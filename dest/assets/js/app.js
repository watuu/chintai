(function () {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties$1(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass$1(e, r, t) {
    return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var jquery = {exports: {}};

  /*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   */

  (function (module) {
  	( function( global, factory ) {

  		{

  			// For CommonJS and CommonJS-like environments where a proper `window`
  			// is present, execute the factory and get jQuery.
  			// For environments that do not have a `window` with a `document`
  			// (such as Node.js), expose a factory as module.exports.
  			// This accentuates the need for the creation of a real `window`.
  			// e.g. var jQuery = require("jquery")(window);
  			// See ticket trac-14549 for more info.
  			module.exports = global.document ?
  				factory( global, true ) :
  				function( w ) {
  					if ( !w.document ) {
  						throw new Error( "jQuery requires a window with a document" );
  					}
  					return factory( w );
  				};
  		}

  	// Pass this if window is not defined yet
  	} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  	var arr = [];

  	var getProto = Object.getPrototypeOf;

  	var slice = arr.slice;

  	var flat = arr.flat ? function( array ) {
  		return arr.flat.call( array );
  	} : function( array ) {
  		return arr.concat.apply( [], array );
  	};


  	var push = arr.push;

  	var indexOf = arr.indexOf;

  	var class2type = {};

  	var toString = class2type.toString;

  	var hasOwn = class2type.hasOwnProperty;

  	var fnToString = hasOwn.toString;

  	var ObjectFunctionString = fnToString.call( Object );

  	var support = {};

  	var isFunction = function isFunction( obj ) {

  			// Support: Chrome <=57, Firefox <=52
  			// In some browsers, typeof returns "function" for HTML <object> elements
  			// (i.e., `typeof document.createElement( "object" ) === "function"`).
  			// We don't want to classify *any* DOM node as a function.
  			// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
  			// Plus for old WebKit, typeof returns "function" for HTML collections
  			// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
  			return typeof obj === "function" && typeof obj.nodeType !== "number" &&
  				typeof obj.item !== "function";
  		};


  	var isWindow = function isWindow( obj ) {
  			return obj != null && obj === obj.window;
  		};


  	var document = window.document;



  		var preservedScriptAttributes = {
  			type: true,
  			src: true,
  			nonce: true,
  			noModule: true
  		};

  		function DOMEval( code, node, doc ) {
  			doc = doc || document;

  			var i, val,
  				script = doc.createElement( "script" );

  			script.text = code;
  			if ( node ) {
  				for ( i in preservedScriptAttributes ) {

  					// Support: Firefox 64+, Edge 18+
  					// Some browsers don't support the "nonce" property on scripts.
  					// On the other hand, just using `getAttribute` is not enough as
  					// the `nonce` attribute is reset to an empty string whenever it
  					// becomes browsing-context connected.
  					// See https://github.com/whatwg/html/issues/2369
  					// See https://html.spec.whatwg.org/#nonce-attributes
  					// The `node.getAttribute` check was added for the sake of
  					// `jQuery.globalEval` so that it can fake a nonce-containing node
  					// via an object.
  					val = node[ i ] || node.getAttribute && node.getAttribute( i );
  					if ( val ) {
  						script.setAttribute( i, val );
  					}
  				}
  			}
  			doc.head.appendChild( script ).parentNode.removeChild( script );
  		}


  	function toType( obj ) {
  		if ( obj == null ) {
  			return obj + "";
  		}

  		// Support: Android <=2.3 only (functionish RegExp)
  		return typeof obj === "object" || typeof obj === "function" ?
  			class2type[ toString.call( obj ) ] || "object" :
  			typeof obj;
  	}
  	/* global Symbol */
  	// Defining this global in .eslintrc.json would create a danger of using the global
  	// unguarded in another place, it seems safer to define global only for this module



  	var version = "3.7.1",

  		rhtmlSuffix = /HTML$/i,

  		// Define a local copy of jQuery
  		jQuery = function( selector, context ) {

  			// The jQuery object is actually just the init constructor 'enhanced'
  			// Need init if jQuery is called (just allow error to be thrown if not included)
  			return new jQuery.fn.init( selector, context );
  		};

  	jQuery.fn = jQuery.prototype = {

  		// The current version of jQuery being used
  		jquery: version,

  		constructor: jQuery,

  		// The default length of a jQuery object is 0
  		length: 0,

  		toArray: function() {
  			return slice.call( this );
  		},

  		// Get the Nth element in the matched element set OR
  		// Get the whole matched element set as a clean array
  		get: function( num ) {

  			// Return all the elements in a clean array
  			if ( num == null ) {
  				return slice.call( this );
  			}

  			// Return just the one element from the set
  			return num < 0 ? this[ num + this.length ] : this[ num ];
  		},

  		// Take an array of elements and push it onto the stack
  		// (returning the new matched element set)
  		pushStack: function( elems ) {

  			// Build a new jQuery matched element set
  			var ret = jQuery.merge( this.constructor(), elems );

  			// Add the old object onto the stack (as a reference)
  			ret.prevObject = this;

  			// Return the newly-formed element set
  			return ret;
  		},

  		// Execute a callback for every element in the matched set.
  		each: function( callback ) {
  			return jQuery.each( this, callback );
  		},

  		map: function( callback ) {
  			return this.pushStack( jQuery.map( this, function( elem, i ) {
  				return callback.call( elem, i, elem );
  			} ) );
  		},

  		slice: function() {
  			return this.pushStack( slice.apply( this, arguments ) );
  		},

  		first: function() {
  			return this.eq( 0 );
  		},

  		last: function() {
  			return this.eq( -1 );
  		},

  		even: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return ( i + 1 ) % 2;
  			} ) );
  		},

  		odd: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return i % 2;
  			} ) );
  		},

  		eq: function( i ) {
  			var len = this.length,
  				j = +i + ( i < 0 ? len : 0 );
  			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  		},

  		end: function() {
  			return this.prevObject || this.constructor();
  		},

  		// For internal use only.
  		// Behaves like an Array's method, not like a jQuery method.
  		push: push,
  		sort: arr.sort,
  		splice: arr.splice
  	};

  	jQuery.extend = jQuery.fn.extend = function() {
  		var options, name, src, copy, copyIsArray, clone,
  			target = arguments[ 0 ] || {},
  			i = 1,
  			length = arguments.length,
  			deep = false;

  		// Handle a deep copy situation
  		if ( typeof target === "boolean" ) {
  			deep = target;

  			// Skip the boolean and the target
  			target = arguments[ i ] || {};
  			i++;
  		}

  		// Handle case when target is a string or something (possible in deep copy)
  		if ( typeof target !== "object" && !isFunction( target ) ) {
  			target = {};
  		}

  		// Extend jQuery itself if only one argument is passed
  		if ( i === length ) {
  			target = this;
  			i--;
  		}

  		for ( ; i < length; i++ ) {

  			// Only deal with non-null/undefined values
  			if ( ( options = arguments[ i ] ) != null ) {

  				// Extend the base object
  				for ( name in options ) {
  					copy = options[ name ];

  					// Prevent Object.prototype pollution
  					// Prevent never-ending loop
  					if ( name === "__proto__" || target === copy ) {
  						continue;
  					}

  					// Recurse if we're merging plain objects or arrays
  					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  						( copyIsArray = Array.isArray( copy ) ) ) ) {
  						src = target[ name ];

  						// Ensure proper type for the source value
  						if ( copyIsArray && !Array.isArray( src ) ) {
  							clone = [];
  						} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  							clone = {};
  						} else {
  							clone = src;
  						}
  						copyIsArray = false;

  						// Never move original objects, clone them
  						target[ name ] = jQuery.extend( deep, clone, copy );

  					// Don't bring in undefined values
  					} else if ( copy !== undefined ) {
  						target[ name ] = copy;
  					}
  				}
  			}
  		}

  		// Return the modified object
  		return target;
  	};

  	jQuery.extend( {

  		// Unique for each copy of jQuery on the page
  		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  		// Assume jQuery is ready without the ready module
  		isReady: true,

  		error: function( msg ) {
  			throw new Error( msg );
  		},

  		noop: function() {},

  		isPlainObject: function( obj ) {
  			var proto, Ctor;

  			// Detect obvious negatives
  			// Use toString instead of jQuery.type to catch host objects
  			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  				return false;
  			}

  			proto = getProto( obj );

  			// Objects with no prototype (e.g., `Object.create( null )`) are plain
  			if ( !proto ) {
  				return true;
  			}

  			// Objects with prototype are plain iff they were constructed by a global Object function
  			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  		},

  		isEmptyObject: function( obj ) {
  			var name;

  			for ( name in obj ) {
  				return false;
  			}
  			return true;
  		},

  		// Evaluates a script in a provided context; falls back to the global one
  		// if not specified.
  		globalEval: function( code, options, doc ) {
  			DOMEval( code, { nonce: options && options.nonce }, doc );
  		},

  		each: function( obj, callback ) {
  			var length, i = 0;

  			if ( isArrayLike( obj ) ) {
  				length = obj.length;
  				for ( ; i < length; i++ ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			} else {
  				for ( i in obj ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			}

  			return obj;
  		},


  		// Retrieve the text value of an array of DOM nodes
  		text: function( elem ) {
  			var node,
  				ret = "",
  				i = 0,
  				nodeType = elem.nodeType;

  			if ( !nodeType ) {

  				// If no nodeType, this is expected to be an array
  				while ( ( node = elem[ i++ ] ) ) {

  					// Do not traverse comment nodes
  					ret += jQuery.text( node );
  				}
  			}
  			if ( nodeType === 1 || nodeType === 11 ) {
  				return elem.textContent;
  			}
  			if ( nodeType === 9 ) {
  				return elem.documentElement.textContent;
  			}
  			if ( nodeType === 3 || nodeType === 4 ) {
  				return elem.nodeValue;
  			}

  			// Do not include comment or processing instruction nodes

  			return ret;
  		},

  		// results is for internal usage only
  		makeArray: function( arr, results ) {
  			var ret = results || [];

  			if ( arr != null ) {
  				if ( isArrayLike( Object( arr ) ) ) {
  					jQuery.merge( ret,
  						typeof arr === "string" ?
  							[ arr ] : arr
  					);
  				} else {
  					push.call( ret, arr );
  				}
  			}

  			return ret;
  		},

  		inArray: function( elem, arr, i ) {
  			return arr == null ? -1 : indexOf.call( arr, elem, i );
  		},

  		isXMLDoc: function( elem ) {
  			var namespace = elem && elem.namespaceURI,
  				docElem = elem && ( elem.ownerDocument || elem ).documentElement;

  			// Assume HTML when documentElement doesn't yet exist, such as inside
  			// document fragments.
  			return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
  		},

  		// Support: Android <=4.0 only, PhantomJS 1 only
  		// push.apply(_, arraylike) throws on ancient WebKit
  		merge: function( first, second ) {
  			var len = +second.length,
  				j = 0,
  				i = first.length;

  			for ( ; j < len; j++ ) {
  				first[ i++ ] = second[ j ];
  			}

  			first.length = i;

  			return first;
  		},

  		grep: function( elems, callback, invert ) {
  			var callbackInverse,
  				matches = [],
  				i = 0,
  				length = elems.length,
  				callbackExpect = !invert;

  			// Go through the array, only saving the items
  			// that pass the validator function
  			for ( ; i < length; i++ ) {
  				callbackInverse = !callback( elems[ i ], i );
  				if ( callbackInverse !== callbackExpect ) {
  					matches.push( elems[ i ] );
  				}
  			}

  			return matches;
  		},

  		// arg is for internal usage only
  		map: function( elems, callback, arg ) {
  			var length, value,
  				i = 0,
  				ret = [];

  			// Go through the array, translating each of the items to their new values
  			if ( isArrayLike( elems ) ) {
  				length = elems.length;
  				for ( ; i < length; i++ ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}

  			// Go through every key on the object,
  			} else {
  				for ( i in elems ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}
  			}

  			// Flatten any nested arrays
  			return flat( ret );
  		},

  		// A global GUID counter for objects
  		guid: 1,

  		// jQuery.support is not used in Core but other projects attach their
  		// properties to it so it needs to exist.
  		support: support
  	} );

  	if ( typeof Symbol === "function" ) {
  		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  	}

  	// Populate the class2type map
  	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  		function( _i, name ) {
  			class2type[ "[object " + name + "]" ] = name.toLowerCase();
  		} );

  	function isArrayLike( obj ) {

  		// Support: real iOS 8.2 only (not reproducible in simulator)
  		// `in` check used to prevent JIT error (gh-2145)
  		// hasOwn isn't used here due to false negatives
  		// regarding Nodelist length in IE
  		var length = !!obj && "length" in obj && obj.length,
  			type = toType( obj );

  		if ( isFunction( obj ) || isWindow( obj ) ) {
  			return false;
  		}

  		return type === "array" || length === 0 ||
  			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  	}


  	function nodeName( elem, name ) {

  		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  	}
  	var pop = arr.pop;


  	var sort = arr.sort;


  	var splice = arr.splice;


  	var whitespace = "[\\x20\\t\\r\\n\\f]";


  	var rtrimCSS = new RegExp(
  		"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
  		"g"
  	);




  	// Note: an element does not contain itself
  	jQuery.contains = function( a, b ) {
  		var bup = b && b.parentNode;

  		return a === bup || !!( bup && bup.nodeType === 1 && (

  			// Support: IE 9 - 11+
  			// IE doesn't have `contains` on SVG.
  			a.contains ?
  				a.contains( bup ) :
  				a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  		) );
  	};




  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

  	function fcssescape( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	}

  	jQuery.escapeSelector = function( sel ) {
  		return ( sel + "" ).replace( rcssescape, fcssescape );
  	};




  	var preferredDoc = document,
  		pushNative = push;

  	( function() {

  	var i,
  		Expr,
  		outermostContext,
  		sortInput,
  		hasDuplicate,
  		push = pushNative,

  		// Local document vars
  		document,
  		documentElement,
  		documentIsHTML,
  		rbuggyQSA,
  		matches,

  		// Instance-specific data
  		expando = jQuery.expando,
  		dirruns = 0,
  		done = 0,
  		classCache = createCache(),
  		tokenCache = createCache(),
  		compilerCache = createCache(),
  		nonnativeSelectorCache = createCache(),
  		sortOrder = function( a, b ) {
  			if ( a === b ) {
  				hasDuplicate = true;
  			}
  			return 0;
  		},

  		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
  			"loop|multiple|open|readonly|required|scoped",

  		// Regular expressions

  		// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  		identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  		// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
  		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

  			// Operator (capture 2)
  			"*([*^$|!~]?=)" + whitespace +

  			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
  			whitespace + "*\\]",

  		pseudos = ":(" + identifier + ")(?:\\((" +

  			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  			// 1. quoted (capture 3; capture 4 or capture 5)
  			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

  			// 2. simple (capture 6)
  			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

  			// 3. anything else (capture 2)
  			".*" +
  			")\\)|)",

  		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  		rwhitespace = new RegExp( whitespace + "+", "g" ),

  		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  		rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
  			whitespace + "*" ),
  		rdescend = new RegExp( whitespace + "|>" ),

  		rpseudo = new RegExp( pseudos ),
  		ridentifier = new RegExp( "^" + identifier + "$" ),

  		matchExpr = {
  			ID: new RegExp( "^#(" + identifier + ")" ),
  			CLASS: new RegExp( "^\\.(" + identifier + ")" ),
  			TAG: new RegExp( "^(" + identifier + "|[*])" ),
  			ATTR: new RegExp( "^" + attributes ),
  			PSEUDO: new RegExp( "^" + pseudos ),
  			CHILD: new RegExp(
  				"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
  					whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
  					whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  			bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

  			// For use in libraries implementing .is()
  			// We use this for POS matching in `select`
  			needsContext: new RegExp( "^" + whitespace +
  				"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
  				"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  		},

  		rinputs = /^(?:input|select|textarea|button)$/i,
  		rheader = /^h\d$/i,

  		// Easily-parseable/retrievable ID or TAG or CLASS selectors
  		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  		rsibling = /[+~]/,

  		// CSS escapes
  		// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  		runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\([^\\r\\n\\f])", "g" ),
  		funescape = function( escape, nonHex ) {
  			var high = "0x" + escape.slice( 1 ) - 0x10000;

  			if ( nonHex ) {

  				// Strip the backslash prefix from a non-hex escape sequence
  				return nonHex;
  			}

  			// Replace a hexadecimal escape sequence with the encoded Unicode code point
  			// Support: IE <=11+
  			// For values outside the Basic Multilingual Plane (BMP), manually construct a
  			// surrogate pair
  			return high < 0 ?
  				String.fromCharCode( high + 0x10000 ) :
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  		},

  		// Used for iframes; see `setDocument`.
  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Removing the function wrapper causes a "Permission Denied"
  		// error in IE/Edge.
  		unloadHandler = function() {
  			setDocument();
  		},

  		inDisabledFieldset = addCombinator(
  			function( elem ) {
  				return elem.disabled === true && nodeName( elem, "fieldset" );
  			},
  			{ dir: "parentNode", next: "legend" }
  		);

  	// Support: IE <=9 only
  	// Accessing document.activeElement can throw unexpectedly
  	// https://bugs.jquery.com/ticket/13393
  	function safeActiveElement() {
  		try {
  			return document.activeElement;
  		} catch ( err ) { }
  	}

  	// Optimize for push.apply( _, NodeList )
  	try {
  		push.apply(
  			( arr = slice.call( preferredDoc.childNodes ) ),
  			preferredDoc.childNodes
  		);

  		// Support: Android <=4.0
  		// Detect silently failing push.apply
  		// eslint-disable-next-line no-unused-expressions
  		arr[ preferredDoc.childNodes.length ].nodeType;
  	} catch ( e ) {
  		push = {
  			apply: function( target, els ) {
  				pushNative.apply( target, slice.call( els ) );
  			},
  			call: function( target ) {
  				pushNative.apply( target, slice.call( arguments, 1 ) );
  			}
  		};
  	}

  	function find( selector, context, results, seed ) {
  		var m, i, elem, nid, match, groups, newSelector,
  			newContext = context && context.ownerDocument,

  			// nodeType defaults to 9, since context defaults to document
  			nodeType = context ? context.nodeType : 9;

  		results = results || [];

  		// Return early from calls with invalid selector or context
  		if ( typeof selector !== "string" || !selector ||
  			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  			return results;
  		}

  		// Try to shortcut find operations (as opposed to filters) in HTML documents
  		if ( !seed ) {
  			setDocument( context );
  			context = context || document;

  			if ( documentIsHTML ) {

  				// If the selector is sufficiently simple, try using a "get*By*" DOM method
  				// (excepting DocumentFragment context, where the methods don't exist)
  				if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

  					// ID selector
  					if ( ( m = match[ 1 ] ) ) {

  						// Document context
  						if ( nodeType === 9 ) {
  							if ( ( elem = context.getElementById( m ) ) ) {

  								// Support: IE 9 only
  								// getElementById can match elements by name instead of ID
  								if ( elem.id === m ) {
  									push.call( results, elem );
  									return results;
  								}
  							} else {
  								return results;
  							}

  						// Element context
  						} else {

  							// Support: IE 9 only
  							// getElementById can match elements by name instead of ID
  							if ( newContext && ( elem = newContext.getElementById( m ) ) &&
  								find.contains( context, elem ) &&
  								elem.id === m ) {

  								push.call( results, elem );
  								return results;
  							}
  						}

  					// Type selector
  					} else if ( match[ 2 ] ) {
  						push.apply( results, context.getElementsByTagName( selector ) );
  						return results;

  					// Class selector
  					} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
  						push.apply( results, context.getElementsByClassName( m ) );
  						return results;
  					}
  				}

  				// Take advantage of querySelectorAll
  				if ( !nonnativeSelectorCache[ selector + " " ] &&
  					( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

  					newSelector = selector;
  					newContext = context;

  					// qSA considers elements outside a scoping root when evaluating child or
  					// descendant combinators, which is not what we want.
  					// In such cases, we work around the behavior by prefixing every selector in the
  					// list with an ID selector referencing the scope context.
  					// The technique has to be used as well when a leading combinator is used
  					// as such selectors are not recognized by querySelectorAll.
  					// Thanks to Andrew Dupont for this technique.
  					if ( nodeType === 1 &&
  						( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

  						// Expand context for sibling selectors
  						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  							context;

  						// We can use :scope instead of the ID hack if the browser
  						// supports it & if we're not changing the context.
  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when
  						// strict-comparing two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( newContext != context || !support.scope ) {

  							// Capture the context ID, setting it first if necessary
  							if ( ( nid = context.getAttribute( "id" ) ) ) {
  								nid = jQuery.escapeSelector( nid );
  							} else {
  								context.setAttribute( "id", ( nid = expando ) );
  							}
  						}

  						// Prefix every selector in the list
  						groups = tokenize( selector );
  						i = groups.length;
  						while ( i-- ) {
  							groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
  								toSelector( groups[ i ] );
  						}
  						newSelector = groups.join( "," );
  					}

  					try {
  						push.apply( results,
  							newContext.querySelectorAll( newSelector )
  						);
  						return results;
  					} catch ( qsaError ) {
  						nonnativeSelectorCache( selector, true );
  					} finally {
  						if ( nid === expando ) {
  							context.removeAttribute( "id" );
  						}
  					}
  				}
  			}
  		}

  		// All others
  		return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
  	}

  	/**
  	 * Create key-value caches of limited size
  	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
  	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  	 *	deleting the oldest entry
  	 */
  	function createCache() {
  		var keys = [];

  		function cache( key, value ) {

  			// Use (key + " ") to avoid collision with native prototype properties
  			// (see https://github.com/jquery/sizzle/issues/157)
  			if ( keys.push( key + " " ) > Expr.cacheLength ) {

  				// Only keep the most recent entries
  				delete cache[ keys.shift() ];
  			}
  			return ( cache[ key + " " ] = value );
  		}
  		return cache;
  	}

  	/**
  	 * Mark a function for special use by jQuery selector module
  	 * @param {Function} fn The function to mark
  	 */
  	function markFunction( fn ) {
  		fn[ expando ] = true;
  		return fn;
  	}

  	/**
  	 * Support testing using an element
  	 * @param {Function} fn Passed the created element and returns a boolean result
  	 */
  	function assert( fn ) {
  		var el = document.createElement( "fieldset" );

  		try {
  			return !!fn( el );
  		} catch ( e ) {
  			return false;
  		} finally {

  			// Remove from its parent by default
  			if ( el.parentNode ) {
  				el.parentNode.removeChild( el );
  			}

  			// release memory in IE
  			el = null;
  		}
  	}

  	/**
  	 * Returns a function to use in pseudos for input types
  	 * @param {String} type
  	 */
  	function createInputPseudo( type ) {
  		return function( elem ) {
  			return nodeName( elem, "input" ) && elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for buttons
  	 * @param {String} type
  	 */
  	function createButtonPseudo( type ) {
  		return function( elem ) {
  			return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
  				elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for :enabled/:disabled
  	 * @param {Boolean} disabled true for :disabled; false for :enabled
  	 */
  	function createDisabledPseudo( disabled ) {

  		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  		return function( elem ) {

  			// Only certain elements can match :enabled or :disabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  			if ( "form" in elem ) {

  				// Check for inherited disabledness on relevant non-disabled elements:
  				// * listed form-associated elements in a disabled fieldset
  				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  				// * option elements in a disabled optgroup
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  				// All such elements have a "form" property.
  				if ( elem.parentNode && elem.disabled === false ) {

  					// Option elements defer to a parent optgroup if present
  					if ( "label" in elem ) {
  						if ( "label" in elem.parentNode ) {
  							return elem.parentNode.disabled === disabled;
  						} else {
  							return elem.disabled === disabled;
  						}
  					}

  					// Support: IE 6 - 11+
  					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  					return elem.isDisabled === disabled ||

  						// Where there is no isDisabled, check manually
  						elem.isDisabled !== !disabled &&
  							inDisabledFieldset( elem ) === disabled;
  				}

  				return elem.disabled === disabled;

  			// Try to winnow out elements that can't be disabled before trusting the disabled property.
  			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  			// even exist on them, let alone have a boolean value.
  			} else if ( "label" in elem ) {
  				return elem.disabled === disabled;
  			}

  			// Remaining elements are neither :enabled nor :disabled
  			return false;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for positionals
  	 * @param {Function} fn
  	 */
  	function createPositionalPseudo( fn ) {
  		return markFunction( function( argument ) {
  			argument = +argument;
  			return markFunction( function( seed, matches ) {
  				var j,
  					matchIndexes = fn( [], seed.length, argument ),
  					i = matchIndexes.length;

  				// Match elements found at the specified indexes
  				while ( i-- ) {
  					if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
  						seed[ j ] = !( matches[ j ] = seed[ j ] );
  					}
  				}
  			} );
  		} );
  	}

  	/**
  	 * Checks a node for validity as a jQuery selector context
  	 * @param {Element|Object=} context
  	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
  	 */
  	function testContext( context ) {
  		return context && typeof context.getElementsByTagName !== "undefined" && context;
  	}

  	/**
  	 * Sets document-related variables once based on the current document
  	 * @param {Element|Object} [node] An element or document object to use to set the document
  	 * @returns {Object} Returns the current document
  	 */
  	function setDocument( node ) {
  		var subWindow,
  			doc = node ? node.ownerDocument || node : preferredDoc;

  		// Return early if doc is invalid or already selected
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
  			return document;
  		}

  		// Update global variables
  		document = doc;
  		documentElement = document.documentElement;
  		documentIsHTML = !jQuery.isXMLDoc( document );

  		// Support: iOS 7 only, IE 9 - 11+
  		// Older browsers didn't support unprefixed `matches`.
  		matches = documentElement.matches ||
  			documentElement.webkitMatchesSelector ||
  			documentElement.msMatchesSelector;

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Accessing iframe documents after unload throws "permission denied" errors
  		// (see trac-13936).
  		// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
  		// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
  		if ( documentElement.msMatchesSelector &&

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			preferredDoc != document &&
  			( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

  			// Support: IE 9 - 11+, Edge 12 - 18+
  			subWindow.addEventListener( "unload", unloadHandler );
  		}

  		// Support: IE <10
  		// Check if getElementById returns elements by name
  		// The broken getElementById methods don't pick up programmatically-set names,
  		// so use a roundabout getElementsByName test
  		support.getById = assert( function( el ) {
  			documentElement.appendChild( el ).id = jQuery.expando;
  			return !document.getElementsByName ||
  				!document.getElementsByName( jQuery.expando ).length;
  		} );

  		// Support: IE 9 only
  		// Check to see if it's possible to do matchesSelector
  		// on a disconnected node.
  		support.disconnectedMatch = assert( function( el ) {
  			return matches.call( el, "*" );
  		} );

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// IE/Edge don't support the :scope pseudo-class.
  		support.scope = assert( function() {
  			return document.querySelectorAll( ":scope" );
  		} );

  		// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
  		// Make sure the `:has()` argument is parsed unforgivingly.
  		// We include `*` in the test to detect buggy implementations that are
  		// _selectively_ forgiving (specifically when the list includes at least
  		// one valid selector).
  		// Note that we treat complete lack of support for `:has()` as if it were
  		// spec-compliant support, which is fine because use of `:has()` in such
  		// environments will fail in the qSA path and fall back to jQuery traversal
  		// anyway.
  		support.cssHas = assert( function() {
  			try {
  				document.querySelector( ":has(*,:jqfake)" );
  				return false;
  			} catch ( e ) {
  				return true;
  			}
  		} );

  		// ID filter and find
  		if ( support.getById ) {
  			Expr.filter.ID = function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					return elem.getAttribute( "id" ) === attrId;
  				};
  			};
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var elem = context.getElementById( id );
  					return elem ? [ elem ] : [];
  				}
  			};
  		} else {
  			Expr.filter.ID =  function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					var node = typeof elem.getAttributeNode !== "undefined" &&
  						elem.getAttributeNode( "id" );
  					return node && node.value === attrId;
  				};
  			};

  			// Support: IE 6 - 7 only
  			// getElementById is not reliable as a find shortcut
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var node, i, elems,
  						elem = context.getElementById( id );

  					if ( elem ) {

  						// Verify the id attribute
  						node = elem.getAttributeNode( "id" );
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}

  						// Fall back on getElementsByName
  						elems = context.getElementsByName( id );
  						i = 0;
  						while ( ( elem = elems[ i++ ] ) ) {
  							node = elem.getAttributeNode( "id" );
  							if ( node && node.value === id ) {
  								return [ elem ];
  							}
  						}
  					}

  					return [];
  				}
  			};
  		}

  		// Tag
  		Expr.find.TAG = function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else {
  				return context.querySelectorAll( tag );
  			}
  		};

  		// Class
  		Expr.find.CLASS = function( className, context ) {
  			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  				return context.getElementsByClassName( className );
  			}
  		};

  		/* QSA/matchesSelector
  		---------------------------------------------------------------------- */

  		// QSA and matchesSelector support

  		rbuggyQSA = [];

  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert( function( el ) {

  			var input;

  			documentElement.appendChild( el ).innerHTML =
  				"<a id='" + expando + "' href='' disabled='disabled'></a>" +
  				"<select id='" + expando + "-\r\\' disabled='disabled'>" +
  				"<option selected=''></option></select>";

  			// Support: iOS <=7 - 8 only
  			// Boolean attributes and "value" are not treated correctly in some XML documents
  			if ( !el.querySelectorAll( "[selected]" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: iOS <=7 - 8 only
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push( "~=" );
  			}

  			// Support: iOS 8 only
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push( ".#.+[+~]" );
  			}

  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			if ( !el.querySelectorAll( ":checked" ).length ) {
  				rbuggyQSA.push( ":checked" );
  			}

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			input = document.createElement( "input" );
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE 9 - 11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			documentElement.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE 11+, Edge 15 - 18+
  			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
  			// Adding a temporary attribute to the document before the selection works
  			// around the issue.
  			// Interestingly, IE 10 & older don't seem to have the issue.
  			input = document.createElement( "input" );
  			input.setAttribute( "name", "" );
  			el.appendChild( input );
  			if ( !el.querySelectorAll( "[name='']" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
  					whitespace + "*(?:''|\"\")" );
  			}
  		} );

  		if ( !support.cssHas ) {

  			// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
  			// Our regular `try-catch` mechanism fails to detect natively-unsupported
  			// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
  			// in browsers that parse the `:has()` argument as a forgiving selector list.
  			// https://drafts.csswg.org/selectors/#relational now requires the argument
  			// to be parsed unforgivingly, but browsers have not yet fully adjusted.
  			rbuggyQSA.push( ":has" );
  		}

  		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

  		/* Sorting
  		---------------------------------------------------------------------- */

  		// Document order sorting
  		sortOrder = function( a, b ) {

  			// Flag for duplicate removal
  			if ( a === b ) {
  				hasDuplicate = true;
  				return 0;
  			}

  			// Sort on method existence if only one input has compareDocumentPosition
  			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  			if ( compare ) {
  				return compare;
  			}

  			// Calculate position if both inputs belong to the same document
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
  				a.compareDocumentPosition( b ) :

  				// Otherwise we know they are disconnected
  				1;

  			// Disconnected nodes
  			if ( compare & 1 ||
  				( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

  				// Choose the first element that is related to our preferred document
  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( a === document || a.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, a ) ) {
  					return -1;
  				}

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( b === document || b.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, b ) ) {
  					return 1;
  				}

  				// Maintain original order
  				return sortInput ?
  					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
  					0;
  			}

  			return compare & 4 ? -1 : 1;
  		};

  		return document;
  	}

  	find.matches = function( expr, elements ) {
  		return find( expr, null, null, elements );
  	};

  	find.matchesSelector = function( elem, expr ) {
  		setDocument( elem );

  		if ( documentIsHTML &&
  			!nonnativeSelectorCache[ expr + " " ] &&
  			( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

  			try {
  				var ret = matches.call( elem, expr );

  				// IE 9's matchesSelector returns false on disconnected nodes
  				if ( ret || support.disconnectedMatch ||

  						// As well, disconnected nodes are said to be in a document
  						// fragment in IE 9
  						elem.document && elem.document.nodeType !== 11 ) {
  					return ret;
  				}
  			} catch ( e ) {
  				nonnativeSelectorCache( expr, true );
  			}
  		}

  		return find( expr, document, null, [ elem ] ).length > 0;
  	};

  	find.contains = function( context, elem ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( context.ownerDocument || context ) != document ) {
  			setDocument( context );
  		}
  		return jQuery.contains( context, elem );
  	};


  	find.attr = function( elem, name ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( elem.ownerDocument || elem ) != document ) {
  			setDocument( elem );
  		}

  		var fn = Expr.attrHandle[ name.toLowerCase() ],

  			// Don't get fooled by Object.prototype properties (see trac-13807)
  			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  				fn( elem, name, !documentIsHTML ) :
  				undefined;

  		if ( val !== undefined ) {
  			return val;
  		}

  		return elem.getAttribute( name );
  	};

  	find.error = function( msg ) {
  		throw new Error( "Syntax error, unrecognized expression: " + msg );
  	};

  	/**
  	 * Document sorting and removing duplicates
  	 * @param {ArrayLike} results
  	 */
  	jQuery.uniqueSort = function( results ) {
  		var elem,
  			duplicates = [],
  			j = 0,
  			i = 0;

  		// Unless we *know* we can detect duplicates, assume their presence
  		//
  		// Support: Android <=4.0+
  		// Testing for detecting duplicates is unpredictable so instead assume we can't
  		// depend on duplicate detection in all browsers without a stable sort.
  		hasDuplicate = !support.sortStable;
  		sortInput = !support.sortStable && slice.call( results, 0 );
  		sort.call( results, sortOrder );

  		if ( hasDuplicate ) {
  			while ( ( elem = results[ i++ ] ) ) {
  				if ( elem === results[ i ] ) {
  					j = duplicates.push( i );
  				}
  			}
  			while ( j-- ) {
  				splice.call( results, duplicates[ j ], 1 );
  			}
  		}

  		// Clear input after sorting to release objects
  		// See https://github.com/jquery/sizzle/pull/225
  		sortInput = null;

  		return results;
  	};

  	jQuery.fn.uniqueSort = function() {
  		return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
  	};

  	Expr = jQuery.expr = {

  		// Can be adjusted by the user
  		cacheLength: 50,

  		createPseudo: markFunction,

  		match: matchExpr,

  		attrHandle: {},

  		find: {},

  		relative: {
  			">": { dir: "parentNode", first: true },
  			" ": { dir: "parentNode" },
  			"+": { dir: "previousSibling", first: true },
  			"~": { dir: "previousSibling" }
  		},

  		preFilter: {
  			ATTR: function( match ) {
  				match[ 1 ] = match[ 1 ].replace( runescape, funescape );

  				// Move the given value to match[3] whether quoted or unquoted
  				match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
  					.replace( runescape, funescape );

  				if ( match[ 2 ] === "~=" ) {
  					match[ 3 ] = " " + match[ 3 ] + " ";
  				}

  				return match.slice( 0, 4 );
  			},

  			CHILD: function( match ) {

  				/* matches from matchExpr["CHILD"]
  					1 type (only|nth|...)
  					2 what (child|of-type)
  					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  					4 xn-component of xn+y argument ([+-]?\d*n|)
  					5 sign of xn-component
  					6 x of xn-component
  					7 sign of y-component
  					8 y of y-component
  				*/
  				match[ 1 ] = match[ 1 ].toLowerCase();

  				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

  					// nth-* requires argument
  					if ( !match[ 3 ] ) {
  						find.error( match[ 0 ] );
  					}

  					// numeric x and y parameters for Expr.filter.CHILD
  					// remember that false/true cast respectively to 0/1
  					match[ 4 ] = +( match[ 4 ] ?
  						match[ 5 ] + ( match[ 6 ] || 1 ) :
  						2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
  					);
  					match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

  				// other types prohibit arguments
  				} else if ( match[ 3 ] ) {
  					find.error( match[ 0 ] );
  				}

  				return match;
  			},

  			PSEUDO: function( match ) {
  				var excess,
  					unquoted = !match[ 6 ] && match[ 2 ];

  				if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
  					return null;
  				}

  				// Accept quoted arguments as-is
  				if ( match[ 3 ] ) {
  					match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

  				// Strip excess characters from unquoted arguments
  				} else if ( unquoted && rpseudo.test( unquoted ) &&

  					// Get excess from tokenize (recursively)
  					( excess = tokenize( unquoted, true ) ) &&

  					// advance to the next closing parenthesis
  					( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

  					// excess is a negative index
  					match[ 0 ] = match[ 0 ].slice( 0, excess );
  					match[ 2 ] = unquoted.slice( 0, excess );
  				}

  				// Return only captures needed by the pseudo filter method (type and argument)
  				return match.slice( 0, 3 );
  			}
  		},

  		filter: {

  			TAG: function( nodeNameSelector ) {
  				var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  				return nodeNameSelector === "*" ?
  					function() {
  						return true;
  					} :
  					function( elem ) {
  						return nodeName( elem, expectedNodeName );
  					};
  			},

  			CLASS: function( className ) {
  				var pattern = classCache[ className + " " ];

  				return pattern ||
  					( pattern = new RegExp( "(^|" + whitespace + ")" + className +
  						"(" + whitespace + "|$)" ) ) &&
  					classCache( className, function( elem ) {
  						return pattern.test(
  							typeof elem.className === "string" && elem.className ||
  								typeof elem.getAttribute !== "undefined" &&
  									elem.getAttribute( "class" ) ||
  								""
  						);
  					} );
  			},

  			ATTR: function( name, operator, check ) {
  				return function( elem ) {
  					var result = find.attr( elem, name );

  					if ( result == null ) {
  						return operator === "!=";
  					}
  					if ( !operator ) {
  						return true;
  					}

  					result += "";

  					if ( operator === "=" ) {
  						return result === check;
  					}
  					if ( operator === "!=" ) {
  						return result !== check;
  					}
  					if ( operator === "^=" ) {
  						return check && result.indexOf( check ) === 0;
  					}
  					if ( operator === "*=" ) {
  						return check && result.indexOf( check ) > -1;
  					}
  					if ( operator === "$=" ) {
  						return check && result.slice( -check.length ) === check;
  					}
  					if ( operator === "~=" ) {
  						return ( " " + result.replace( rwhitespace, " " ) + " " )
  							.indexOf( check ) > -1;
  					}
  					if ( operator === "|=" ) {
  						return result === check || result.slice( 0, check.length + 1 ) === check + "-";
  					}

  					return false;
  				};
  			},

  			CHILD: function( type, what, _argument, first, last ) {
  				var simple = type.slice( 0, 3 ) !== "nth",
  					forward = type.slice( -4 ) !== "last",
  					ofType = what === "of-type";

  				return first === 1 && last === 0 ?

  					// Shortcut for :nth-*(n)
  					function( elem ) {
  						return !!elem.parentNode;
  					} :

  					function( elem, _context, xml ) {
  						var cache, outerCache, node, nodeIndex, start,
  							dir = simple !== forward ? "nextSibling" : "previousSibling",
  							parent = elem.parentNode,
  							name = ofType && elem.nodeName.toLowerCase(),
  							useCache = !xml && !ofType,
  							diff = false;

  						if ( parent ) {

  							// :(first|last|only)-(child|of-type)
  							if ( simple ) {
  								while ( dir ) {
  									node = elem;
  									while ( ( node = node[ dir ] ) ) {
  										if ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) {

  											return false;
  										}
  									}

  									// Reverse direction for :only-* (if we haven't yet done so)
  									start = dir = type === "only" && !start && "nextSibling";
  								}
  								return true;
  							}

  							start = [ forward ? parent.firstChild : parent.lastChild ];

  							// non-xml :nth-child(...) stores cache data on `parent`
  							if ( forward && useCache ) {

  								// Seek `elem` from a previously-cached index
  								outerCache = parent[ expando ] || ( parent[ expando ] = {} );
  								cache = outerCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex && cache[ 2 ];
  								node = nodeIndex && parent.childNodes[ nodeIndex ];

  								while ( ( node = ++nodeIndex && node && node[ dir ] ||

  									// Fallback to seeking `elem` from the start
  									( diff = nodeIndex = 0 ) || start.pop() ) ) {

  									// When found, cache indexes on `parent` and break
  									if ( node.nodeType === 1 && ++diff && node === elem ) {
  										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
  										break;
  									}
  								}

  							} else {

  								// Use previously-cached element index if available
  								if ( useCache ) {
  									outerCache = elem[ expando ] || ( elem[ expando ] = {} );
  									cache = outerCache[ type ] || [];
  									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  									diff = nodeIndex;
  								}

  								// xml :nth-child(...)
  								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  								if ( diff === false ) {

  									// Use the same loop as above to seek `elem` from the start
  									while ( ( node = ++nodeIndex && node && node[ dir ] ||
  										( diff = nodeIndex = 0 ) || start.pop() ) ) {

  										if ( ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) &&
  											++diff ) {

  											// Cache the index of each encountered element
  											if ( useCache ) {
  												outerCache = node[ expando ] ||
  													( node[ expando ] = {} );
  												outerCache[ type ] = [ dirruns, diff ];
  											}

  											if ( node === elem ) {
  												break;
  											}
  										}
  									}
  								}
  							}

  							// Incorporate the offset, then check against cycle size
  							diff -= last;
  							return diff === first || ( diff % first === 0 && diff / first >= 0 );
  						}
  					};
  			},

  			PSEUDO: function( pseudo, argument ) {

  				// pseudo-class names are case-insensitive
  				// https://www.w3.org/TR/selectors/#pseudo-classes
  				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  				// Remember that setFilters inherits from pseudos
  				var args,
  					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  						find.error( "unsupported pseudo: " + pseudo );

  				// The user may use createPseudo to indicate that
  				// arguments are needed to create the filter function
  				// just as jQuery does
  				if ( fn[ expando ] ) {
  					return fn( argument );
  				}

  				// But maintain support for old signatures
  				if ( fn.length > 1 ) {
  					args = [ pseudo, pseudo, "", argument ];
  					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  						markFunction( function( seed, matches ) {
  							var idx,
  								matched = fn( seed, argument ),
  								i = matched.length;
  							while ( i-- ) {
  								idx = indexOf.call( seed, matched[ i ] );
  								seed[ idx ] = !( matches[ idx ] = matched[ i ] );
  							}
  						} ) :
  						function( elem ) {
  							return fn( elem, 0, args );
  						};
  				}

  				return fn;
  			}
  		},

  		pseudos: {

  			// Potentially complex pseudos
  			not: markFunction( function( selector ) {

  				// Trim the selector passed to compile
  				// to avoid treating leading and trailing
  				// spaces as combinators
  				var input = [],
  					results = [],
  					matcher = compile( selector.replace( rtrimCSS, "$1" ) );

  				return matcher[ expando ] ?
  					markFunction( function( seed, matches, _context, xml ) {
  						var elem,
  							unmatched = matcher( seed, null, xml, [] ),
  							i = seed.length;

  						// Match elements unmatched by `matcher`
  						while ( i-- ) {
  							if ( ( elem = unmatched[ i ] ) ) {
  								seed[ i ] = !( matches[ i ] = elem );
  							}
  						}
  					} ) :
  					function( elem, _context, xml ) {
  						input[ 0 ] = elem;
  						matcher( input, null, xml, results );

  						// Don't keep the element
  						// (see https://github.com/jquery/sizzle/issues/299)
  						input[ 0 ] = null;
  						return !results.pop();
  					};
  			} ),

  			has: markFunction( function( selector ) {
  				return function( elem ) {
  					return find( selector, elem ).length > 0;
  				};
  			} ),

  			contains: markFunction( function( text ) {
  				text = text.replace( runescape, funescape );
  				return function( elem ) {
  					return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
  				};
  			} ),

  			// "Whether an element is represented by a :lang() selector
  			// is based solely on the element's language value
  			// being equal to the identifier C,
  			// or beginning with the identifier C immediately followed by "-".
  			// The matching of C against the element's language value is performed case-insensitively.
  			// The identifier C does not have to be a valid language name."
  			// https://www.w3.org/TR/selectors/#lang-pseudo
  			lang: markFunction( function( lang ) {

  				// lang value must be a valid identifier
  				if ( !ridentifier.test( lang || "" ) ) {
  					find.error( "unsupported lang: " + lang );
  				}
  				lang = lang.replace( runescape, funescape ).toLowerCase();
  				return function( elem ) {
  					var elemLang;
  					do {
  						if ( ( elemLang = documentIsHTML ?
  							elem.lang :
  							elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

  							elemLang = elemLang.toLowerCase();
  							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  						}
  					} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
  					return false;
  				};
  			} ),

  			// Miscellaneous
  			target: function( elem ) {
  				var hash = window.location && window.location.hash;
  				return hash && hash.slice( 1 ) === elem.id;
  			},

  			root: function( elem ) {
  				return elem === documentElement;
  			},

  			focus: function( elem ) {
  				return elem === safeActiveElement() &&
  					document.hasFocus() &&
  					!!( elem.type || elem.href || ~elem.tabIndex );
  			},

  			// Boolean properties
  			enabled: createDisabledPseudo( false ),
  			disabled: createDisabledPseudo( true ),

  			checked: function( elem ) {

  				// In CSS3, :checked should return both checked and selected elements
  				// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  				return ( nodeName( elem, "input" ) && !!elem.checked ) ||
  					( nodeName( elem, "option" ) && !!elem.selected );
  			},

  			selected: function( elem ) {

  				// Support: IE <=11+
  				// Accessing the selectedIndex property
  				// forces the browser to treat the default option as
  				// selected when in an optgroup.
  				if ( elem.parentNode ) {
  					// eslint-disable-next-line no-unused-expressions
  					elem.parentNode.selectedIndex;
  				}

  				return elem.selected === true;
  			},

  			// Contents
  			empty: function( elem ) {

  				// https://www.w3.org/TR/selectors/#empty-pseudo
  				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  				//   but not by others (comment: 8; processing instruction: 7; etc.)
  				// nodeType < 6 works because attributes (2) do not appear as children
  				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  					if ( elem.nodeType < 6 ) {
  						return false;
  					}
  				}
  				return true;
  			},

  			parent: function( elem ) {
  				return !Expr.pseudos.empty( elem );
  			},

  			// Element/input types
  			header: function( elem ) {
  				return rheader.test( elem.nodeName );
  			},

  			input: function( elem ) {
  				return rinputs.test( elem.nodeName );
  			},

  			button: function( elem ) {
  				return nodeName( elem, "input" ) && elem.type === "button" ||
  					nodeName( elem, "button" );
  			},

  			text: function( elem ) {
  				var attr;
  				return nodeName( elem, "input" ) && elem.type === "text" &&

  					// Support: IE <10 only
  					// New HTML5 attribute values (e.g., "search") appear
  					// with elem.type === "text"
  					( ( attr = elem.getAttribute( "type" ) ) == null ||
  						attr.toLowerCase() === "text" );
  			},

  			// Position-in-collection
  			first: createPositionalPseudo( function() {
  				return [ 0 ];
  			} ),

  			last: createPositionalPseudo( function( _matchIndexes, length ) {
  				return [ length - 1 ];
  			} ),

  			eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
  				return [ argument < 0 ? argument + length : argument ];
  			} ),

  			even: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 0;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			odd: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 1;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i;

  				if ( argument < 0 ) {
  					i = argument + length;
  				} else if ( argument > length ) {
  					i = length;
  				} else {
  					i = argument;
  				}

  				for ( ; --i >= 0; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i = argument < 0 ? argument + length : argument;
  				for ( ; ++i < length; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} )
  		}
  	};

  	Expr.pseudos.nth = Expr.pseudos.eq;

  	// Add button/input type pseudos
  	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  		Expr.pseudos[ i ] = createInputPseudo( i );
  	}
  	for ( i in { submit: true, reset: true } ) {
  		Expr.pseudos[ i ] = createButtonPseudo( i );
  	}

  	// Easy API for creating new setFilters
  	function setFilters() {}
  	setFilters.prototype = Expr.filters = Expr.pseudos;
  	Expr.setFilters = new setFilters();

  	function tokenize( selector, parseOnly ) {
  		var matched, match, tokens, type,
  			soFar, groups, preFilters,
  			cached = tokenCache[ selector + " " ];

  		if ( cached ) {
  			return parseOnly ? 0 : cached.slice( 0 );
  		}

  		soFar = selector;
  		groups = [];
  		preFilters = Expr.preFilter;

  		while ( soFar ) {

  			// Comma and first run
  			if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
  				if ( match ) {

  					// Don't consume trailing commas as valid
  					soFar = soFar.slice( match[ 0 ].length ) || soFar;
  				}
  				groups.push( ( tokens = [] ) );
  			}

  			matched = false;

  			// Combinators
  			if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
  				matched = match.shift();
  				tokens.push( {
  					value: matched,

  					// Cast descendant combinators to space
  					type: match[ 0 ].replace( rtrimCSS, " " )
  				} );
  				soFar = soFar.slice( matched.length );
  			}

  			// Filters
  			for ( type in Expr.filter ) {
  				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
  					( match = preFilters[ type ]( match ) ) ) ) {
  					matched = match.shift();
  					tokens.push( {
  						value: matched,
  						type: type,
  						matches: match
  					} );
  					soFar = soFar.slice( matched.length );
  				}
  			}

  			if ( !matched ) {
  				break;
  			}
  		}

  		// Return the length of the invalid excess
  		// if we're just parsing
  		// Otherwise, throw an error or return tokens
  		if ( parseOnly ) {
  			return soFar.length;
  		}

  		return soFar ?
  			find.error( selector ) :

  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  	}

  	function toSelector( tokens ) {
  		var i = 0,
  			len = tokens.length,
  			selector = "";
  		for ( ; i < len; i++ ) {
  			selector += tokens[ i ].value;
  		}
  		return selector;
  	}

  	function addCombinator( matcher, combinator, base ) {
  		var dir = combinator.dir,
  			skip = combinator.next,
  			key = skip || dir,
  			checkNonElements = base && key === "parentNode",
  			doneName = done++;

  		return combinator.first ?

  			// Check against closest ancestor/preceding element
  			function( elem, context, xml ) {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						return matcher( elem, context, xml );
  					}
  				}
  				return false;
  			} :

  			// Check against all ancestor/preceding elements
  			function( elem, context, xml ) {
  				var oldCache, outerCache,
  					newCache = [ dirruns, doneName ];

  				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  				if ( xml ) {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							if ( matcher( elem, context, xml ) ) {
  								return true;
  							}
  						}
  					}
  				} else {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							outerCache = elem[ expando ] || ( elem[ expando ] = {} );

  							if ( skip && nodeName( elem, skip ) ) {
  								elem = elem[ dir ] || elem;
  							} else if ( ( oldCache = outerCache[ key ] ) &&
  								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  								// Assign to newCache so results back-propagate to previous elements
  								return ( newCache[ 2 ] = oldCache[ 2 ] );
  							} else {

  								// Reuse newcache so results back-propagate to previous elements
  								outerCache[ key ] = newCache;

  								// A match means we're done; a fail means we have to keep checking
  								if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
  									return true;
  								}
  							}
  						}
  					}
  				}
  				return false;
  			};
  	}

  	function elementMatcher( matchers ) {
  		return matchers.length > 1 ?
  			function( elem, context, xml ) {
  				var i = matchers.length;
  				while ( i-- ) {
  					if ( !matchers[ i ]( elem, context, xml ) ) {
  						return false;
  					}
  				}
  				return true;
  			} :
  			matchers[ 0 ];
  	}

  	function multipleContexts( selector, contexts, results ) {
  		var i = 0,
  			len = contexts.length;
  		for ( ; i < len; i++ ) {
  			find( selector, contexts[ i ], results );
  		}
  		return results;
  	}

  	function condense( unmatched, map, filter, context, xml ) {
  		var elem,
  			newUnmatched = [],
  			i = 0,
  			len = unmatched.length,
  			mapped = map != null;

  		for ( ; i < len; i++ ) {
  			if ( ( elem = unmatched[ i ] ) ) {
  				if ( !filter || filter( elem, context, xml ) ) {
  					newUnmatched.push( elem );
  					if ( mapped ) {
  						map.push( i );
  					}
  				}
  			}
  		}

  		return newUnmatched;
  	}

  	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  		if ( postFilter && !postFilter[ expando ] ) {
  			postFilter = setMatcher( postFilter );
  		}
  		if ( postFinder && !postFinder[ expando ] ) {
  			postFinder = setMatcher( postFinder, postSelector );
  		}
  		return markFunction( function( seed, results, context, xml ) {
  			var temp, i, elem, matcherOut,
  				preMap = [],
  				postMap = [],
  				preexisting = results.length,

  				// Get initial elements from seed or context
  				elems = seed ||
  					multipleContexts( selector || "*",
  						context.nodeType ? [ context ] : context, [] ),

  				// Prefilter to get matcher input, preserving a map for seed-results synchronization
  				matcherIn = preFilter && ( seed || !selector ) ?
  					condense( elems, preMap, preFilter, context, xml ) :
  					elems;

  			if ( matcher ) {

  				// If we have a postFinder, or filtered seed, or non-seed postFilter
  				// or preexisting results,
  				matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results;

  				// Find primary matches
  				matcher( matcherIn, matcherOut, context, xml );
  			} else {
  				matcherOut = matcherIn;
  			}

  			// Apply postFilter
  			if ( postFilter ) {
  				temp = condense( matcherOut, postMap );
  				postFilter( temp, [], context, xml );

  				// Un-match failing elements by moving them back to matcherIn
  				i = temp.length;
  				while ( i-- ) {
  					if ( ( elem = temp[ i ] ) ) {
  						matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
  					}
  				}
  			}

  			if ( seed ) {
  				if ( postFinder || preFilter ) {
  					if ( postFinder ) {

  						// Get the final matcherOut by condensing this intermediate into postFinder contexts
  						temp = [];
  						i = matcherOut.length;
  						while ( i-- ) {
  							if ( ( elem = matcherOut[ i ] ) ) {

  								// Restore matcherIn since elem is not yet a final match
  								temp.push( ( matcherIn[ i ] = elem ) );
  							}
  						}
  						postFinder( null, ( matcherOut = [] ), temp, xml );
  					}

  					// Move matched elements from seed to results to keep them synchronized
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( ( elem = matcherOut[ i ] ) &&
  							( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

  							seed[ temp ] = !( results[ temp ] = elem );
  						}
  					}
  				}

  			// Add elements to results, through postFinder if defined
  			} else {
  				matcherOut = condense(
  					matcherOut === results ?
  						matcherOut.splice( preexisting, matcherOut.length ) :
  						matcherOut
  				);
  				if ( postFinder ) {
  					postFinder( null, results, matcherOut, xml );
  				} else {
  					push.apply( results, matcherOut );
  				}
  			}
  		} );
  	}

  	function matcherFromTokens( tokens ) {
  		var checkContext, matcher, j,
  			len = tokens.length,
  			leadingRelative = Expr.relative[ tokens[ 0 ].type ],
  			implicitRelative = leadingRelative || Expr.relative[ " " ],
  			i = leadingRelative ? 1 : 0,

  			// The foundational matcher ensures that elements are reachable from top-level context(s)
  			matchContext = addCombinator( function( elem ) {
  				return elem === checkContext;
  			}, implicitRelative, true ),
  			matchAnyContext = addCombinator( function( elem ) {
  				return indexOf.call( checkContext, elem ) > -1;
  			}, implicitRelative, true ),
  			matchers = [ function( elem, context, xml ) {

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
  					( checkContext = context ).nodeType ?
  						matchContext( elem, context, xml ) :
  						matchAnyContext( elem, context, xml ) );

  				// Avoid hanging onto element
  				// (see https://github.com/jquery/sizzle/issues/299)
  				checkContext = null;
  				return ret;
  			} ];

  		for ( ; i < len; i++ ) {
  			if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
  				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
  			} else {
  				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

  				// Return special upon seeing a positional matcher
  				if ( matcher[ expando ] ) {

  					// Find the next relative operator (if any) for proper handling
  					j = ++i;
  					for ( ; j < len; j++ ) {
  						if ( Expr.relative[ tokens[ j ].type ] ) {
  							break;
  						}
  					}
  					return setMatcher(
  						i > 1 && elementMatcher( matchers ),
  						i > 1 && toSelector(

  							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  							tokens.slice( 0, i - 1 )
  								.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
  						).replace( rtrimCSS, "$1" ),
  						matcher,
  						i < j && matcherFromTokens( tokens.slice( i, j ) ),
  						j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
  						j < len && toSelector( tokens )
  					);
  				}
  				matchers.push( matcher );
  			}
  		}

  		return elementMatcher( matchers );
  	}

  	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  		var bySet = setMatchers.length > 0,
  			byElement = elementMatchers.length > 0,
  			superMatcher = function( seed, context, xml, results, outermost ) {
  				var elem, j, matcher,
  					matchedCount = 0,
  					i = "0",
  					unmatched = seed && [],
  					setMatched = [],
  					contextBackup = outermostContext,

  					// We must always have either seed elements or outermost context
  					elems = seed || byElement && Expr.find.TAG( "*", outermost ),

  					// Use integer dirruns iff this is the outermost matcher
  					dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
  					len = elems.length;

  				if ( outermost ) {

  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  					// two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					outermostContext = context == document || context || outermost;
  				}

  				// Add elements passing elementMatchers directly to results
  				// Support: iOS <=7 - 9 only
  				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
  				// elements by id. (see trac-14142)
  				for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
  					if ( byElement && elem ) {
  						j = 0;

  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  						// two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( !context && elem.ownerDocument != document ) {
  							setDocument( elem );
  							xml = !documentIsHTML;
  						}
  						while ( ( matcher = elementMatchers[ j++ ] ) ) {
  							if ( matcher( elem, context || document, xml ) ) {
  								push.call( results, elem );
  								break;
  							}
  						}
  						if ( outermost ) {
  							dirruns = dirrunsUnique;
  						}
  					}

  					// Track unmatched elements for set filters
  					if ( bySet ) {

  						// They will have gone through all possible matchers
  						if ( ( elem = !matcher && elem ) ) {
  							matchedCount--;
  						}

  						// Lengthen the array for every element, matched or not
  						if ( seed ) {
  							unmatched.push( elem );
  						}
  					}
  				}

  				// `i` is now the count of elements visited above, and adding it to `matchedCount`
  				// makes the latter nonnegative.
  				matchedCount += i;

  				// Apply set filters to unmatched elements
  				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  				// no element matchers and no seed.
  				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  				// numerically zero.
  				if ( bySet && i !== matchedCount ) {
  					j = 0;
  					while ( ( matcher = setMatchers[ j++ ] ) ) {
  						matcher( unmatched, setMatched, context, xml );
  					}

  					if ( seed ) {

  						// Reintegrate element matches to eliminate the need for sorting
  						if ( matchedCount > 0 ) {
  							while ( i-- ) {
  								if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
  									setMatched[ i ] = pop.call( results );
  								}
  							}
  						}

  						// Discard index placeholder values to get only actual matches
  						setMatched = condense( setMatched );
  					}

  					// Add matches to results
  					push.apply( results, setMatched );

  					// Seedless set matches succeeding multiple successful matchers stipulate sorting
  					if ( outermost && !seed && setMatched.length > 0 &&
  						( matchedCount + setMatchers.length ) > 1 ) {

  						jQuery.uniqueSort( results );
  					}
  				}

  				// Override manipulation of globals by nested matchers
  				if ( outermost ) {
  					dirruns = dirrunsUnique;
  					outermostContext = contextBackup;
  				}

  				return unmatched;
  			};

  		return bySet ?
  			markFunction( superMatcher ) :
  			superMatcher;
  	}

  	function compile( selector, match /* Internal Use Only */ ) {
  		var i,
  			setMatchers = [],
  			elementMatchers = [],
  			cached = compilerCache[ selector + " " ];

  		if ( !cached ) {

  			// Generate a function of recursive functions that can be used to check each element
  			if ( !match ) {
  				match = tokenize( selector );
  			}
  			i = match.length;
  			while ( i-- ) {
  				cached = matcherFromTokens( match[ i ] );
  				if ( cached[ expando ] ) {
  					setMatchers.push( cached );
  				} else {
  					elementMatchers.push( cached );
  				}
  			}

  			// Cache the compiled function
  			cached = compilerCache( selector,
  				matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  			// Save selector and tokenization
  			cached.selector = selector;
  		}
  		return cached;
  	}

  	/**
  	 * A low-level selection function that works with jQuery's compiled
  	 *  selector functions
  	 * @param {String|Function} selector A selector or a pre-compiled
  	 *  selector function built with jQuery selector compile
  	 * @param {Element} context
  	 * @param {Array} [results]
  	 * @param {Array} [seed] A set of elements to match against
  	 */
  	function select( selector, context, results, seed ) {
  		var i, tokens, token, type, find,
  			compiled = typeof selector === "function" && selector,
  			match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  		results = results || [];

  		// Try to minimize operations if there is only one selector in the list and no seed
  		// (the latter of which guarantees us context)
  		if ( match.length === 1 ) {

  			// Reduce context if the leading compound selector is an ID
  			tokens = match[ 0 ] = match[ 0 ].slice( 0 );
  			if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
  					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

  				context = ( Expr.find.ID(
  					token.matches[ 0 ].replace( runescape, funescape ),
  					context
  				) || [] )[ 0 ];
  				if ( !context ) {
  					return results;

  				// Precompiled matchers will still verify ancestry, so step up a level
  				} else if ( compiled ) {
  					context = context.parentNode;
  				}

  				selector = selector.slice( tokens.shift().value.length );
  			}

  			// Fetch a seed set for right-to-left matching
  			i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
  			while ( i-- ) {
  				token = tokens[ i ];

  				// Abort if we hit a combinator
  				if ( Expr.relative[ ( type = token.type ) ] ) {
  					break;
  				}
  				if ( ( find = Expr.find[ type ] ) ) {

  					// Search, expanding context for leading sibling combinators
  					if ( ( seed = find(
  						token.matches[ 0 ].replace( runescape, funescape ),
  						rsibling.test( tokens[ 0 ].type ) &&
  							testContext( context.parentNode ) || context
  					) ) ) {

  						// If seed is empty or no tokens remain, we can return early
  						tokens.splice( i, 1 );
  						selector = seed.length && toSelector( tokens );
  						if ( !selector ) {
  							push.apply( results, seed );
  							return results;
  						}

  						break;
  					}
  				}
  			}
  		}

  		// Compile and execute a filtering function if one is not provided
  		// Provide `match` to avoid retokenization if we modified the selector above
  		( compiled || compile( selector, match ) )(
  			seed,
  			context,
  			!documentIsHTML,
  			results,
  			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  		);
  		return results;
  	}

  	// One-time assignments

  	// Support: Android <=4.0 - 4.1+
  	// Sort stability
  	support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

  	// Initialize against the default document
  	setDocument();

  	// Support: Android <=4.0 - 4.1+
  	// Detached nodes confoundingly follow *each other*
  	support.sortDetached = assert( function( el ) {

  		// Should return 1, but returns 4 (following)
  		return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  	} );

  	jQuery.find = find;

  	// Deprecated
  	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  	jQuery.unique = jQuery.uniqueSort;

  	// These have always been private, but they used to be documented as part of
  	// Sizzle so let's maintain them for now for backwards compatibility purposes.
  	find.compile = compile;
  	find.select = select;
  	find.setDocument = setDocument;
  	find.tokenize = tokenize;

  	find.escape = jQuery.escapeSelector;
  	find.getText = jQuery.text;
  	find.isXML = jQuery.isXMLDoc;
  	find.selectors = jQuery.expr;
  	find.support = jQuery.support;
  	find.uniqueSort = jQuery.uniqueSort;

  		/* eslint-enable */

  	} )();


  	var dir = function( elem, dir, until ) {
  		var matched = [],
  			truncate = until !== undefined;

  		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  			if ( elem.nodeType === 1 ) {
  				if ( truncate && jQuery( elem ).is( until ) ) {
  					break;
  				}
  				matched.push( elem );
  			}
  		}
  		return matched;
  	};


  	var siblings = function( n, elem ) {
  		var matched = [];

  		for ( ; n; n = n.nextSibling ) {
  			if ( n.nodeType === 1 && n !== elem ) {
  				matched.push( n );
  			}
  		}

  		return matched;
  	};


  	var rneedsContext = jQuery.expr.match.needsContext;

  	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  	// Implement the identical functionality for filter and not
  	function winnow( elements, qualifier, not ) {
  		if ( isFunction( qualifier ) ) {
  			return jQuery.grep( elements, function( elem, i ) {
  				return !!qualifier.call( elem, i, elem ) !== not;
  			} );
  		}

  		// Single element
  		if ( qualifier.nodeType ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( elem === qualifier ) !== not;
  			} );
  		}

  		// Arraylike of elements (jQuery, arguments, Array)
  		if ( typeof qualifier !== "string" ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  			} );
  		}

  		// Filtered directly for both simple and complex selectors
  		return jQuery.filter( qualifier, elements, not );
  	}

  	jQuery.filter = function( expr, elems, not ) {
  		var elem = elems[ 0 ];

  		if ( not ) {
  			expr = ":not(" + expr + ")";
  		}

  		if ( elems.length === 1 && elem.nodeType === 1 ) {
  			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  		}

  		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  			return elem.nodeType === 1;
  		} ) );
  	};

  	jQuery.fn.extend( {
  		find: function( selector ) {
  			var i, ret,
  				len = this.length,
  				self = this;

  			if ( typeof selector !== "string" ) {
  				return this.pushStack( jQuery( selector ).filter( function() {
  					for ( i = 0; i < len; i++ ) {
  						if ( jQuery.contains( self[ i ], this ) ) {
  							return true;
  						}
  					}
  				} ) );
  			}

  			ret = this.pushStack( [] );

  			for ( i = 0; i < len; i++ ) {
  				jQuery.find( selector, self[ i ], ret );
  			}

  			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  		},
  		filter: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], false ) );
  		},
  		not: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], true ) );
  		},
  		is: function( selector ) {
  			return !!winnow(
  				this,

  				// If this is a positional/relative selector, check membership in the returned set
  				// so $("p:first").is("p:last") won't return true for a doc with two "p".
  				typeof selector === "string" && rneedsContext.test( selector ) ?
  					jQuery( selector ) :
  					selector || [],
  				false
  			).length;
  		}
  	} );


  	// Initialize a jQuery object


  	// A central reference to the root jQuery(document)
  	var rootjQuery,

  		// A simple way to check for HTML strings
  		// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
  		// Strict HTML recognition (trac-11290: must start with <)
  		// Shortcut simple #id case for speed
  		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  		init = jQuery.fn.init = function( selector, context, root ) {
  			var match, elem;

  			// HANDLE: $(""), $(null), $(undefined), $(false)
  			if ( !selector ) {
  				return this;
  			}

  			// Method init() accepts an alternate rootjQuery
  			// so migrate can support jQuery.sub (gh-2101)
  			root = root || rootjQuery;

  			// Handle HTML strings
  			if ( typeof selector === "string" ) {
  				if ( selector[ 0 ] === "<" &&
  					selector[ selector.length - 1 ] === ">" &&
  					selector.length >= 3 ) {

  					// Assume that strings that start and end with <> are HTML and skip the regex check
  					match = [ null, selector, null ];

  				} else {
  					match = rquickExpr.exec( selector );
  				}

  				// Match html or make sure no context is specified for #id
  				if ( match && ( match[ 1 ] || !context ) ) {

  					// HANDLE: $(html) -> $(array)
  					if ( match[ 1 ] ) {
  						context = context instanceof jQuery ? context[ 0 ] : context;

  						// Option to run scripts is true for back-compat
  						// Intentionally let the error be thrown if parseHTML is not present
  						jQuery.merge( this, jQuery.parseHTML(
  							match[ 1 ],
  							context && context.nodeType ? context.ownerDocument || context : document,
  							true
  						) );

  						// HANDLE: $(html, props)
  						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  							for ( match in context ) {

  								// Properties of context are called as methods if possible
  								if ( isFunction( this[ match ] ) ) {
  									this[ match ]( context[ match ] );

  								// ...and otherwise set as attributes
  								} else {
  									this.attr( match, context[ match ] );
  								}
  							}
  						}

  						return this;

  					// HANDLE: $(#id)
  					} else {
  						elem = document.getElementById( match[ 2 ] );

  						if ( elem ) {

  							// Inject the element directly into the jQuery object
  							this[ 0 ] = elem;
  							this.length = 1;
  						}
  						return this;
  					}

  				// HANDLE: $(expr, $(...))
  				} else if ( !context || context.jquery ) {
  					return ( context || root ).find( selector );

  				// HANDLE: $(expr, context)
  				// (which is just equivalent to: $(context).find(expr)
  				} else {
  					return this.constructor( context ).find( selector );
  				}

  			// HANDLE: $(DOMElement)
  			} else if ( selector.nodeType ) {
  				this[ 0 ] = selector;
  				this.length = 1;
  				return this;

  			// HANDLE: $(function)
  			// Shortcut for document ready
  			} else if ( isFunction( selector ) ) {
  				return root.ready !== undefined ?
  					root.ready( selector ) :

  					// Execute immediately if ready is not present
  					selector( jQuery );
  			}

  			return jQuery.makeArray( selector, this );
  		};

  	// Give the init function the jQuery prototype for later instantiation
  	init.prototype = jQuery.fn;

  	// Initialize central reference
  	rootjQuery = jQuery( document );


  	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  		// Methods guaranteed to produce a unique set when starting from a unique set
  		guaranteedUnique = {
  			children: true,
  			contents: true,
  			next: true,
  			prev: true
  		};

  	jQuery.fn.extend( {
  		has: function( target ) {
  			var targets = jQuery( target, this ),
  				l = targets.length;

  			return this.filter( function() {
  				var i = 0;
  				for ( ; i < l; i++ ) {
  					if ( jQuery.contains( this, targets[ i ] ) ) {
  						return true;
  					}
  				}
  			} );
  		},

  		closest: function( selectors, context ) {
  			var cur,
  				i = 0,
  				l = this.length,
  				matched = [],
  				targets = typeof selectors !== "string" && jQuery( selectors );

  			// Positional selectors never match, since there's no _selection_ context
  			if ( !rneedsContext.test( selectors ) ) {
  				for ( ; i < l; i++ ) {
  					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  						// Always skip document fragments
  						if ( cur.nodeType < 11 && ( targets ?
  							targets.index( cur ) > -1 :

  							// Don't pass non-elements to jQuery#find
  							cur.nodeType === 1 &&
  								jQuery.find.matchesSelector( cur, selectors ) ) ) {

  							matched.push( cur );
  							break;
  						}
  					}
  				}
  			}

  			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  		},

  		// Determine the position of an element within the set
  		index: function( elem ) {

  			// No argument, return index in parent
  			if ( !elem ) {
  				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  			}

  			// Index in selector
  			if ( typeof elem === "string" ) {
  				return indexOf.call( jQuery( elem ), this[ 0 ] );
  			}

  			// Locate the position of the desired element
  			return indexOf.call( this,

  				// If it receives a jQuery object, the first element is used
  				elem.jquery ? elem[ 0 ] : elem
  			);
  		},

  		add: function( selector, context ) {
  			return this.pushStack(
  				jQuery.uniqueSort(
  					jQuery.merge( this.get(), jQuery( selector, context ) )
  				)
  			);
  		},

  		addBack: function( selector ) {
  			return this.add( selector == null ?
  				this.prevObject : this.prevObject.filter( selector )
  			);
  		}
  	} );

  	function sibling( cur, dir ) {
  		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  		return cur;
  	}

  	jQuery.each( {
  		parent: function( elem ) {
  			var parent = elem.parentNode;
  			return parent && parent.nodeType !== 11 ? parent : null;
  		},
  		parents: function( elem ) {
  			return dir( elem, "parentNode" );
  		},
  		parentsUntil: function( elem, _i, until ) {
  			return dir( elem, "parentNode", until );
  		},
  		next: function( elem ) {
  			return sibling( elem, "nextSibling" );
  		},
  		prev: function( elem ) {
  			return sibling( elem, "previousSibling" );
  		},
  		nextAll: function( elem ) {
  			return dir( elem, "nextSibling" );
  		},
  		prevAll: function( elem ) {
  			return dir( elem, "previousSibling" );
  		},
  		nextUntil: function( elem, _i, until ) {
  			return dir( elem, "nextSibling", until );
  		},
  		prevUntil: function( elem, _i, until ) {
  			return dir( elem, "previousSibling", until );
  		},
  		siblings: function( elem ) {
  			return siblings( ( elem.parentNode || {} ).firstChild, elem );
  		},
  		children: function( elem ) {
  			return siblings( elem.firstChild );
  		},
  		contents: function( elem ) {
  			if ( elem.contentDocument != null &&

  				// Support: IE 11+
  				// <object> elements with no `data` attribute has an object
  				// `contentDocument` with a `null` prototype.
  				getProto( elem.contentDocument ) ) {

  				return elem.contentDocument;
  			}

  			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  			// Treat the template element as a regular one in browsers that
  			// don't support it.
  			if ( nodeName( elem, "template" ) ) {
  				elem = elem.content || elem;
  			}

  			return jQuery.merge( [], elem.childNodes );
  		}
  	}, function( name, fn ) {
  		jQuery.fn[ name ] = function( until, selector ) {
  			var matched = jQuery.map( this, fn, until );

  			if ( name.slice( -5 ) !== "Until" ) {
  				selector = until;
  			}

  			if ( selector && typeof selector === "string" ) {
  				matched = jQuery.filter( selector, matched );
  			}

  			if ( this.length > 1 ) {

  				// Remove duplicates
  				if ( !guaranteedUnique[ name ] ) {
  					jQuery.uniqueSort( matched );
  				}

  				// Reverse order for parents* and prev-derivatives
  				if ( rparentsprev.test( name ) ) {
  					matched.reverse();
  				}
  			}

  			return this.pushStack( matched );
  		};
  	} );
  	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  	// Convert String-formatted options into Object-formatted ones
  	function createOptions( options ) {
  		var object = {};
  		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  			object[ flag ] = true;
  		} );
  		return object;
  	}

  	/*
  	 * Create a callback list using the following parameters:
  	 *
  	 *	options: an optional list of space-separated options that will change how
  	 *			the callback list behaves or a more traditional option object
  	 *
  	 * By default a callback list will act like an event callback list and can be
  	 * "fired" multiple times.
  	 *
  	 * Possible options:
  	 *
  	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
  	 *
  	 *	memory:			will keep track of previous values and will call any callback added
  	 *					after the list has been fired right away with the latest "memorized"
  	 *					values (like a Deferred)
  	 *
  	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  	 *
  	 *	stopOnFalse:	interrupt callings when a callback returns false
  	 *
  	 */
  	jQuery.Callbacks = function( options ) {

  		// Convert options from String-formatted to Object-formatted if needed
  		// (we check in cache first)
  		options = typeof options === "string" ?
  			createOptions( options ) :
  			jQuery.extend( {}, options );

  		var // Flag to know if list is currently firing
  			firing,

  			// Last fire value for non-forgettable lists
  			memory,

  			// Flag to know if list was already fired
  			fired,

  			// Flag to prevent firing
  			locked,

  			// Actual callback list
  			list = [],

  			// Queue of execution data for repeatable lists
  			queue = [],

  			// Index of currently firing callback (modified by add/remove as needed)
  			firingIndex = -1,

  			// Fire callbacks
  			fire = function() {

  				// Enforce single-firing
  				locked = locked || options.once;

  				// Execute callbacks for all pending executions,
  				// respecting firingIndex overrides and runtime changes
  				fired = firing = true;
  				for ( ; queue.length; firingIndex = -1 ) {
  					memory = queue.shift();
  					while ( ++firingIndex < list.length ) {

  						// Run callback and check for early termination
  						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  							options.stopOnFalse ) {

  							// Jump to end and forget the data so .add doesn't re-fire
  							firingIndex = list.length;
  							memory = false;
  						}
  					}
  				}

  				// Forget the data if we're done with it
  				if ( !options.memory ) {
  					memory = false;
  				}

  				firing = false;

  				// Clean up if we're done firing for good
  				if ( locked ) {

  					// Keep an empty list if we have data for future add calls
  					if ( memory ) {
  						list = [];

  					// Otherwise, this object is spent
  					} else {
  						list = "";
  					}
  				}
  			},

  			// Actual Callbacks object
  			self = {

  				// Add a callback or a collection of callbacks to the list
  				add: function() {
  					if ( list ) {

  						// If we have memory from a past run, we should fire after adding
  						if ( memory && !firing ) {
  							firingIndex = list.length - 1;
  							queue.push( memory );
  						}

  						( function add( args ) {
  							jQuery.each( args, function( _, arg ) {
  								if ( isFunction( arg ) ) {
  									if ( !options.unique || !self.has( arg ) ) {
  										list.push( arg );
  									}
  								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  									// Inspect recursively
  									add( arg );
  								}
  							} );
  						} )( arguments );

  						if ( memory && !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Remove a callback from the list
  				remove: function() {
  					jQuery.each( arguments, function( _, arg ) {
  						var index;
  						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  							list.splice( index, 1 );

  							// Handle firing indexes
  							if ( index <= firingIndex ) {
  								firingIndex--;
  							}
  						}
  					} );
  					return this;
  				},

  				// Check if a given callback is in the list.
  				// If no argument is given, return whether or not list has callbacks attached.
  				has: function( fn ) {
  					return fn ?
  						jQuery.inArray( fn, list ) > -1 :
  						list.length > 0;
  				},

  				// Remove all callbacks from the list
  				empty: function() {
  					if ( list ) {
  						list = [];
  					}
  					return this;
  				},

  				// Disable .fire and .add
  				// Abort any current/pending executions
  				// Clear all callbacks and values
  				disable: function() {
  					locked = queue = [];
  					list = memory = "";
  					return this;
  				},
  				disabled: function() {
  					return !list;
  				},

  				// Disable .fire
  				// Also disable .add unless we have memory (since it would have no effect)
  				// Abort any pending executions
  				lock: function() {
  					locked = queue = [];
  					if ( !memory && !firing ) {
  						list = memory = "";
  					}
  					return this;
  				},
  				locked: function() {
  					return !!locked;
  				},

  				// Call all callbacks with the given context and arguments
  				fireWith: function( context, args ) {
  					if ( !locked ) {
  						args = args || [];
  						args = [ context, args.slice ? args.slice() : args ];
  						queue.push( args );
  						if ( !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Call all the callbacks with the given arguments
  				fire: function() {
  					self.fireWith( this, arguments );
  					return this;
  				},

  				// To know if the callbacks have already been called at least once
  				fired: function() {
  					return !!fired;
  				}
  			};

  		return self;
  	};


  	function Identity( v ) {
  		return v;
  	}
  	function Thrower( ex ) {
  		throw ex;
  	}

  	function adoptValue( value, resolve, reject, noValue ) {
  		var method;

  		try {

  			// Check for promise aspect first to privilege synchronous behavior
  			if ( value && isFunction( ( method = value.promise ) ) ) {
  				method.call( value ).done( resolve ).fail( reject );

  			// Other thenables
  			} else if ( value && isFunction( ( method = value.then ) ) ) {
  				method.call( value, resolve, reject );

  			// Other non-thenables
  			} else {

  				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  				// * false: [ value ].slice( 0 ) => resolve( value )
  				// * true: [ value ].slice( 1 ) => resolve()
  				resolve.apply( undefined, [ value ].slice( noValue ) );
  			}

  		// For Promises/A+, convert exceptions into rejections
  		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  		// Deferred#then to conditionally suppress rejection.
  		} catch ( value ) {

  			// Support: Android 4.0 only
  			// Strict mode functions invoked without .call/.apply get global-object context
  			reject.apply( undefined, [ value ] );
  		}
  	}

  	jQuery.extend( {

  		Deferred: function( func ) {
  			var tuples = [

  					// action, add listener, callbacks,
  					// ... .then handlers, argument index, [final state]
  					[ "notify", "progress", jQuery.Callbacks( "memory" ),
  						jQuery.Callbacks( "memory" ), 2 ],
  					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  				],
  				state = "pending",
  				promise = {
  					state: function() {
  						return state;
  					},
  					always: function() {
  						deferred.done( arguments ).fail( arguments );
  						return this;
  					},
  					"catch": function( fn ) {
  						return promise.then( null, fn );
  					},

  					// Keep pipe for back-compat
  					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  						var fns = arguments;

  						return jQuery.Deferred( function( newDefer ) {
  							jQuery.each( tuples, function( _i, tuple ) {

  								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  								// deferred.progress(function() { bind to newDefer or newDefer.notify })
  								// deferred.done(function() { bind to newDefer or newDefer.resolve })
  								// deferred.fail(function() { bind to newDefer or newDefer.reject })
  								deferred[ tuple[ 1 ] ]( function() {
  									var returned = fn && fn.apply( this, arguments );
  									if ( returned && isFunction( returned.promise ) ) {
  										returned.promise()
  											.progress( newDefer.notify )
  											.done( newDefer.resolve )
  											.fail( newDefer.reject );
  									} else {
  										newDefer[ tuple[ 0 ] + "With" ](
  											this,
  											fn ? [ returned ] : arguments
  										);
  									}
  								} );
  							} );
  							fns = null;
  						} ).promise();
  					},
  					then: function( onFulfilled, onRejected, onProgress ) {
  						var maxDepth = 0;
  						function resolve( depth, deferred, handler, special ) {
  							return function() {
  								var that = this,
  									args = arguments,
  									mightThrow = function() {
  										var returned, then;

  										// Support: Promises/A+ section 2.3.3.3.3
  										// https://promisesaplus.com/#point-59
  										// Ignore double-resolution attempts
  										if ( depth < maxDepth ) {
  											return;
  										}

  										returned = handler.apply( that, args );

  										// Support: Promises/A+ section 2.3.1
  										// https://promisesaplus.com/#point-48
  										if ( returned === deferred.promise() ) {
  											throw new TypeError( "Thenable self-resolution" );
  										}

  										// Support: Promises/A+ sections 2.3.3.1, 3.5
  										// https://promisesaplus.com/#point-54
  										// https://promisesaplus.com/#point-75
  										// Retrieve `then` only once
  										then = returned &&

  											// Support: Promises/A+ section 2.3.4
  											// https://promisesaplus.com/#point-64
  											// Only check objects and functions for thenability
  											( typeof returned === "object" ||
  												typeof returned === "function" ) &&
  											returned.then;

  										// Handle a returned thenable
  										if ( isFunction( then ) ) {

  											// Special processors (notify) just wait for resolution
  											if ( special ) {
  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special )
  												);

  											// Normal processors (resolve) also hook into progress
  											} else {

  												// ...and disregard older resolution values
  												maxDepth++;

  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special ),
  													resolve( maxDepth, deferred, Identity,
  														deferred.notifyWith )
  												);
  											}

  										// Handle all other returned values
  										} else {

  											// Only substitute handlers pass on context
  											// and multiple values (non-spec behavior)
  											if ( handler !== Identity ) {
  												that = undefined;
  												args = [ returned ];
  											}

  											// Process the value(s)
  											// Default process is resolve
  											( special || deferred.resolveWith )( that, args );
  										}
  									},

  									// Only normal processors (resolve) catch and reject exceptions
  									process = special ?
  										mightThrow :
  										function() {
  											try {
  												mightThrow();
  											} catch ( e ) {

  												if ( jQuery.Deferred.exceptionHook ) {
  													jQuery.Deferred.exceptionHook( e,
  														process.error );
  												}

  												// Support: Promises/A+ section 2.3.3.3.4.1
  												// https://promisesaplus.com/#point-61
  												// Ignore post-resolution exceptions
  												if ( depth + 1 >= maxDepth ) {

  													// Only substitute handlers pass on context
  													// and multiple values (non-spec behavior)
  													if ( handler !== Thrower ) {
  														that = undefined;
  														args = [ e ];
  													}

  													deferred.rejectWith( that, args );
  												}
  											}
  										};

  								// Support: Promises/A+ section 2.3.3.3.1
  								// https://promisesaplus.com/#point-57
  								// Re-resolve promises immediately to dodge false rejection from
  								// subsequent errors
  								if ( depth ) {
  									process();
  								} else {

  									// Call an optional hook to record the error, in case of exception
  									// since it's otherwise lost when execution goes async
  									if ( jQuery.Deferred.getErrorHook ) {
  										process.error = jQuery.Deferred.getErrorHook();

  									// The deprecated alias of the above. While the name suggests
  									// returning the stack, not an error instance, jQuery just passes
  									// it directly to `console.warn` so both will work; an instance
  									// just better cooperates with source maps.
  									} else if ( jQuery.Deferred.getStackHook ) {
  										process.error = jQuery.Deferred.getStackHook();
  									}
  									window.setTimeout( process );
  								}
  							};
  						}

  						return jQuery.Deferred( function( newDefer ) {

  							// progress_handlers.add( ... )
  							tuples[ 0 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onProgress ) ?
  										onProgress :
  										Identity,
  									newDefer.notifyWith
  								)
  							);

  							// fulfilled_handlers.add( ... )
  							tuples[ 1 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onFulfilled ) ?
  										onFulfilled :
  										Identity
  								)
  							);

  							// rejected_handlers.add( ... )
  							tuples[ 2 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onRejected ) ?
  										onRejected :
  										Thrower
  								)
  							);
  						} ).promise();
  					},

  					// Get a promise for this deferred
  					// If obj is provided, the promise aspect is added to the object
  					promise: function( obj ) {
  						return obj != null ? jQuery.extend( obj, promise ) : promise;
  					}
  				},
  				deferred = {};

  			// Add list-specific methods
  			jQuery.each( tuples, function( i, tuple ) {
  				var list = tuple[ 2 ],
  					stateString = tuple[ 5 ];

  				// promise.progress = list.add
  				// promise.done = list.add
  				// promise.fail = list.add
  				promise[ tuple[ 1 ] ] = list.add;

  				// Handle state
  				if ( stateString ) {
  					list.add(
  						function() {

  							// state = "resolved" (i.e., fulfilled)
  							// state = "rejected"
  							state = stateString;
  						},

  						// rejected_callbacks.disable
  						// fulfilled_callbacks.disable
  						tuples[ 3 - i ][ 2 ].disable,

  						// rejected_handlers.disable
  						// fulfilled_handlers.disable
  						tuples[ 3 - i ][ 3 ].disable,

  						// progress_callbacks.lock
  						tuples[ 0 ][ 2 ].lock,

  						// progress_handlers.lock
  						tuples[ 0 ][ 3 ].lock
  					);
  				}

  				// progress_handlers.fire
  				// fulfilled_handlers.fire
  				// rejected_handlers.fire
  				list.add( tuple[ 3 ].fire );

  				// deferred.notify = function() { deferred.notifyWith(...) }
  				// deferred.resolve = function() { deferred.resolveWith(...) }
  				// deferred.reject = function() { deferred.rejectWith(...) }
  				deferred[ tuple[ 0 ] ] = function() {
  					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  					return this;
  				};

  				// deferred.notifyWith = list.fireWith
  				// deferred.resolveWith = list.fireWith
  				// deferred.rejectWith = list.fireWith
  				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  			} );

  			// Make the deferred a promise
  			promise.promise( deferred );

  			// Call given func if any
  			if ( func ) {
  				func.call( deferred, deferred );
  			}

  			// All done!
  			return deferred;
  		},

  		// Deferred helper
  		when: function( singleValue ) {
  			var

  				// count of uncompleted subordinates
  				remaining = arguments.length,

  				// count of unprocessed arguments
  				i = remaining,

  				// subordinate fulfillment data
  				resolveContexts = Array( i ),
  				resolveValues = slice.call( arguments ),

  				// the primary Deferred
  				primary = jQuery.Deferred(),

  				// subordinate callback factory
  				updateFunc = function( i ) {
  					return function( value ) {
  						resolveContexts[ i ] = this;
  						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  						if ( !( --remaining ) ) {
  							primary.resolveWith( resolveContexts, resolveValues );
  						}
  					};
  				};

  			// Single- and empty arguments are adopted like Promise.resolve
  			if ( remaining <= 1 ) {
  				adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
  					!remaining );

  				// Use .then() to unwrap secondary thenables (cf. gh-3000)
  				if ( primary.state() === "pending" ||
  					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  					return primary.then();
  				}
  			}

  			// Multiple arguments are aggregated like Promise.all array elements
  			while ( i-- ) {
  				adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
  			}

  			return primary.promise();
  		}
  	} );


  	// These usually indicate a programmer mistake during development,
  	// warn about them ASAP rather than swallowing them by default.
  	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  	// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
  	// captured before the async barrier to get the original error cause
  	// which may otherwise be hidden.
  	jQuery.Deferred.exceptionHook = function( error, asyncError ) {

  		// Support: IE 8 - 9 only
  		// Console exists when dev tools are open, which can happen at any time
  		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  			window.console.warn( "jQuery.Deferred exception: " + error.message,
  				error.stack, asyncError );
  		}
  	};




  	jQuery.readyException = function( error ) {
  		window.setTimeout( function() {
  			throw error;
  		} );
  	};




  	// The deferred used on DOM ready
  	var readyList = jQuery.Deferred();

  	jQuery.fn.ready = function( fn ) {

  		readyList
  			.then( fn )

  			// Wrap jQuery.readyException in a function so that the lookup
  			// happens at the time of error handling instead of callback
  			// registration.
  			.catch( function( error ) {
  				jQuery.readyException( error );
  			} );

  		return this;
  	};

  	jQuery.extend( {

  		// Is the DOM ready to be used? Set to true once it occurs.
  		isReady: false,

  		// A counter to track how many items to wait for before
  		// the ready event fires. See trac-6781
  		readyWait: 1,

  		// Handle when the DOM is ready
  		ready: function( wait ) {

  			// Abort if there are pending holds or we're already ready
  			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  				return;
  			}

  			// Remember that the DOM is ready
  			jQuery.isReady = true;

  			// If a normal DOM Ready event fired, decrement, and wait if need be
  			if ( wait !== true && --jQuery.readyWait > 0 ) {
  				return;
  			}

  			// If there are functions bound, to execute
  			readyList.resolveWith( document, [ jQuery ] );
  		}
  	} );

  	jQuery.ready.then = readyList.then;

  	// The ready event handler and self cleanup method
  	function completed() {
  		document.removeEventListener( "DOMContentLoaded", completed );
  		window.removeEventListener( "load", completed );
  		jQuery.ready();
  	}

  	// Catch cases where $(document).ready() is called
  	// after the browser event has already occurred.
  	// Support: IE <=9 - 10 only
  	// Older IE sometimes signals "interactive" too soon
  	if ( document.readyState === "complete" ||
  		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  		// Handle it asynchronously to allow scripts the opportunity to delay ready
  		window.setTimeout( jQuery.ready );

  	} else {

  		// Use the handy event callback
  		document.addEventListener( "DOMContentLoaded", completed );

  		// A fallback to window.onload, that will always work
  		window.addEventListener( "load", completed );
  	}




  	// Multifunctional method to get and set values of a collection
  	// The value/s can optionally be executed if it's a function
  	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  		var i = 0,
  			len = elems.length,
  			bulk = key == null;

  		// Sets many values
  		if ( toType( key ) === "object" ) {
  			chainable = true;
  			for ( i in key ) {
  				access( elems, fn, i, key[ i ], true, emptyGet, raw );
  			}

  		// Sets one value
  		} else if ( value !== undefined ) {
  			chainable = true;

  			if ( !isFunction( value ) ) {
  				raw = true;
  			}

  			if ( bulk ) {

  				// Bulk operations run against the entire set
  				if ( raw ) {
  					fn.call( elems, value );
  					fn = null;

  				// ...except when executing function values
  				} else {
  					bulk = fn;
  					fn = function( elem, _key, value ) {
  						return bulk.call( jQuery( elem ), value );
  					};
  				}
  			}

  			if ( fn ) {
  				for ( ; i < len; i++ ) {
  					fn(
  						elems[ i ], key, raw ?
  							value :
  							value.call( elems[ i ], i, fn( elems[ i ], key ) )
  					);
  				}
  			}
  		}

  		if ( chainable ) {
  			return elems;
  		}

  		// Gets
  		if ( bulk ) {
  			return fn.call( elems );
  		}

  		return len ? fn( elems[ 0 ], key ) : emptyGet;
  	};


  	// Matches dashed string for camelizing
  	var rmsPrefix = /^-ms-/,
  		rdashAlpha = /-([a-z])/g;

  	// Used by camelCase as callback to replace()
  	function fcamelCase( _all, letter ) {
  		return letter.toUpperCase();
  	}

  	// Convert dashed to camelCase; used by the css and data modules
  	// Support: IE <=9 - 11, Edge 12 - 15
  	// Microsoft forgot to hump their vendor prefix (trac-9572)
  	function camelCase( string ) {
  		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  	}
  	var acceptData = function( owner ) {

  		// Accepts only:
  		//  - Node
  		//    - Node.ELEMENT_NODE
  		//    - Node.DOCUMENT_NODE
  		//  - Object
  		//    - Any
  		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  	};




  	function Data() {
  		this.expando = jQuery.expando + Data.uid++;
  	}

  	Data.uid = 1;

  	Data.prototype = {

  		cache: function( owner ) {

  			// Check if the owner object already has a cache
  			var value = owner[ this.expando ];

  			// If not, create one
  			if ( !value ) {
  				value = {};

  				// We can accept data for non-element nodes in modern browsers,
  				// but we should not, see trac-8335.
  				// Always return an empty object.
  				if ( acceptData( owner ) ) {

  					// If it is a node unlikely to be stringify-ed or looped over
  					// use plain assignment
  					if ( owner.nodeType ) {
  						owner[ this.expando ] = value;

  					// Otherwise secure it in a non-enumerable property
  					// configurable must be true to allow the property to be
  					// deleted when data is removed
  					} else {
  						Object.defineProperty( owner, this.expando, {
  							value: value,
  							configurable: true
  						} );
  					}
  				}
  			}

  			return value;
  		},
  		set: function( owner, data, value ) {
  			var prop,
  				cache = this.cache( owner );

  			// Handle: [ owner, key, value ] args
  			// Always use camelCase key (gh-2257)
  			if ( typeof data === "string" ) {
  				cache[ camelCase( data ) ] = value;

  			// Handle: [ owner, { properties } ] args
  			} else {

  				// Copy the properties one-by-one to the cache object
  				for ( prop in data ) {
  					cache[ camelCase( prop ) ] = data[ prop ];
  				}
  			}
  			return cache;
  		},
  		get: function( owner, key ) {
  			return key === undefined ?
  				this.cache( owner ) :

  				// Always use camelCase key (gh-2257)
  				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  		},
  		access: function( owner, key, value ) {

  			// In cases where either:
  			//
  			//   1. No key was specified
  			//   2. A string key was specified, but no value provided
  			//
  			// Take the "read" path and allow the get method to determine
  			// which value to return, respectively either:
  			//
  			//   1. The entire cache object
  			//   2. The data stored at the key
  			//
  			if ( key === undefined ||
  					( ( key && typeof key === "string" ) && value === undefined ) ) {

  				return this.get( owner, key );
  			}

  			// When the key is not a string, or both a key and value
  			// are specified, set or extend (existing objects) with either:
  			//
  			//   1. An object of properties
  			//   2. A key and value
  			//
  			this.set( owner, key, value );

  			// Since the "set" path can have two possible entry points
  			// return the expected data based on which path was taken[*]
  			return value !== undefined ? value : key;
  		},
  		remove: function( owner, key ) {
  			var i,
  				cache = owner[ this.expando ];

  			if ( cache === undefined ) {
  				return;
  			}

  			if ( key !== undefined ) {

  				// Support array or space separated string of keys
  				if ( Array.isArray( key ) ) {

  					// If key is an array of keys...
  					// We always set camelCase keys, so remove that.
  					key = key.map( camelCase );
  				} else {
  					key = camelCase( key );

  					// If a key with the spaces exists, use it.
  					// Otherwise, create an array by matching non-whitespace
  					key = key in cache ?
  						[ key ] :
  						( key.match( rnothtmlwhite ) || [] );
  				}

  				i = key.length;

  				while ( i-- ) {
  					delete cache[ key[ i ] ];
  				}
  			}

  			// Remove the expando if there's no more data
  			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  				// Support: Chrome <=35 - 45
  				// Webkit & Blink performance suffers when deleting properties
  				// from DOM nodes, so set to undefined instead
  				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = undefined;
  				} else {
  					delete owner[ this.expando ];
  				}
  			}
  		},
  		hasData: function( owner ) {
  			var cache = owner[ this.expando ];
  			return cache !== undefined && !jQuery.isEmptyObject( cache );
  		}
  	};
  	var dataPriv = new Data();

  	var dataUser = new Data();



  	//	Implementation Summary
  	//
  	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
  	//	2. Improve the module's maintainability by reducing the storage
  	//		paths to a single mechanism.
  	//	3. Use the same single mechanism to support "private" and "user" data.
  	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
  	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  		rmultiDash = /[A-Z]/g;

  	function getData( data ) {
  		if ( data === "true" ) {
  			return true;
  		}

  		if ( data === "false" ) {
  			return false;
  		}

  		if ( data === "null" ) {
  			return null;
  		}

  		// Only convert to a number if it doesn't change the string
  		if ( data === +data + "" ) {
  			return +data;
  		}

  		if ( rbrace.test( data ) ) {
  			return JSON.parse( data );
  		}

  		return data;
  	}

  	function dataAttr( elem, key, data ) {
  		var name;

  		// If nothing was found internally, try to fetch any
  		// data from the HTML5 data-* attribute
  		if ( data === undefined && elem.nodeType === 1 ) {
  			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  			data = elem.getAttribute( name );

  			if ( typeof data === "string" ) {
  				try {
  					data = getData( data );
  				} catch ( e ) {}

  				// Make sure we set the data so it isn't changed later
  				dataUser.set( elem, key, data );
  			} else {
  				data = undefined;
  			}
  		}
  		return data;
  	}

  	jQuery.extend( {
  		hasData: function( elem ) {
  			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  		},

  		data: function( elem, name, data ) {
  			return dataUser.access( elem, name, data );
  		},

  		removeData: function( elem, name ) {
  			dataUser.remove( elem, name );
  		},

  		// TODO: Now that all calls to _data and _removeData have been replaced
  		// with direct calls to dataPriv methods, these can be deprecated.
  		_data: function( elem, name, data ) {
  			return dataPriv.access( elem, name, data );
  		},

  		_removeData: function( elem, name ) {
  			dataPriv.remove( elem, name );
  		}
  	} );

  	jQuery.fn.extend( {
  		data: function( key, value ) {
  			var i, name, data,
  				elem = this[ 0 ],
  				attrs = elem && elem.attributes;

  			// Gets all values
  			if ( key === undefined ) {
  				if ( this.length ) {
  					data = dataUser.get( elem );

  					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  						i = attrs.length;
  						while ( i-- ) {

  							// Support: IE 11 only
  							// The attrs elements can be null (trac-14894)
  							if ( attrs[ i ] ) {
  								name = attrs[ i ].name;
  								if ( name.indexOf( "data-" ) === 0 ) {
  									name = camelCase( name.slice( 5 ) );
  									dataAttr( elem, name, data[ name ] );
  								}
  							}
  						}
  						dataPriv.set( elem, "hasDataAttrs", true );
  					}
  				}

  				return data;
  			}

  			// Sets multiple values
  			if ( typeof key === "object" ) {
  				return this.each( function() {
  					dataUser.set( this, key );
  				} );
  			}

  			return access( this, function( value ) {
  				var data;

  				// The calling jQuery object (element matches) is not empty
  				// (and therefore has an element appears at this[ 0 ]) and the
  				// `value` parameter was not undefined. An empty jQuery object
  				// will result in `undefined` for elem = this[ 0 ] which will
  				// throw an exception if an attempt to read a data cache is made.
  				if ( elem && value === undefined ) {

  					// Attempt to get data from the cache
  					// The key will always be camelCased in Data
  					data = dataUser.get( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// Attempt to "discover" the data in
  					// HTML5 custom data-* attrs
  					data = dataAttr( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// We tried really hard, but the data doesn't exist.
  					return;
  				}

  				// Set the data...
  				this.each( function() {

  					// We always store the camelCased key
  					dataUser.set( this, key, value );
  				} );
  			}, null, value, arguments.length > 1, null, true );
  		},

  		removeData: function( key ) {
  			return this.each( function() {
  				dataUser.remove( this, key );
  			} );
  		}
  	} );


  	jQuery.extend( {
  		queue: function( elem, type, data ) {
  			var queue;

  			if ( elem ) {
  				type = ( type || "fx" ) + "queue";
  				queue = dataPriv.get( elem, type );

  				// Speed up dequeue by getting out quickly if this is just a lookup
  				if ( data ) {
  					if ( !queue || Array.isArray( data ) ) {
  						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  					} else {
  						queue.push( data );
  					}
  				}
  				return queue || [];
  			}
  		},

  		dequeue: function( elem, type ) {
  			type = type || "fx";

  			var queue = jQuery.queue( elem, type ),
  				startLength = queue.length,
  				fn = queue.shift(),
  				hooks = jQuery._queueHooks( elem, type ),
  				next = function() {
  					jQuery.dequeue( elem, type );
  				};

  			// If the fx queue is dequeued, always remove the progress sentinel
  			if ( fn === "inprogress" ) {
  				fn = queue.shift();
  				startLength--;
  			}

  			if ( fn ) {

  				// Add a progress sentinel to prevent the fx queue from being
  				// automatically dequeued
  				if ( type === "fx" ) {
  					queue.unshift( "inprogress" );
  				}

  				// Clear up the last queue stop function
  				delete hooks.stop;
  				fn.call( elem, next, hooks );
  			}

  			if ( !startLength && hooks ) {
  				hooks.empty.fire();
  			}
  		},

  		// Not public - generate a queueHooks object, or return the current one
  		_queueHooks: function( elem, type ) {
  			var key = type + "queueHooks";
  			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  				empty: jQuery.Callbacks( "once memory" ).add( function() {
  					dataPriv.remove( elem, [ type + "queue", key ] );
  				} )
  			} );
  		}
  	} );

  	jQuery.fn.extend( {
  		queue: function( type, data ) {
  			var setter = 2;

  			if ( typeof type !== "string" ) {
  				data = type;
  				type = "fx";
  				setter--;
  			}

  			if ( arguments.length < setter ) {
  				return jQuery.queue( this[ 0 ], type );
  			}

  			return data === undefined ?
  				this :
  				this.each( function() {
  					var queue = jQuery.queue( this, type, data );

  					// Ensure a hooks for this queue
  					jQuery._queueHooks( this, type );

  					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  						jQuery.dequeue( this, type );
  					}
  				} );
  		},
  		dequeue: function( type ) {
  			return this.each( function() {
  				jQuery.dequeue( this, type );
  			} );
  		},
  		clearQueue: function( type ) {
  			return this.queue( type || "fx", [] );
  		},

  		// Get a promise resolved when queues of a certain type
  		// are emptied (fx is the type by default)
  		promise: function( type, obj ) {
  			var tmp,
  				count = 1,
  				defer = jQuery.Deferred(),
  				elements = this,
  				i = this.length,
  				resolve = function() {
  					if ( !( --count ) ) {
  						defer.resolveWith( elements, [ elements ] );
  					}
  				};

  			if ( typeof type !== "string" ) {
  				obj = type;
  				type = undefined;
  			}
  			type = type || "fx";

  			while ( i-- ) {
  				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  				if ( tmp && tmp.empty ) {
  					count++;
  					tmp.empty.add( resolve );
  				}
  			}
  			resolve();
  			return defer.promise( obj );
  		}
  	} );
  	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  	var documentElement = document.documentElement;



  		var isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem );
  			},
  			composed = { composed: true };

  		// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  		// Check attachment across shadow DOM boundaries when possible (gh-3504)
  		// Support: iOS 10.0-10.2 only
  		// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  		// leading to errors. We need to check for `getRootNode`.
  		if ( documentElement.getRootNode ) {
  			isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem ) ||
  					elem.getRootNode( composed ) === elem.ownerDocument;
  			};
  		}
  	var isHiddenWithinTree = function( elem, el ) {

  			// isHiddenWithinTree might be called from jQuery#filter function;
  			// in that case, element will be second argument
  			elem = el || elem;

  			// Inline style trumps all
  			return elem.style.display === "none" ||
  				elem.style.display === "" &&

  				// Otherwise, check computed style
  				// Support: Firefox <=43 - 45
  				// Disconnected elements can have computed display: none, so first confirm that elem is
  				// in the document.
  				isAttached( elem ) &&

  				jQuery.css( elem, "display" ) === "none";
  		};



  	function adjustCSS( elem, prop, valueParts, tween ) {
  		var adjusted, scale,
  			maxIterations = 20,
  			currentValue = tween ?
  				function() {
  					return tween.cur();
  				} :
  				function() {
  					return jQuery.css( elem, prop, "" );
  				},
  			initial = currentValue(),
  			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  			// Starting value computation is required for potential unit mismatches
  			initialInUnit = elem.nodeType &&
  				( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  				rcssNum.exec( jQuery.css( elem, prop ) );

  		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  			// Support: Firefox <=54
  			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  			initial = initial / 2;

  			// Trust units reported by jQuery.css
  			unit = unit || initialInUnit[ 3 ];

  			// Iteratively approximate from a nonzero starting point
  			initialInUnit = +initial || 1;

  			while ( maxIterations-- ) {

  				// Evaluate and update our best guess (doubling guesses that zero out).
  				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  				jQuery.style( elem, prop, initialInUnit + unit );
  				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  					maxIterations = 0;
  				}
  				initialInUnit = initialInUnit / scale;

  			}

  			initialInUnit = initialInUnit * 2;
  			jQuery.style( elem, prop, initialInUnit + unit );

  			// Make sure we update the tween properties later on
  			valueParts = valueParts || [];
  		}

  		if ( valueParts ) {
  			initialInUnit = +initialInUnit || +initial || 0;

  			// Apply relative offset (+=/-=) if specified
  			adjusted = valueParts[ 1 ] ?
  				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  				+valueParts[ 2 ];
  			if ( tween ) {
  				tween.unit = unit;
  				tween.start = initialInUnit;
  				tween.end = adjusted;
  			}
  		}
  		return adjusted;
  	}


  	var defaultDisplayMap = {};

  	function getDefaultDisplay( elem ) {
  		var temp,
  			doc = elem.ownerDocument,
  			nodeName = elem.nodeName,
  			display = defaultDisplayMap[ nodeName ];

  		if ( display ) {
  			return display;
  		}

  		temp = doc.body.appendChild( doc.createElement( nodeName ) );
  		display = jQuery.css( temp, "display" );

  		temp.parentNode.removeChild( temp );

  		if ( display === "none" ) {
  			display = "block";
  		}
  		defaultDisplayMap[ nodeName ] = display;

  		return display;
  	}

  	function showHide( elements, show ) {
  		var display, elem,
  			values = [],
  			index = 0,
  			length = elements.length;

  		// Determine new display value for elements that need to change
  		for ( ; index < length; index++ ) {
  			elem = elements[ index ];
  			if ( !elem.style ) {
  				continue;
  			}

  			display = elem.style.display;
  			if ( show ) {

  				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  				// check is required in this first loop unless we have a nonempty display value (either
  				// inline or about-to-be-restored)
  				if ( display === "none" ) {
  					values[ index ] = dataPriv.get( elem, "display" ) || null;
  					if ( !values[ index ] ) {
  						elem.style.display = "";
  					}
  				}
  				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  					values[ index ] = getDefaultDisplay( elem );
  				}
  			} else {
  				if ( display !== "none" ) {
  					values[ index ] = "none";

  					// Remember what we're overwriting
  					dataPriv.set( elem, "display", display );
  				}
  			}
  		}

  		// Set the display of the elements in a second loop to avoid constant reflow
  		for ( index = 0; index < length; index++ ) {
  			if ( values[ index ] != null ) {
  				elements[ index ].style.display = values[ index ];
  			}
  		}

  		return elements;
  	}

  	jQuery.fn.extend( {
  		show: function() {
  			return showHide( this, true );
  		},
  		hide: function() {
  			return showHide( this );
  		},
  		toggle: function( state ) {
  			if ( typeof state === "boolean" ) {
  				return state ? this.show() : this.hide();
  			}

  			return this.each( function() {
  				if ( isHiddenWithinTree( this ) ) {
  					jQuery( this ).show();
  				} else {
  					jQuery( this ).hide();
  				}
  			} );
  		}
  	} );
  	var rcheckableType = ( /^(?:checkbox|radio)$/i );

  	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  	( function() {
  		var fragment = document.createDocumentFragment(),
  			div = fragment.appendChild( document.createElement( "div" ) ),
  			input = document.createElement( "input" );

  		// Support: Android 4.0 - 4.3 only
  		// Check state lost if the name is set (trac-11217)
  		// Support: Windows Web Apps (WWA)
  		// `name` and `type` must use .setAttribute for WWA (trac-14901)
  		input.setAttribute( "type", "radio" );
  		input.setAttribute( "checked", "checked" );
  		input.setAttribute( "name", "t" );

  		div.appendChild( input );

  		// Support: Android <=4.1 only
  		// Older WebKit doesn't clone checked state correctly in fragments
  		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  		// Support: IE <=11 only
  		// Make sure textarea (and checkbox) defaultValue is properly cloned
  		div.innerHTML = "<textarea>x</textarea>";
  		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  		// Support: IE <=9 only
  		// IE <=9 replaces <option> tags with their contents when inserted outside of
  		// the select element.
  		div.innerHTML = "<option></option>";
  		support.option = !!div.lastChild;
  	} )();


  	// We have to close these tags to support XHTML (trac-13200)
  	var wrapMap = {

  		// XHTML parsers do not magically insert elements in the
  		// same way that tag soup parsers do. So we cannot shorten
  		// this by omitting <tbody> or other required elements.
  		thead: [ 1, "<table>", "</table>" ],
  		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  		_default: [ 0, "", "" ]
  	};

  	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  	wrapMap.th = wrapMap.td;

  	// Support: IE <=9 only
  	if ( !support.option ) {
  		wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  	}


  	function getAll( context, tag ) {

  		// Support: IE <=9 - 11 only
  		// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
  		var ret;

  		if ( typeof context.getElementsByTagName !== "undefined" ) {
  			ret = context.getElementsByTagName( tag || "*" );

  		} else if ( typeof context.querySelectorAll !== "undefined" ) {
  			ret = context.querySelectorAll( tag || "*" );

  		} else {
  			ret = [];
  		}

  		if ( tag === undefined || tag && nodeName( context, tag ) ) {
  			return jQuery.merge( [ context ], ret );
  		}

  		return ret;
  	}


  	// Mark scripts as having already been evaluated
  	function setGlobalEval( elems, refElements ) {
  		var i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			dataPriv.set(
  				elems[ i ],
  				"globalEval",
  				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  			);
  		}
  	}


  	var rhtml = /<|&#?\w+;/;

  	function buildFragment( elems, context, scripts, selection, ignored ) {
  		var elem, tmp, tag, wrap, attached, j,
  			fragment = context.createDocumentFragment(),
  			nodes = [],
  			i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			elem = elems[ i ];

  			if ( elem || elem === 0 ) {

  				// Add nodes directly
  				if ( toType( elem ) === "object" ) {

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  				// Convert non-html into a text node
  				} else if ( !rhtml.test( elem ) ) {
  					nodes.push( context.createTextNode( elem ) );

  				// Convert html into DOM nodes
  				} else {
  					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  					// Deserialize a standard representation
  					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  					wrap = wrapMap[ tag ] || wrapMap._default;
  					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  					// Descend through wrappers to the right content
  					j = wrap[ 0 ];
  					while ( j-- ) {
  						tmp = tmp.lastChild;
  					}

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, tmp.childNodes );

  					// Remember the top-level container
  					tmp = fragment.firstChild;

  					// Ensure the created nodes are orphaned (trac-12392)
  					tmp.textContent = "";
  				}
  			}
  		}

  		// Remove wrapper from fragment
  		fragment.textContent = "";

  		i = 0;
  		while ( ( elem = nodes[ i++ ] ) ) {

  			// Skip elements already in the context collection (trac-4087)
  			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  				if ( ignored ) {
  					ignored.push( elem );
  				}
  				continue;
  			}

  			attached = isAttached( elem );

  			// Append to fragment
  			tmp = getAll( fragment.appendChild( elem ), "script" );

  			// Preserve script evaluation history
  			if ( attached ) {
  				setGlobalEval( tmp );
  			}

  			// Capture executables
  			if ( scripts ) {
  				j = 0;
  				while ( ( elem = tmp[ j++ ] ) ) {
  					if ( rscriptType.test( elem.type || "" ) ) {
  						scripts.push( elem );
  					}
  				}
  			}
  		}

  		return fragment;
  	}


  	var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  	function returnTrue() {
  		return true;
  	}

  	function returnFalse() {
  		return false;
  	}

  	function on( elem, types, selector, data, fn, one ) {
  		var origFn, type;

  		// Types can be a map of types/handlers
  		if ( typeof types === "object" ) {

  			// ( types-Object, selector, data )
  			if ( typeof selector !== "string" ) {

  				// ( types-Object, data )
  				data = data || selector;
  				selector = undefined;
  			}
  			for ( type in types ) {
  				on( elem, type, selector, data, types[ type ], one );
  			}
  			return elem;
  		}

  		if ( data == null && fn == null ) {

  			// ( types, fn )
  			fn = selector;
  			data = selector = undefined;
  		} else if ( fn == null ) {
  			if ( typeof selector === "string" ) {

  				// ( types, selector, fn )
  				fn = data;
  				data = undefined;
  			} else {

  				// ( types, data, fn )
  				fn = data;
  				data = selector;
  				selector = undefined;
  			}
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		} else if ( !fn ) {
  			return elem;
  		}

  		if ( one === 1 ) {
  			origFn = fn;
  			fn = function( event ) {

  				// Can use an empty set, since event contains the info
  				jQuery().off( event );
  				return origFn.apply( this, arguments );
  			};

  			// Use same guid so caller can remove using origFn
  			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  		}
  		return elem.each( function() {
  			jQuery.event.add( this, types, fn, data, selector );
  		} );
  	}

  	/*
  	 * Helper functions for managing events -- not part of the public interface.
  	 * Props to Dean Edwards' addEvent library for many of the ideas.
  	 */
  	jQuery.event = {

  		global: {},

  		add: function( elem, types, handler, data, selector ) {

  			var handleObjIn, eventHandle, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.get( elem );

  			// Only attach events to objects that accept data
  			if ( !acceptData( elem ) ) {
  				return;
  			}

  			// Caller can pass in an object of custom data in lieu of the handler
  			if ( handler.handler ) {
  				handleObjIn = handler;
  				handler = handleObjIn.handler;
  				selector = handleObjIn.selector;
  			}

  			// Ensure that invalid selectors throw exceptions at attach time
  			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  			if ( selector ) {
  				jQuery.find.matchesSelector( documentElement, selector );
  			}

  			// Make sure that the handler has a unique ID, used to find/remove it later
  			if ( !handler.guid ) {
  				handler.guid = jQuery.guid++;
  			}

  			// Init the element's event structure and main handler, if this is the first
  			if ( !( events = elemData.events ) ) {
  				events = elemData.events = Object.create( null );
  			}
  			if ( !( eventHandle = elemData.handle ) ) {
  				eventHandle = elemData.handle = function( e ) {

  					// Discard the second event of a jQuery.event.trigger() and
  					// when an event is called after a page has unloaded
  					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  				};
  			}

  			// Handle multiple events separated by a space
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// There *must* be a type, no attaching namespace-only handlers
  				if ( !type ) {
  					continue;
  				}

  				// If event changes its type, use the special event handlers for the changed type
  				special = jQuery.event.special[ type ] || {};

  				// If selector defined, determine special event api type, otherwise given type
  				type = ( selector ? special.delegateType : special.bindType ) || type;

  				// Update special based on newly reset type
  				special = jQuery.event.special[ type ] || {};

  				// handleObj is passed to all event handlers
  				handleObj = jQuery.extend( {
  					type: type,
  					origType: origType,
  					data: data,
  					handler: handler,
  					guid: handler.guid,
  					selector: selector,
  					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  					namespace: namespaces.join( "." )
  				}, handleObjIn );

  				// Init the event handler queue if we're the first
  				if ( !( handlers = events[ type ] ) ) {
  					handlers = events[ type ] = [];
  					handlers.delegateCount = 0;

  					// Only use addEventListener if the special events handler returns false
  					if ( !special.setup ||
  						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  						if ( elem.addEventListener ) {
  							elem.addEventListener( type, eventHandle );
  						}
  					}
  				}

  				if ( special.add ) {
  					special.add.call( elem, handleObj );

  					if ( !handleObj.handler.guid ) {
  						handleObj.handler.guid = handler.guid;
  					}
  				}

  				// Add to the element's handler list, delegates in front
  				if ( selector ) {
  					handlers.splice( handlers.delegateCount++, 0, handleObj );
  				} else {
  					handlers.push( handleObj );
  				}

  				// Keep track of which events have ever been used, for event optimization
  				jQuery.event.global[ type ] = true;
  			}

  		},

  		// Detach an event or set of events from an element
  		remove: function( elem, types, handler, selector, mappedTypes ) {

  			var j, origCount, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  			if ( !elemData || !( events = elemData.events ) ) {
  				return;
  			}

  			// Once for each type.namespace in types; type may be omitted
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// Unbind all events (on this namespace, if provided) for the element
  				if ( !type ) {
  					for ( type in events ) {
  						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  					}
  					continue;
  				}

  				special = jQuery.event.special[ type ] || {};
  				type = ( selector ? special.delegateType : special.bindType ) || type;
  				handlers = events[ type ] || [];
  				tmp = tmp[ 2 ] &&
  					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  				// Remove matching events
  				origCount = j = handlers.length;
  				while ( j-- ) {
  					handleObj = handlers[ j ];

  					if ( ( mappedTypes || origType === handleObj.origType ) &&
  						( !handler || handler.guid === handleObj.guid ) &&
  						( !tmp || tmp.test( handleObj.namespace ) ) &&
  						( !selector || selector === handleObj.selector ||
  							selector === "**" && handleObj.selector ) ) {
  						handlers.splice( j, 1 );

  						if ( handleObj.selector ) {
  							handlers.delegateCount--;
  						}
  						if ( special.remove ) {
  							special.remove.call( elem, handleObj );
  						}
  					}
  				}

  				// Remove generic event handler if we removed something and no more handlers exist
  				// (avoids potential for endless recursion during removal of special event handlers)
  				if ( origCount && !handlers.length ) {
  					if ( !special.teardown ||
  						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  						jQuery.removeEvent( elem, type, elemData.handle );
  					}

  					delete events[ type ];
  				}
  			}

  			// Remove data and the expando if it's no longer used
  			if ( jQuery.isEmptyObject( events ) ) {
  				dataPriv.remove( elem, "handle events" );
  			}
  		},

  		dispatch: function( nativeEvent ) {

  			var i, j, ret, matched, handleObj, handlerQueue,
  				args = new Array( arguments.length ),

  				// Make a writable jQuery.Event from the native event object
  				event = jQuery.event.fix( nativeEvent ),

  				handlers = (
  					dataPriv.get( this, "events" ) || Object.create( null )
  				)[ event.type ] || [],
  				special = jQuery.event.special[ event.type ] || {};

  			// Use the fix-ed jQuery.Event rather than the (read-only) native event
  			args[ 0 ] = event;

  			for ( i = 1; i < arguments.length; i++ ) {
  				args[ i ] = arguments[ i ];
  			}

  			event.delegateTarget = this;

  			// Call the preDispatch hook for the mapped type, and let it bail if desired
  			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  				return;
  			}

  			// Determine handlers
  			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  			// Run delegates first; they may want to stop propagation beneath us
  			i = 0;
  			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  				event.currentTarget = matched.elem;

  				j = 0;
  				while ( ( handleObj = matched.handlers[ j++ ] ) &&
  					!event.isImmediatePropagationStopped() ) {

  					// If the event is namespaced, then each handler is only invoked if it is
  					// specially universal or its namespaces are a superset of the event's.
  					if ( !event.rnamespace || handleObj.namespace === false ||
  						event.rnamespace.test( handleObj.namespace ) ) {

  						event.handleObj = handleObj;
  						event.data = handleObj.data;

  						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  							handleObj.handler ).apply( matched.elem, args );

  						if ( ret !== undefined ) {
  							if ( ( event.result = ret ) === false ) {
  								event.preventDefault();
  								event.stopPropagation();
  							}
  						}
  					}
  				}
  			}

  			// Call the postDispatch hook for the mapped type
  			if ( special.postDispatch ) {
  				special.postDispatch.call( this, event );
  			}

  			return event.result;
  		},

  		handlers: function( event, handlers ) {
  			var i, handleObj, sel, matchedHandlers, matchedSelectors,
  				handlerQueue = [],
  				delegateCount = handlers.delegateCount,
  				cur = event.target;

  			// Find delegate handlers
  			if ( delegateCount &&

  				// Support: IE <=9
  				// Black-hole SVG <use> instance trees (trac-13180)
  				cur.nodeType &&

  				// Support: Firefox <=42
  				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  				// Support: IE 11 only
  				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  				!( event.type === "click" && event.button >= 1 ) ) {

  				for ( ; cur !== this; cur = cur.parentNode || this ) {

  					// Don't check non-elements (trac-13208)
  					// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
  					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  						matchedHandlers = [];
  						matchedSelectors = {};
  						for ( i = 0; i < delegateCount; i++ ) {
  							handleObj = handlers[ i ];

  							// Don't conflict with Object.prototype properties (trac-13203)
  							sel = handleObj.selector + " ";

  							if ( matchedSelectors[ sel ] === undefined ) {
  								matchedSelectors[ sel ] = handleObj.needsContext ?
  									jQuery( sel, this ).index( cur ) > -1 :
  									jQuery.find( sel, this, null, [ cur ] ).length;
  							}
  							if ( matchedSelectors[ sel ] ) {
  								matchedHandlers.push( handleObj );
  							}
  						}
  						if ( matchedHandlers.length ) {
  							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  						}
  					}
  				}
  			}

  			// Add the remaining (directly-bound) handlers
  			cur = this;
  			if ( delegateCount < handlers.length ) {
  				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  			}

  			return handlerQueue;
  		},

  		addProp: function( name, hook ) {
  			Object.defineProperty( jQuery.Event.prototype, name, {
  				enumerable: true,
  				configurable: true,

  				get: isFunction( hook ) ?
  					function() {
  						if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  						}
  					} :
  					function() {
  						if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  						}
  					},

  				set: function( value ) {
  					Object.defineProperty( this, name, {
  						enumerable: true,
  						configurable: true,
  						writable: true,
  						value: value
  					} );
  				}
  			} );
  		},

  		fix: function( originalEvent ) {
  			return originalEvent[ jQuery.expando ] ?
  				originalEvent :
  				new jQuery.Event( originalEvent );
  		},

  		special: {
  			load: {

  				// Prevent triggered image.load events from bubbling to window.load
  				noBubble: true
  			},
  			click: {

  				// Utilize native event to ensure correct state for checkable inputs
  				setup: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Claim the first handler
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						// dataPriv.set( el, "click", ... )
  						leverageNative( el, "click", true );
  					}

  					// Return false to allow normal processing in the caller
  					return false;
  				},
  				trigger: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Force setup before triggering a click
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						leverageNative( el, "click" );
  					}

  					// Return non-false to allow normal event-path propagation
  					return true;
  				},

  				// For cross-browser consistency, suppress native .click() on links
  				// Also prevent it if we're currently inside a leveraged native-event stack
  				_default: function( event ) {
  					var target = event.target;
  					return rcheckableType.test( target.type ) &&
  						target.click && nodeName( target, "input" ) &&
  						dataPriv.get( target, "click" ) ||
  						nodeName( target, "a" );
  				}
  			},

  			beforeunload: {
  				postDispatch: function( event ) {

  					// Support: Firefox 20+
  					// Firefox doesn't alert if the returnValue field is not set.
  					if ( event.result !== undefined && event.originalEvent ) {
  						event.originalEvent.returnValue = event.result;
  					}
  				}
  			}
  		}
  	};

  	// Ensure the presence of an event listener that handles manually-triggered
  	// synthetic events by interrupting progress until reinvoked in response to
  	// *native* events that it fires directly, ensuring that state changes have
  	// already occurred before other listeners are invoked.
  	function leverageNative( el, type, isSetup ) {

  		// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
  		if ( !isSetup ) {
  			if ( dataPriv.get( el, type ) === undefined ) {
  				jQuery.event.add( el, type, returnTrue );
  			}
  			return;
  		}

  		// Register the controller as a special universal handler for all event namespaces
  		dataPriv.set( el, type, false );
  		jQuery.event.add( el, type, {
  			namespace: false,
  			handler: function( event ) {
  				var result,
  					saved = dataPriv.get( this, type );

  				if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  					// Interrupt processing of the outer synthetic .trigger()ed event
  					if ( !saved ) {

  						// Store arguments for use when handling the inner native event
  						// There will always be at least one argument (an event object), so this array
  						// will not be confused with a leftover capture object.
  						saved = slice.call( arguments );
  						dataPriv.set( this, type, saved );

  						// Trigger the native event and capture its result
  						this[ type ]();
  						result = dataPriv.get( this, type );
  						dataPriv.set( this, type, false );

  						if ( saved !== result ) {

  							// Cancel the outer synthetic event
  							event.stopImmediatePropagation();
  							event.preventDefault();

  							return result;
  						}

  					// If this is an inner synthetic event for an event with a bubbling surrogate
  					// (focus or blur), assume that the surrogate already propagated from triggering
  					// the native event and prevent that from happening again here.
  					// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  					// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  					// less bad than duplication.
  					} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  						event.stopPropagation();
  					}

  				// If this is a native event triggered above, everything is now in order
  				// Fire an inner synthetic event with the original arguments
  				} else if ( saved ) {

  					// ...and capture the result
  					dataPriv.set( this, type, jQuery.event.trigger(
  						saved[ 0 ],
  						saved.slice( 1 ),
  						this
  					) );

  					// Abort handling of the native event by all jQuery handlers while allowing
  					// native handlers on the same element to run. On target, this is achieved
  					// by stopping immediate propagation just on the jQuery event. However,
  					// the native event is re-wrapped by a jQuery one on each level of the
  					// propagation so the only way to stop it for jQuery is to stop it for
  					// everyone via native `stopPropagation()`. This is not a problem for
  					// focus/blur which don't bubble, but it does also stop click on checkboxes
  					// and radios. We accept this limitation.
  					event.stopPropagation();
  					event.isImmediatePropagationStopped = returnTrue;
  				}
  			}
  		} );
  	}

  	jQuery.removeEvent = function( elem, type, handle ) {

  		// This "if" is needed for plain objects
  		if ( elem.removeEventListener ) {
  			elem.removeEventListener( type, handle );
  		}
  	};

  	jQuery.Event = function( src, props ) {

  		// Allow instantiation without the 'new' keyword
  		if ( !( this instanceof jQuery.Event ) ) {
  			return new jQuery.Event( src, props );
  		}

  		// Event object
  		if ( src && src.type ) {
  			this.originalEvent = src;
  			this.type = src.type;

  			// Events bubbling up the document may have been marked as prevented
  			// by a handler lower down the tree; reflect the correct value.
  			this.isDefaultPrevented = src.defaultPrevented ||
  					src.defaultPrevented === undefined &&

  					// Support: Android <=2.3 only
  					src.returnValue === false ?
  				returnTrue :
  				returnFalse;

  			// Create target properties
  			// Support: Safari <=6 - 7 only
  			// Target should not be a text node (trac-504, trac-13143)
  			this.target = ( src.target && src.target.nodeType === 3 ) ?
  				src.target.parentNode :
  				src.target;

  			this.currentTarget = src.currentTarget;
  			this.relatedTarget = src.relatedTarget;

  		// Event type
  		} else {
  			this.type = src;
  		}

  		// Put explicitly provided properties onto the event object
  		if ( props ) {
  			jQuery.extend( this, props );
  		}

  		// Create a timestamp if incoming event doesn't have one
  		this.timeStamp = src && src.timeStamp || Date.now();

  		// Mark it as fixed
  		this[ jQuery.expando ] = true;
  	};

  	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  	jQuery.Event.prototype = {
  		constructor: jQuery.Event,
  		isDefaultPrevented: returnFalse,
  		isPropagationStopped: returnFalse,
  		isImmediatePropagationStopped: returnFalse,
  		isSimulated: false,

  		preventDefault: function() {
  			var e = this.originalEvent;

  			this.isDefaultPrevented = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.preventDefault();
  			}
  		},
  		stopPropagation: function() {
  			var e = this.originalEvent;

  			this.isPropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopPropagation();
  			}
  		},
  		stopImmediatePropagation: function() {
  			var e = this.originalEvent;

  			this.isImmediatePropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopImmediatePropagation();
  			}

  			this.stopPropagation();
  		}
  	};

  	// Includes all common event props including KeyEvent and MouseEvent specific props
  	jQuery.each( {
  		altKey: true,
  		bubbles: true,
  		cancelable: true,
  		changedTouches: true,
  		ctrlKey: true,
  		detail: true,
  		eventPhase: true,
  		metaKey: true,
  		pageX: true,
  		pageY: true,
  		shiftKey: true,
  		view: true,
  		"char": true,
  		code: true,
  		charCode: true,
  		key: true,
  		keyCode: true,
  		button: true,
  		buttons: true,
  		clientX: true,
  		clientY: true,
  		offsetX: true,
  		offsetY: true,
  		pointerId: true,
  		pointerType: true,
  		screenX: true,
  		screenY: true,
  		targetTouches: true,
  		toElement: true,
  		touches: true,
  		which: true
  	}, jQuery.event.addProp );

  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

  		function focusMappedHandler( nativeEvent ) {
  			if ( document.documentMode ) {

  				// Support: IE 11+
  				// Attach a single focusin/focusout handler on the document while someone wants
  				// focus/blur. This is because the former are synchronous in IE while the latter
  				// are async. In other browsers, all those handlers are invoked synchronously.

  				// `handle` from private data would already wrap the event, but we need
  				// to change the `type` here.
  				var handle = dataPriv.get( this, "handle" ),
  					event = jQuery.event.fix( nativeEvent );
  				event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
  				event.isSimulated = true;

  				// First, handle focusin/focusout
  				handle( nativeEvent );

  				// ...then, handle focus/blur
  				//
  				// focus/blur don't bubble while focusin/focusout do; simulate the former by only
  				// invoking the handler at the lower level.
  				if ( event.target === event.currentTarget ) {

  					// The setup part calls `leverageNative`, which, in turn, calls
  					// `jQuery.event.add`, so event handle will already have been set
  					// by this point.
  					handle( event );
  				}
  			} else {

  				// For non-IE browsers, attach a single capturing handler on the document
  				// while someone wants focusin/focusout.
  				jQuery.event.simulate( delegateType, nativeEvent.target,
  					jQuery.event.fix( nativeEvent ) );
  			}
  		}

  		jQuery.event.special[ type ] = {

  			// Utilize native event if possible so blur/focus sequence is correct
  			setup: function() {

  				var attaches;

  				// Claim the first handler
  				// dataPriv.set( this, "focus", ... )
  				// dataPriv.set( this, "blur", ... )
  				leverageNative( this, type, true );

  				if ( document.documentMode ) {

  					// Support: IE 9 - 11+
  					// We use the same native handler for focusin & focus (and focusout & blur)
  					// so we need to coordinate setup & teardown parts between those events.
  					// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  					attaches = dataPriv.get( this, delegateType );
  					if ( !attaches ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					}
  					dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
  				} else {

  					// Return false to allow normal processing in the caller
  					return false;
  				}
  			},
  			trigger: function() {

  				// Force setup before trigger
  				leverageNative( this, type );

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			teardown: function() {
  				var attaches;

  				if ( document.documentMode ) {
  					attaches = dataPriv.get( this, delegateType ) - 1;
  					if ( !attaches ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  						dataPriv.remove( this, delegateType );
  					} else {
  						dataPriv.set( this, delegateType, attaches );
  					}
  				} else {

  					// Return false to indicate standard teardown should be applied
  					return false;
  				}
  			},

  			// Suppress native focus or blur if we're currently inside
  			// a leveraged native-event stack
  			_default: function( event ) {
  				return dataPriv.get( event.target, type );
  			},

  			delegateType: delegateType
  		};

  		// Support: Firefox <=44
  		// Firefox doesn't have focus(in | out) events
  		// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  		//
  		// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  		// focus(in | out) events fire after focus & blur events,
  		// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  		// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  		//
  		// Support: IE 9 - 11+
  		// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
  		// attach a single handler for both events in IE.
  		jQuery.event.special[ delegateType ] = {
  			setup: function() {

  				// Handle: regular nodes (via `this.ownerDocument`), window
  				// (via `this.document`) & document (via `this`).
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType );

  				// Support: IE 9 - 11+
  				// We use the same native handler for focusin & focus (and focusout & blur)
  				// so we need to coordinate setup & teardown parts between those events.
  				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.addEventListener( type, focusMappedHandler, true );
  					}
  				}
  				dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType ) - 1;

  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.removeEventListener( type, focusMappedHandler, true );
  					}
  					dataPriv.remove( dataHolder, delegateType );
  				} else {
  					dataPriv.set( dataHolder, delegateType, attaches );
  				}
  			}
  		};
  	} );

  	// Create mouseenter/leave events using mouseover/out and event-time checks
  	// so that event delegation works in jQuery.
  	// Do the same for pointerenter/pointerleave and pointerover/pointerout
  	//
  	// Support: Safari 7 only
  	// Safari sends mouseenter too often; see:
  	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  	// for the description of the bug (it existed in older Chrome versions as well).
  	jQuery.each( {
  		mouseenter: "mouseover",
  		mouseleave: "mouseout",
  		pointerenter: "pointerover",
  		pointerleave: "pointerout"
  	}, function( orig, fix ) {
  		jQuery.event.special[ orig ] = {
  			delegateType: fix,
  			bindType: fix,

  			handle: function( event ) {
  				var ret,
  					target = this,
  					related = event.relatedTarget,
  					handleObj = event.handleObj;

  				// For mouseenter/leave call the handler if related is outside the target.
  				// NB: No relatedTarget if the mouse left/entered the browser window
  				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  					event.type = handleObj.origType;
  					ret = handleObj.handler.apply( this, arguments );
  					event.type = fix;
  				}
  				return ret;
  			}
  		};
  	} );

  	jQuery.fn.extend( {

  		on: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn );
  		},
  		one: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn, 1 );
  		},
  		off: function( types, selector, fn ) {
  			var handleObj, type;
  			if ( types && types.preventDefault && types.handleObj ) {

  				// ( event )  dispatched jQuery.Event
  				handleObj = types.handleObj;
  				jQuery( types.delegateTarget ).off(
  					handleObj.namespace ?
  						handleObj.origType + "." + handleObj.namespace :
  						handleObj.origType,
  					handleObj.selector,
  					handleObj.handler
  				);
  				return this;
  			}
  			if ( typeof types === "object" ) {

  				// ( types-object [, selector] )
  				for ( type in types ) {
  					this.off( type, selector, types[ type ] );
  				}
  				return this;
  			}
  			if ( selector === false || typeof selector === "function" ) {

  				// ( types [, fn] )
  				fn = selector;
  				selector = undefined;
  			}
  			if ( fn === false ) {
  				fn = returnFalse;
  			}
  			return this.each( function() {
  				jQuery.event.remove( this, types, fn, selector );
  			} );
  		}
  	} );


  	var

  		// Support: IE <=10 - 11, Edge 12 - 13 only
  		// In IE/Edge using regex groups here causes severe slowdowns.
  		// See https://connect.microsoft.com/IE/feedback/details/1736512/
  		rnoInnerhtml = /<script|<style|<link/i,

  		// checked="checked" or checked
  		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

  		rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

  	// Prefer a tbody over its parent table for containing new rows
  	function manipulationTarget( elem, content ) {
  		if ( nodeName( elem, "table" ) &&
  			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  		}

  		return elem;
  	}

  	// Replace/restore the type attribute of script elements for safe DOM manipulation
  	function disableScript( elem ) {
  		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  		return elem;
  	}
  	function restoreScript( elem ) {
  		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  			elem.type = elem.type.slice( 5 );
  		} else {
  			elem.removeAttribute( "type" );
  		}

  		return elem;
  	}

  	function cloneCopyEvent( src, dest ) {
  		var i, l, type, pdataOld, udataOld, udataCur, events;

  		if ( dest.nodeType !== 1 ) {
  			return;
  		}

  		// 1. Copy private data: events, handlers, etc.
  		if ( dataPriv.hasData( src ) ) {
  			pdataOld = dataPriv.get( src );
  			events = pdataOld.events;

  			if ( events ) {
  				dataPriv.remove( dest, "handle events" );

  				for ( type in events ) {
  					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  						jQuery.event.add( dest, type, events[ type ][ i ] );
  					}
  				}
  			}
  		}

  		// 2. Copy user data
  		if ( dataUser.hasData( src ) ) {
  			udataOld = dataUser.access( src );
  			udataCur = jQuery.extend( {}, udataOld );

  			dataUser.set( dest, udataCur );
  		}
  	}

  	// Fix IE bugs, see support tests
  	function fixInput( src, dest ) {
  		var nodeName = dest.nodeName.toLowerCase();

  		// Fails to persist the checked state of a cloned checkbox or radio button.
  		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  			dest.checked = src.checked;

  		// Fails to return the selected option to the default selected state when cloning options
  		} else if ( nodeName === "input" || nodeName === "textarea" ) {
  			dest.defaultValue = src.defaultValue;
  		}
  	}

  	function domManip( collection, args, callback, ignored ) {

  		// Flatten any nested arrays
  		args = flat( args );

  		var fragment, first, scripts, hasScripts, node, doc,
  			i = 0,
  			l = collection.length,
  			iNoClone = l - 1,
  			value = args[ 0 ],
  			valueIsFunction = isFunction( value );

  		// We can't cloneNode fragments that contain checked, in WebKit
  		if ( valueIsFunction ||
  				( l > 1 && typeof value === "string" &&
  					!support.checkClone && rchecked.test( value ) ) ) {
  			return collection.each( function( index ) {
  				var self = collection.eq( index );
  				if ( valueIsFunction ) {
  					args[ 0 ] = value.call( this, index, self.html() );
  				}
  				domManip( self, args, callback, ignored );
  			} );
  		}

  		if ( l ) {
  			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  			first = fragment.firstChild;

  			if ( fragment.childNodes.length === 1 ) {
  				fragment = first;
  			}

  			// Require either new content or an interest in ignored elements to invoke the callback
  			if ( first || ignored ) {
  				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  				hasScripts = scripts.length;

  				// Use the original fragment for the last item
  				// instead of the first because it can end up
  				// being emptied incorrectly in certain situations (trac-8070).
  				for ( ; i < l; i++ ) {
  					node = fragment;

  					if ( i !== iNoClone ) {
  						node = jQuery.clone( node, true, true );

  						// Keep references to cloned scripts for later restoration
  						if ( hasScripts ) {

  							// Support: Android <=4.0 only, PhantomJS 1 only
  							// push.apply(_, arraylike) throws on ancient WebKit
  							jQuery.merge( scripts, getAll( node, "script" ) );
  						}
  					}

  					callback.call( collection[ i ], node, i );
  				}

  				if ( hasScripts ) {
  					doc = scripts[ scripts.length - 1 ].ownerDocument;

  					// Re-enable scripts
  					jQuery.map( scripts, restoreScript );

  					// Evaluate executable scripts on first document insertion
  					for ( i = 0; i < hasScripts; i++ ) {
  						node = scripts[ i ];
  						if ( rscriptType.test( node.type || "" ) &&
  							!dataPriv.access( node, "globalEval" ) &&
  							jQuery.contains( doc, node ) ) {

  							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  								// Optional AJAX dependency, but won't run scripts if not present
  								if ( jQuery._evalUrl && !node.noModule ) {
  									jQuery._evalUrl( node.src, {
  										nonce: node.nonce || node.getAttribute( "nonce" )
  									}, doc );
  								}
  							} else {

  								// Unwrap a CDATA section containing script contents. This shouldn't be
  								// needed as in XML documents they're already not visible when
  								// inspecting element contents and in HTML documents they have no
  								// meaning but we're preserving that logic for backwards compatibility.
  								// This will be removed completely in 4.0. See gh-4904.
  								DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  							}
  						}
  					}
  				}
  			}
  		}

  		return collection;
  	}

  	function remove( elem, selector, keepData ) {
  		var node,
  			nodes = selector ? jQuery.filter( selector, elem ) : elem,
  			i = 0;

  		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  			if ( !keepData && node.nodeType === 1 ) {
  				jQuery.cleanData( getAll( node ) );
  			}

  			if ( node.parentNode ) {
  				if ( keepData && isAttached( node ) ) {
  					setGlobalEval( getAll( node, "script" ) );
  				}
  				node.parentNode.removeChild( node );
  			}
  		}

  		return elem;
  	}

  	jQuery.extend( {
  		htmlPrefilter: function( html ) {
  			return html;
  		},

  		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  			var i, l, srcElements, destElements,
  				clone = elem.cloneNode( true ),
  				inPage = isAttached( elem );

  			// Fix IE cloning issues
  			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  					!jQuery.isXMLDoc( elem ) ) {

  				// We eschew jQuery#find here for performance reasons:
  				// https://jsperf.com/getall-vs-sizzle/2
  				destElements = getAll( clone );
  				srcElements = getAll( elem );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					fixInput( srcElements[ i ], destElements[ i ] );
  				}
  			}

  			// Copy the events from the original to the clone
  			if ( dataAndEvents ) {
  				if ( deepDataAndEvents ) {
  					srcElements = srcElements || getAll( elem );
  					destElements = destElements || getAll( clone );

  					for ( i = 0, l = srcElements.length; i < l; i++ ) {
  						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  					}
  				} else {
  					cloneCopyEvent( elem, clone );
  				}
  			}

  			// Preserve script evaluation history
  			destElements = getAll( clone, "script" );
  			if ( destElements.length > 0 ) {
  				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  			}

  			// Return the cloned set
  			return clone;
  		},

  		cleanData: function( elems ) {
  			var data, elem, type,
  				special = jQuery.event.special,
  				i = 0;

  			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  				if ( acceptData( elem ) ) {
  					if ( ( data = elem[ dataPriv.expando ] ) ) {
  						if ( data.events ) {
  							for ( type in data.events ) {
  								if ( special[ type ] ) {
  									jQuery.event.remove( elem, type );

  								// This is a shortcut to avoid jQuery.event.remove's overhead
  								} else {
  									jQuery.removeEvent( elem, type, data.handle );
  								}
  							}
  						}

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataPriv.expando ] = undefined;
  					}
  					if ( elem[ dataUser.expando ] ) {

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataUser.expando ] = undefined;
  					}
  				}
  			}
  		}
  	} );

  	jQuery.fn.extend( {
  		detach: function( selector ) {
  			return remove( this, selector, true );
  		},

  		remove: function( selector ) {
  			return remove( this, selector );
  		},

  		text: function( value ) {
  			return access( this, function( value ) {
  				return value === undefined ?
  					jQuery.text( this ) :
  					this.empty().each( function() {
  						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  							this.textContent = value;
  						}
  					} );
  			}, null, value, arguments.length );
  		},

  		append: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.appendChild( elem );
  				}
  			} );
  		},

  		prepend: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.insertBefore( elem, target.firstChild );
  				}
  			} );
  		},

  		before: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this );
  				}
  			} );
  		},

  		after: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this.nextSibling );
  				}
  			} );
  		},

  		empty: function() {
  			var elem,
  				i = 0;

  			for ( ; ( elem = this[ i ] ) != null; i++ ) {
  				if ( elem.nodeType === 1 ) {

  					// Prevent memory leaks
  					jQuery.cleanData( getAll( elem, false ) );

  					// Remove any remaining nodes
  					elem.textContent = "";
  				}
  			}

  			return this;
  		},

  		clone: function( dataAndEvents, deepDataAndEvents ) {
  			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  			return this.map( function() {
  				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  			} );
  		},

  		html: function( value ) {
  			return access( this, function( value ) {
  				var elem = this[ 0 ] || {},
  					i = 0,
  					l = this.length;

  				if ( value === undefined && elem.nodeType === 1 ) {
  					return elem.innerHTML;
  				}

  				// See if we can take a shortcut and just use innerHTML
  				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  					value = jQuery.htmlPrefilter( value );

  					try {
  						for ( ; i < l; i++ ) {
  							elem = this[ i ] || {};

  							// Remove element nodes and prevent memory leaks
  							if ( elem.nodeType === 1 ) {
  								jQuery.cleanData( getAll( elem, false ) );
  								elem.innerHTML = value;
  							}
  						}

  						elem = 0;

  					// If using innerHTML throws an exception, use the fallback method
  					} catch ( e ) {}
  				}

  				if ( elem ) {
  					this.empty().append( value );
  				}
  			}, null, value, arguments.length );
  		},

  		replaceWith: function() {
  			var ignored = [];

  			// Make the changes, replacing each non-ignored context element with the new content
  			return domManip( this, arguments, function( elem ) {
  				var parent = this.parentNode;

  				if ( jQuery.inArray( this, ignored ) < 0 ) {
  					jQuery.cleanData( getAll( this ) );
  					if ( parent ) {
  						parent.replaceChild( elem, this );
  					}
  				}

  			// Force callback invocation
  			}, ignored );
  		}
  	} );

  	jQuery.each( {
  		appendTo: "append",
  		prependTo: "prepend",
  		insertBefore: "before",
  		insertAfter: "after",
  		replaceAll: "replaceWith"
  	}, function( name, original ) {
  		jQuery.fn[ name ] = function( selector ) {
  			var elems,
  				ret = [],
  				insert = jQuery( selector ),
  				last = insert.length - 1,
  				i = 0;

  			for ( ; i <= last; i++ ) {
  				elems = i === last ? this : this.clone( true );
  				jQuery( insert[ i ] )[ original ]( elems );

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// .get() because push.apply(_, arraylike) throws on ancient WebKit
  				push.apply( ret, elems.get() );
  			}

  			return this.pushStack( ret );
  		};
  	} );
  	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  	var rcustomProp = /^--/;


  	var getStyles = function( elem ) {

  			// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
  			// IE throws on elements created in popups
  			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  			var view = elem.ownerDocument.defaultView;

  			if ( !view || !view.opener ) {
  				view = window;
  			}

  			return view.getComputedStyle( elem );
  		};

  	var swap = function( elem, options, callback ) {
  		var ret, name,
  			old = {};

  		// Remember the old values, and insert the new ones
  		for ( name in options ) {
  			old[ name ] = elem.style[ name ];
  			elem.style[ name ] = options[ name ];
  		}

  		ret = callback.call( elem );

  		// Revert the old values
  		for ( name in options ) {
  			elem.style[ name ] = old[ name ];
  		}

  		return ret;
  	};


  	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  	( function() {

  		// Executing both pixelPosition & boxSizingReliable tests require only one layout
  		// so they're executed at the same time to save the second computation.
  		function computeStyleTests() {

  			// This is a singleton, we need to execute it only once
  			if ( !div ) {
  				return;
  			}

  			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  				"margin-top:1px;padding:0;border:0";
  			div.style.cssText =
  				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  				"margin:auto;border:1px;padding:1px;" +
  				"width:60%;top:1%";
  			documentElement.appendChild( container ).appendChild( div );

  			var divStyle = window.getComputedStyle( div );
  			pixelPositionVal = divStyle.top !== "1%";

  			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  			// Some styles come back with percentage values, even though they shouldn't
  			div.style.right = "60%";
  			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  			// Support: IE 9 - 11 only
  			// Detect misreporting of content dimensions for box-sizing:border-box elements
  			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  			// Support: IE 9 only
  			// Detect overflow:scroll screwiness (gh-3699)
  			// Support: Chrome <=64
  			// Don't get tricked when zoom affects offsetWidth (gh-4029)
  			div.style.position = "absolute";
  			scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  			documentElement.removeChild( container );

  			// Nullify the div so it wouldn't be stored in the memory and
  			// it will also be a sign that checks already performed
  			div = null;
  		}

  		function roundPixelMeasures( measure ) {
  			return Math.round( parseFloat( measure ) );
  		}

  		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  			reliableTrDimensionsVal, reliableMarginLeftVal,
  			container = document.createElement( "div" ),
  			div = document.createElement( "div" );

  		// Finish early in limited (non-browser) environments
  		if ( !div.style ) {
  			return;
  		}

  		// Support: IE <=9 - 11 only
  		// Style of cloned element affects source element cloned (trac-8908)
  		div.style.backgroundClip = "content-box";
  		div.cloneNode( true ).style.backgroundClip = "";
  		support.clearCloneStyle = div.style.backgroundClip === "content-box";

  		jQuery.extend( support, {
  			boxSizingReliable: function() {
  				computeStyleTests();
  				return boxSizingReliableVal;
  			},
  			pixelBoxStyles: function() {
  				computeStyleTests();
  				return pixelBoxStylesVal;
  			},
  			pixelPosition: function() {
  				computeStyleTests();
  				return pixelPositionVal;
  			},
  			reliableMarginLeft: function() {
  				computeStyleTests();
  				return reliableMarginLeftVal;
  			},
  			scrollboxSize: function() {
  				computeStyleTests();
  				return scrollboxSizeVal;
  			},

  			// Support: IE 9 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Behavior in IE 9 is more subtle than in newer versions & it passes
  			// some versions of this test; make sure not to make it pass there!
  			//
  			// Support: Firefox 70+
  			// Only Firefox includes border widths
  			// in computed dimensions. (gh-4529)
  			reliableTrDimensions: function() {
  				var table, tr, trChild, trStyle;
  				if ( reliableTrDimensionsVal == null ) {
  					table = document.createElement( "table" );
  					tr = document.createElement( "tr" );
  					trChild = document.createElement( "div" );

  					table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
  					tr.style.cssText = "box-sizing:content-box;border:1px solid";

  					// Support: Chrome 86+
  					// Height set through cssText does not get applied.
  					// Computed height then comes back as 0.
  					tr.style.height = "1px";
  					trChild.style.height = "9px";

  					// Support: Android 8 Chrome 86+
  					// In our bodyBackground.html iframe,
  					// display for all div elements is set to "inline",
  					// which causes a problem only in Android 8 Chrome 86.
  					// Ensuring the div is `display: block`
  					// gets around this issue.
  					trChild.style.display = "block";

  					documentElement
  						.appendChild( table )
  						.appendChild( tr )
  						.appendChild( trChild );

  					trStyle = window.getComputedStyle( tr );
  					reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
  						parseInt( trStyle.borderTopWidth, 10 ) +
  						parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

  					documentElement.removeChild( table );
  				}
  				return reliableTrDimensionsVal;
  			}
  		} );
  	} )();


  	function curCSS( elem, name, computed ) {
  		var width, minWidth, maxWidth, ret,
  			isCustomProp = rcustomProp.test( name ),

  			// Support: Firefox 51+
  			// Retrieving style before computed somehow
  			// fixes an issue with getting wrong values
  			// on detached elements
  			style = elem.style;

  		computed = computed || getStyles( elem );

  		// getPropertyValue is needed for:
  		//   .css('filter') (IE 9 only, trac-12537)
  		//   .css('--customProperty) (gh-3144)
  		if ( computed ) {

  			// Support: IE <=9 - 11+
  			// IE only supports `"float"` in `getPropertyValue`; in computed styles
  			// it's only available as `"cssFloat"`. We no longer modify properties
  			// sent to `.css()` apart from camelCasing, so we need to check both.
  			// Normally, this would create difference in behavior: if
  			// `getPropertyValue` returns an empty string, the value returned
  			// by `.css()` would be `undefined`. This is usually the case for
  			// disconnected elements. However, in IE even disconnected elements
  			// with no styles return `"none"` for `getPropertyValue( "float" )`
  			ret = computed.getPropertyValue( name ) || computed[ name ];

  			if ( isCustomProp && ret ) {

  				// Support: Firefox 105+, Chrome <=105+
  				// Spec requires trimming whitespace for custom properties (gh-4926).
  				// Firefox only trims leading whitespace. Chrome just collapses
  				// both leading & trailing whitespace to a single space.
  				//
  				// Fall back to `undefined` if empty string returned.
  				// This collapses a missing definition with property defined
  				// and set to an empty string but there's no standard API
  				// allowing us to differentiate them without a performance penalty
  				// and returning `undefined` aligns with older jQuery.
  				//
  				// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
  				// as whitespace while CSS does not, but this is not a problem
  				// because CSS preprocessing replaces them with U+000A LINE FEED
  				// (which *is* CSS whitespace)
  				// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
  				ret = ret.replace( rtrimCSS, "$1" ) || undefined;
  			}

  			if ( ret === "" && !isAttached( elem ) ) {
  				ret = jQuery.style( elem, name );
  			}

  			// A tribute to the "awesome hack by Dean Edwards"
  			// Android Browser returns percentage for some values,
  			// but width seems to be reliably pixels.
  			// This is against the CSSOM draft spec:
  			// https://drafts.csswg.org/cssom/#resolved-values
  			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  				// Remember the original values
  				width = style.width;
  				minWidth = style.minWidth;
  				maxWidth = style.maxWidth;

  				// Put in the new values to get a computed value out
  				style.minWidth = style.maxWidth = style.width = ret;
  				ret = computed.width;

  				// Revert the changed values
  				style.width = width;
  				style.minWidth = minWidth;
  				style.maxWidth = maxWidth;
  			}
  		}

  		return ret !== undefined ?

  			// Support: IE <=9 - 11 only
  			// IE returns zIndex value as an integer.
  			ret + "" :
  			ret;
  	}


  	function addGetHookIf( conditionFn, hookFn ) {

  		// Define the hook, we'll check on the first run if it's really needed.
  		return {
  			get: function() {
  				if ( conditionFn() ) {

  					// Hook not needed (or it's not possible to use it due
  					// to missing dependency), remove it.
  					delete this.get;
  					return;
  				}

  				// Hook needed; redefine it so that the support test is not executed again.
  				return ( this.get = hookFn ).apply( this, arguments );
  			}
  		};
  	}


  	var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  		emptyStyle = document.createElement( "div" ).style,
  		vendorProps = {};

  	// Return a vendor-prefixed property or undefined
  	function vendorPropName( name ) {

  		// Check for vendor prefixed names
  		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  			i = cssPrefixes.length;

  		while ( i-- ) {
  			name = cssPrefixes[ i ] + capName;
  			if ( name in emptyStyle ) {
  				return name;
  			}
  		}
  	}

  	// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  	function finalPropName( name ) {
  		var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  		if ( final ) {
  			return final;
  		}
  		if ( name in emptyStyle ) {
  			return name;
  		}
  		return vendorProps[ name ] = vendorPropName( name ) || name;
  	}


  	var

  		// Swappable if display is none or starts with table
  		// except "table", "table-cell", or "table-caption"
  		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  		cssNormalTransform = {
  			letterSpacing: "0",
  			fontWeight: "400"
  		};

  	function setPositiveNumber( _elem, value, subtract ) {

  		// Any relative (+/-) values have already been
  		// normalized at this point
  		var matches = rcssNum.exec( value );
  		return matches ?

  			// Guard against undefined "subtract", e.g., when used as in cssHooks
  			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  			value;
  	}

  	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  		var i = dimension === "width" ? 1 : 0,
  			extra = 0,
  			delta = 0,
  			marginDelta = 0;

  		// Adjustment may not be necessary
  		if ( box === ( isBorderBox ? "border" : "content" ) ) {
  			return 0;
  		}

  		for ( ; i < 4; i += 2 ) {

  			// Both box models exclude margin
  			// Count margin delta separately to only add it after scroll gutter adjustment.
  			// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
  			if ( box === "margin" ) {
  				marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  			}

  			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  			if ( !isBorderBox ) {

  				// Add padding
  				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  				// For "border" or "margin", add border
  				if ( box !== "padding" ) {
  					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  				// But still keep track of it otherwise
  				} else {
  					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}

  			// If we get here with a border-box (content + padding + border), we're seeking "content" or
  			// "padding" or "margin"
  			} else {

  				// For "content", subtract padding
  				if ( box === "content" ) {
  					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  				}

  				// For "content" or "padding", subtract border
  				if ( box !== "margin" ) {
  					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}
  			}
  		}

  		// Account for positive content-box scroll gutter when requested by providing computedVal
  		if ( !isBorderBox && computedVal >= 0 ) {

  			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  			// Assuming integer scroll gutter, subtract the rest and round down
  			delta += Math.max( 0, Math.ceil(
  				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  				computedVal -
  				delta -
  				extra -
  				0.5

  			// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  			// Use an explicit zero to avoid NaN (gh-3964)
  			) ) || 0;
  		}

  		return delta + marginDelta;
  	}

  	function getWidthOrHeight( elem, dimension, extra ) {

  		// Start with computed style
  		var styles = getStyles( elem ),

  			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  			// Fake content-box until we know it's needed to know the true value.
  			boxSizingNeeded = !support.boxSizingReliable() || extra,
  			isBorderBox = boxSizingNeeded &&
  				jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  			valueIsBorderBox = isBorderBox,

  			val = curCSS( elem, dimension, styles ),
  			offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  		// Support: Firefox <=54
  		// Return a confounding non-pixel value or feign ignorance, as appropriate.
  		if ( rnumnonpx.test( val ) ) {
  			if ( !extra ) {
  				return val;
  			}
  			val = "auto";
  		}


  		// Support: IE 9 - 11 only
  		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
  		// In those cases, the computed value can be trusted to be border-box.
  		if ( ( !support.boxSizingReliable() && isBorderBox ||

  			// Support: IE 10 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Interestingly, in some cases IE 9 doesn't suffer from this issue.
  			!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

  			// Fall back to offsetWidth/offsetHeight when value is "auto"
  			// This happens for inline elements with no explicit setting (gh-3571)
  			val === "auto" ||

  			// Support: Android <=4.1 - 4.3 only
  			// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

  			// Make sure the element is visible & connected
  			elem.getClientRects().length ) {

  			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  			// retrieved value as a content box dimension.
  			valueIsBorderBox = offsetProp in elem;
  			if ( valueIsBorderBox ) {
  				val = elem[ offsetProp ];
  			}
  		}

  		// Normalize "" and auto
  		val = parseFloat( val ) || 0;

  		// Adjust for the element's box model
  		return ( val +
  			boxModelAdjustment(
  				elem,
  				dimension,
  				extra || ( isBorderBox ? "border" : "content" ),
  				valueIsBorderBox,
  				styles,

  				// Provide the current computed size to request scroll gutter calculation (gh-3589)
  				val
  			)
  		) + "px";
  	}

  	jQuery.extend( {

  		// Add in style property hooks for overriding the default
  		// behavior of getting and setting a style property
  		cssHooks: {
  			opacity: {
  				get: function( elem, computed ) {
  					if ( computed ) {

  						// We should always get a number back from opacity
  						var ret = curCSS( elem, "opacity" );
  						return ret === "" ? "1" : ret;
  					}
  				}
  			}
  		},

  		// Don't automatically add "px" to these possibly-unitless properties
  		cssNumber: {
  			animationIterationCount: true,
  			aspectRatio: true,
  			borderImageSlice: true,
  			columnCount: true,
  			flexGrow: true,
  			flexShrink: true,
  			fontWeight: true,
  			gridArea: true,
  			gridColumn: true,
  			gridColumnEnd: true,
  			gridColumnStart: true,
  			gridRow: true,
  			gridRowEnd: true,
  			gridRowStart: true,
  			lineHeight: true,
  			opacity: true,
  			order: true,
  			orphans: true,
  			scale: true,
  			widows: true,
  			zIndex: true,
  			zoom: true,

  			// SVG-related
  			fillOpacity: true,
  			floodOpacity: true,
  			stopOpacity: true,
  			strokeMiterlimit: true,
  			strokeOpacity: true
  		},

  		// Add in properties whose names you wish to fix before
  		// setting or getting the value
  		cssProps: {},

  		// Get and set the style property on a DOM Node
  		style: function( elem, name, value, extra ) {

  			// Don't set styles on text and comment nodes
  			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  				return;
  			}

  			// Make sure that we're working with the right name
  			var ret, type, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name ),
  				style = elem.style;

  			// Make sure that we're working with the right name. We don't
  			// want to query the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Gets hook for the prefixed version, then unprefixed version
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// Check if we're setting a value
  			if ( value !== undefined ) {
  				type = typeof value;

  				// Convert "+=" or "-=" to relative numbers (trac-7345)
  				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  					value = adjustCSS( elem, name, ret );

  					// Fixes bug trac-9237
  					type = "number";
  				}

  				// Make sure that null and NaN values aren't set (trac-7116)
  				if ( value == null || value !== value ) {
  					return;
  				}

  				// If a number was passed in, add the unit (except for certain CSS properties)
  				// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  				// "px" to a few hardcoded values.
  				if ( type === "number" && !isCustomProp ) {
  					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  				}

  				// background-* props affect original clone's values
  				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  					style[ name ] = "inherit";
  				}

  				// If a hook was provided, use that value, otherwise just set the specified value
  				if ( !hooks || !( "set" in hooks ) ||
  					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  					if ( isCustomProp ) {
  						style.setProperty( name, value );
  					} else {
  						style[ name ] = value;
  					}
  				}

  			} else {

  				// If a hook was provided get the non-computed value from there
  				if ( hooks && "get" in hooks &&
  					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  					return ret;
  				}

  				// Otherwise just get the value from the style object
  				return style[ name ];
  			}
  		},

  		css: function( elem, name, extra, styles ) {
  			var val, num, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name );

  			// Make sure that we're working with the right name. We don't
  			// want to modify the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Try prefixed name followed by the unprefixed name
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// If a hook was provided get the computed value from there
  			if ( hooks && "get" in hooks ) {
  				val = hooks.get( elem, true, extra );
  			}

  			// Otherwise, if a way to get the computed value exists, use that
  			if ( val === undefined ) {
  				val = curCSS( elem, name, styles );
  			}

  			// Convert "normal" to computed value
  			if ( val === "normal" && name in cssNormalTransform ) {
  				val = cssNormalTransform[ name ];
  			}

  			// Make numeric if forced or a qualifier was provided and val looks numeric
  			if ( extra === "" || extra ) {
  				num = parseFloat( val );
  				return extra === true || isFinite( num ) ? num || 0 : val;
  			}

  			return val;
  		}
  	} );

  	jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  		jQuery.cssHooks[ dimension ] = {
  			get: function( elem, computed, extra ) {
  				if ( computed ) {

  					// Certain elements can have dimension info if we invisibly show them
  					// but it must have a current display style that would benefit
  					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  						// Support: Safari 8+
  						// Table columns in Safari have non-zero offsetWidth & zero
  						// getBoundingClientRect().width unless display is changed.
  						// Support: IE <=11 only
  						// Running getBoundingClientRect on a disconnected node
  						// in IE throws an error.
  						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  				}
  			},

  			set: function( elem, value, extra ) {
  				var matches,
  					styles = getStyles( elem ),

  					// Only read styles.position if the test has a chance to fail
  					// to avoid forcing a reflow.
  					scrollboxSizeBuggy = !support.scrollboxSize() &&
  						styles.position === "absolute",

  					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  					boxSizingNeeded = scrollboxSizeBuggy || extra,
  					isBorderBox = boxSizingNeeded &&
  						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  					subtract = extra ?
  						boxModelAdjustment(
  							elem,
  							dimension,
  							extra,
  							isBorderBox,
  							styles
  						) :
  						0;

  				// Account for unreliable border-box dimensions by comparing offset* to computed and
  				// faking a content-box to get border and padding (gh-3699)
  				if ( isBorderBox && scrollboxSizeBuggy ) {
  					subtract -= Math.ceil(
  						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  						parseFloat( styles[ dimension ] ) -
  						boxModelAdjustment( elem, dimension, "border", false, styles ) -
  						0.5
  					);
  				}

  				// Convert to pixels if value adjustment is needed
  				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  					( matches[ 3 ] || "px" ) !== "px" ) {

  					elem.style[ dimension ] = value;
  					value = jQuery.css( elem, dimension );
  				}

  				return setPositiveNumber( elem, value, subtract );
  			}
  		};
  	} );

  	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  		function( elem, computed ) {
  			if ( computed ) {
  				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  					elem.getBoundingClientRect().left -
  						swap( elem, { marginLeft: 0 }, function() {
  							return elem.getBoundingClientRect().left;
  						} )
  				) + "px";
  			}
  		}
  	);

  	// These hooks are used by animate to expand properties
  	jQuery.each( {
  		margin: "",
  		padding: "",
  		border: "Width"
  	}, function( prefix, suffix ) {
  		jQuery.cssHooks[ prefix + suffix ] = {
  			expand: function( value ) {
  				var i = 0,
  					expanded = {},

  					// Assumes a single number if not a string
  					parts = typeof value === "string" ? value.split( " " ) : [ value ];

  				for ( ; i < 4; i++ ) {
  					expanded[ prefix + cssExpand[ i ] + suffix ] =
  						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  				}

  				return expanded;
  			}
  		};

  		if ( prefix !== "margin" ) {
  			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  		}
  	} );

  	jQuery.fn.extend( {
  		css: function( name, value ) {
  			return access( this, function( elem, name, value ) {
  				var styles, len,
  					map = {},
  					i = 0;

  				if ( Array.isArray( name ) ) {
  					styles = getStyles( elem );
  					len = name.length;

  					for ( ; i < len; i++ ) {
  						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  					}

  					return map;
  				}

  				return value !== undefined ?
  					jQuery.style( elem, name, value ) :
  					jQuery.css( elem, name );
  			}, name, value, arguments.length > 1 );
  		}
  	} );


  	function Tween( elem, options, prop, end, easing ) {
  		return new Tween.prototype.init( elem, options, prop, end, easing );
  	}
  	jQuery.Tween = Tween;

  	Tween.prototype = {
  		constructor: Tween,
  		init: function( elem, options, prop, end, easing, unit ) {
  			this.elem = elem;
  			this.prop = prop;
  			this.easing = easing || jQuery.easing._default;
  			this.options = options;
  			this.start = this.now = this.cur();
  			this.end = end;
  			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  		},
  		cur: function() {
  			var hooks = Tween.propHooks[ this.prop ];

  			return hooks && hooks.get ?
  				hooks.get( this ) :
  				Tween.propHooks._default.get( this );
  		},
  		run: function( percent ) {
  			var eased,
  				hooks = Tween.propHooks[ this.prop ];

  			if ( this.options.duration ) {
  				this.pos = eased = jQuery.easing[ this.easing ](
  					percent, this.options.duration * percent, 0, 1, this.options.duration
  				);
  			} else {
  				this.pos = eased = percent;
  			}
  			this.now = ( this.end - this.start ) * eased + this.start;

  			if ( this.options.step ) {
  				this.options.step.call( this.elem, this.now, this );
  			}

  			if ( hooks && hooks.set ) {
  				hooks.set( this );
  			} else {
  				Tween.propHooks._default.set( this );
  			}
  			return this;
  		}
  	};

  	Tween.prototype.init.prototype = Tween.prototype;

  	Tween.propHooks = {
  		_default: {
  			get: function( tween ) {
  				var result;

  				// Use a property on the element directly when it is not a DOM element,
  				// or when there is no matching style property that exists.
  				if ( tween.elem.nodeType !== 1 ||
  					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  					return tween.elem[ tween.prop ];
  				}

  				// Passing an empty string as a 3rd parameter to .css will automatically
  				// attempt a parseFloat and fallback to a string if the parse fails.
  				// Simple values such as "10px" are parsed to Float;
  				// complex values such as "rotate(1rad)" are returned as-is.
  				result = jQuery.css( tween.elem, tween.prop, "" );

  				// Empty strings, null, undefined and "auto" are converted to 0.
  				return !result || result === "auto" ? 0 : result;
  			},
  			set: function( tween ) {

  				// Use step hook for back compat.
  				// Use cssHook if its there.
  				// Use .style if available and use plain properties where available.
  				if ( jQuery.fx.step[ tween.prop ] ) {
  					jQuery.fx.step[ tween.prop ]( tween );
  				} else if ( tween.elem.nodeType === 1 && (
  					jQuery.cssHooks[ tween.prop ] ||
  						tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
  					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  				} else {
  					tween.elem[ tween.prop ] = tween.now;
  				}
  			}
  		}
  	};

  	// Support: IE <=9 only
  	// Panic based approach to setting things on disconnected nodes
  	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  		set: function( tween ) {
  			if ( tween.elem.nodeType && tween.elem.parentNode ) {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	};

  	jQuery.easing = {
  		linear: function( p ) {
  			return p;
  		},
  		swing: function( p ) {
  			return 0.5 - Math.cos( p * Math.PI ) / 2;
  		},
  		_default: "swing"
  	};

  	jQuery.fx = Tween.prototype.init;

  	// Back compat <1.8 extension point
  	jQuery.fx.step = {};




  	var
  		fxNow, inProgress,
  		rfxtypes = /^(?:toggle|show|hide)$/,
  		rrun = /queueHooks$/;

  	function schedule() {
  		if ( inProgress ) {
  			if ( document.hidden === false && window.requestAnimationFrame ) {
  				window.requestAnimationFrame( schedule );
  			} else {
  				window.setTimeout( schedule, jQuery.fx.interval );
  			}

  			jQuery.fx.tick();
  		}
  	}

  	// Animations created synchronously will run synchronously
  	function createFxNow() {
  		window.setTimeout( function() {
  			fxNow = undefined;
  		} );
  		return ( fxNow = Date.now() );
  	}

  	// Generate parameters to create a standard animation
  	function genFx( type, includeWidth ) {
  		var which,
  			i = 0,
  			attrs = { height: type };

  		// If we include width, step value is 1 to do all cssExpand values,
  		// otherwise step value is 2 to skip over Left and Right
  		includeWidth = includeWidth ? 1 : 0;
  		for ( ; i < 4; i += 2 - includeWidth ) {
  			which = cssExpand[ i ];
  			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  		}

  		if ( includeWidth ) {
  			attrs.opacity = attrs.width = type;
  		}

  		return attrs;
  	}

  	function createTween( value, prop, animation ) {
  		var tween,
  			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  			index = 0,
  			length = collection.length;
  		for ( ; index < length; index++ ) {
  			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  				// We're done with this property
  				return tween;
  			}
  		}
  	}

  	function defaultPrefilter( elem, props, opts ) {
  		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  			isBox = "width" in props || "height" in props,
  			anim = this,
  			orig = {},
  			style = elem.style,
  			hidden = elem.nodeType && isHiddenWithinTree( elem ),
  			dataShow = dataPriv.get( elem, "fxshow" );

  		// Queue-skipping animations hijack the fx hooks
  		if ( !opts.queue ) {
  			hooks = jQuery._queueHooks( elem, "fx" );
  			if ( hooks.unqueued == null ) {
  				hooks.unqueued = 0;
  				oldfire = hooks.empty.fire;
  				hooks.empty.fire = function() {
  					if ( !hooks.unqueued ) {
  						oldfire();
  					}
  				};
  			}
  			hooks.unqueued++;

  			anim.always( function() {

  				// Ensure the complete handler is called before this completes
  				anim.always( function() {
  					hooks.unqueued--;
  					if ( !jQuery.queue( elem, "fx" ).length ) {
  						hooks.empty.fire();
  					}
  				} );
  			} );
  		}

  		// Detect show/hide animations
  		for ( prop in props ) {
  			value = props[ prop ];
  			if ( rfxtypes.test( value ) ) {
  				delete props[ prop ];
  				toggle = toggle || value === "toggle";
  				if ( value === ( hidden ? "hide" : "show" ) ) {

  					// Pretend to be hidden if this is a "show" and
  					// there is still data from a stopped show/hide
  					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  						hidden = true;

  					// Ignore all other no-op show/hide data
  					} else {
  						continue;
  					}
  				}
  				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  			}
  		}

  		// Bail out if this is a no-op like .hide().hide()
  		propTween = !jQuery.isEmptyObject( props );
  		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  			return;
  		}

  		// Restrict "overflow" and "display" styles during box animations
  		if ( isBox && elem.nodeType === 1 ) {

  			// Support: IE <=9 - 11, Edge 12 - 15
  			// Record all 3 overflow attributes because IE does not infer the shorthand
  			// from identically-valued overflowX and overflowY and Edge just mirrors
  			// the overflowX value there.
  			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  			// Identify a display type, preferring old show/hide data over the CSS cascade
  			restoreDisplay = dataShow && dataShow.display;
  			if ( restoreDisplay == null ) {
  				restoreDisplay = dataPriv.get( elem, "display" );
  			}
  			display = jQuery.css( elem, "display" );
  			if ( display === "none" ) {
  				if ( restoreDisplay ) {
  					display = restoreDisplay;
  				} else {

  					// Get nonempty value(s) by temporarily forcing visibility
  					showHide( [ elem ], true );
  					restoreDisplay = elem.style.display || restoreDisplay;
  					display = jQuery.css( elem, "display" );
  					showHide( [ elem ] );
  				}
  			}

  			// Animate inline elements as inline-block
  			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  				if ( jQuery.css( elem, "float" ) === "none" ) {

  					// Restore the original display value at the end of pure show/hide animations
  					if ( !propTween ) {
  						anim.done( function() {
  							style.display = restoreDisplay;
  						} );
  						if ( restoreDisplay == null ) {
  							display = style.display;
  							restoreDisplay = display === "none" ? "" : display;
  						}
  					}
  					style.display = "inline-block";
  				}
  			}
  		}

  		if ( opts.overflow ) {
  			style.overflow = "hidden";
  			anim.always( function() {
  				style.overflow = opts.overflow[ 0 ];
  				style.overflowX = opts.overflow[ 1 ];
  				style.overflowY = opts.overflow[ 2 ];
  			} );
  		}

  		// Implement show/hide animations
  		propTween = false;
  		for ( prop in orig ) {

  			// General show/hide setup for this element animation
  			if ( !propTween ) {
  				if ( dataShow ) {
  					if ( "hidden" in dataShow ) {
  						hidden = dataShow.hidden;
  					}
  				} else {
  					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  				}

  				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  				if ( toggle ) {
  					dataShow.hidden = !hidden;
  				}

  				// Show elements before animating them
  				if ( hidden ) {
  					showHide( [ elem ], true );
  				}

  				/* eslint-disable no-loop-func */

  				anim.done( function() {

  					/* eslint-enable no-loop-func */

  					// The final step of a "hide" animation is actually hiding the element
  					if ( !hidden ) {
  						showHide( [ elem ] );
  					}
  					dataPriv.remove( elem, "fxshow" );
  					for ( prop in orig ) {
  						jQuery.style( elem, prop, orig[ prop ] );
  					}
  				} );
  			}

  			// Per-property setup
  			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  			if ( !( prop in dataShow ) ) {
  				dataShow[ prop ] = propTween.start;
  				if ( hidden ) {
  					propTween.end = propTween.start;
  					propTween.start = 0;
  				}
  			}
  		}
  	}

  	function propFilter( props, specialEasing ) {
  		var index, name, easing, value, hooks;

  		// camelCase, specialEasing and expand cssHook pass
  		for ( index in props ) {
  			name = camelCase( index );
  			easing = specialEasing[ name ];
  			value = props[ index ];
  			if ( Array.isArray( value ) ) {
  				easing = value[ 1 ];
  				value = props[ index ] = value[ 0 ];
  			}

  			if ( index !== name ) {
  				props[ name ] = value;
  				delete props[ index ];
  			}

  			hooks = jQuery.cssHooks[ name ];
  			if ( hooks && "expand" in hooks ) {
  				value = hooks.expand( value );
  				delete props[ name ];

  				// Not quite $.extend, this won't overwrite existing keys.
  				// Reusing 'index' because we have the correct "name"
  				for ( index in value ) {
  					if ( !( index in props ) ) {
  						props[ index ] = value[ index ];
  						specialEasing[ index ] = easing;
  					}
  				}
  			} else {
  				specialEasing[ name ] = easing;
  			}
  		}
  	}

  	function Animation( elem, properties, options ) {
  		var result,
  			stopped,
  			index = 0,
  			length = Animation.prefilters.length,
  			deferred = jQuery.Deferred().always( function() {

  				// Don't match elem in the :animated selector
  				delete tick.elem;
  			} ),
  			tick = function() {
  				if ( stopped ) {
  					return false;
  				}
  				var currentTime = fxNow || createFxNow(),
  					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  					// Support: Android 2.3 only
  					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
  					temp = remaining / animation.duration || 0,
  					percent = 1 - temp,
  					index = 0,
  					length = animation.tweens.length;

  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( percent );
  				}

  				deferred.notifyWith( elem, [ animation, percent, remaining ] );

  				// If there's more to do, yield
  				if ( percent < 1 && length ) {
  					return remaining;
  				}

  				// If this was an empty animation, synthesize a final progress notification
  				if ( !length ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  				}

  				// Resolve the animation and report its conclusion
  				deferred.resolveWith( elem, [ animation ] );
  				return false;
  			},
  			animation = deferred.promise( {
  				elem: elem,
  				props: jQuery.extend( {}, properties ),
  				opts: jQuery.extend( true, {
  					specialEasing: {},
  					easing: jQuery.easing._default
  				}, options ),
  				originalProperties: properties,
  				originalOptions: options,
  				startTime: fxNow || createFxNow(),
  				duration: options.duration,
  				tweens: [],
  				createTween: function( prop, end ) {
  					var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  					animation.tweens.push( tween );
  					return tween;
  				},
  				stop: function( gotoEnd ) {
  					var index = 0,

  						// If we are going to the end, we want to run all the tweens
  						// otherwise we skip this part
  						length = gotoEnd ? animation.tweens.length : 0;
  					if ( stopped ) {
  						return this;
  					}
  					stopped = true;
  					for ( ; index < length; index++ ) {
  						animation.tweens[ index ].run( 1 );
  					}

  					// Resolve when we played the last frame; otherwise, reject
  					if ( gotoEnd ) {
  						deferred.notifyWith( elem, [ animation, 1, 0 ] );
  						deferred.resolveWith( elem, [ animation, gotoEnd ] );
  					} else {
  						deferred.rejectWith( elem, [ animation, gotoEnd ] );
  					}
  					return this;
  				}
  			} ),
  			props = animation.props;

  		propFilter( props, animation.opts.specialEasing );

  		for ( ; index < length; index++ ) {
  			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  			if ( result ) {
  				if ( isFunction( result.stop ) ) {
  					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  						result.stop.bind( result );
  				}
  				return result;
  			}
  		}

  		jQuery.map( props, createTween, animation );

  		if ( isFunction( animation.opts.start ) ) {
  			animation.opts.start.call( elem, animation );
  		}

  		// Attach callbacks from options
  		animation
  			.progress( animation.opts.progress )
  			.done( animation.opts.done, animation.opts.complete )
  			.fail( animation.opts.fail )
  			.always( animation.opts.always );

  		jQuery.fx.timer(
  			jQuery.extend( tick, {
  				elem: elem,
  				anim: animation,
  				queue: animation.opts.queue
  			} )
  		);

  		return animation;
  	}

  	jQuery.Animation = jQuery.extend( Animation, {

  		tweeners: {
  			"*": [ function( prop, value ) {
  				var tween = this.createTween( prop, value );
  				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  				return tween;
  			} ]
  		},

  		tweener: function( props, callback ) {
  			if ( isFunction( props ) ) {
  				callback = props;
  				props = [ "*" ];
  			} else {
  				props = props.match( rnothtmlwhite );
  			}

  			var prop,
  				index = 0,
  				length = props.length;

  			for ( ; index < length; index++ ) {
  				prop = props[ index ];
  				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  				Animation.tweeners[ prop ].unshift( callback );
  			}
  		},

  		prefilters: [ defaultPrefilter ],

  		prefilter: function( callback, prepend ) {
  			if ( prepend ) {
  				Animation.prefilters.unshift( callback );
  			} else {
  				Animation.prefilters.push( callback );
  			}
  		}
  	} );

  	jQuery.speed = function( speed, easing, fn ) {
  		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  			complete: fn || !fn && easing ||
  				isFunction( speed ) && speed,
  			duration: speed,
  			easing: fn && easing || easing && !isFunction( easing ) && easing
  		};

  		// Go to the end state if fx are off
  		if ( jQuery.fx.off ) {
  			opt.duration = 0;

  		} else {
  			if ( typeof opt.duration !== "number" ) {
  				if ( opt.duration in jQuery.fx.speeds ) {
  					opt.duration = jQuery.fx.speeds[ opt.duration ];

  				} else {
  					opt.duration = jQuery.fx.speeds._default;
  				}
  			}
  		}

  		// Normalize opt.queue - true/undefined/null -> "fx"
  		if ( opt.queue == null || opt.queue === true ) {
  			opt.queue = "fx";
  		}

  		// Queueing
  		opt.old = opt.complete;

  		opt.complete = function() {
  			if ( isFunction( opt.old ) ) {
  				opt.old.call( this );
  			}

  			if ( opt.queue ) {
  				jQuery.dequeue( this, opt.queue );
  			}
  		};

  		return opt;
  	};

  	jQuery.fn.extend( {
  		fadeTo: function( speed, to, easing, callback ) {

  			// Show any hidden elements after setting opacity to 0
  			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  				// Animate to the value specified
  				.end().animate( { opacity: to }, speed, easing, callback );
  		},
  		animate: function( prop, speed, easing, callback ) {
  			var empty = jQuery.isEmptyObject( prop ),
  				optall = jQuery.speed( speed, easing, callback ),
  				doAnimation = function() {

  					// Operate on a copy of prop so per-property easing won't be lost
  					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  					// Empty animations, or finishing resolves immediately
  					if ( empty || dataPriv.get( this, "finish" ) ) {
  						anim.stop( true );
  					}
  				};

  			doAnimation.finish = doAnimation;

  			return empty || optall.queue === false ?
  				this.each( doAnimation ) :
  				this.queue( optall.queue, doAnimation );
  		},
  		stop: function( type, clearQueue, gotoEnd ) {
  			var stopQueue = function( hooks ) {
  				var stop = hooks.stop;
  				delete hooks.stop;
  				stop( gotoEnd );
  			};

  			if ( typeof type !== "string" ) {
  				gotoEnd = clearQueue;
  				clearQueue = type;
  				type = undefined;
  			}
  			if ( clearQueue ) {
  				this.queue( type || "fx", [] );
  			}

  			return this.each( function() {
  				var dequeue = true,
  					index = type != null && type + "queueHooks",
  					timers = jQuery.timers,
  					data = dataPriv.get( this );

  				if ( index ) {
  					if ( data[ index ] && data[ index ].stop ) {
  						stopQueue( data[ index ] );
  					}
  				} else {
  					for ( index in data ) {
  						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  							stopQueue( data[ index ] );
  						}
  					}
  				}

  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this &&
  						( type == null || timers[ index ].queue === type ) ) {

  						timers[ index ].anim.stop( gotoEnd );
  						dequeue = false;
  						timers.splice( index, 1 );
  					}
  				}

  				// Start the next in the queue if the last step wasn't forced.
  				// Timers currently will call their complete callbacks, which
  				// will dequeue but only if they were gotoEnd.
  				if ( dequeue || !gotoEnd ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  		},
  		finish: function( type ) {
  			if ( type !== false ) {
  				type = type || "fx";
  			}
  			return this.each( function() {
  				var index,
  					data = dataPriv.get( this ),
  					queue = data[ type + "queue" ],
  					hooks = data[ type + "queueHooks" ],
  					timers = jQuery.timers,
  					length = queue ? queue.length : 0;

  				// Enable finishing flag on private data
  				data.finish = true;

  				// Empty the queue first
  				jQuery.queue( this, type, [] );

  				if ( hooks && hooks.stop ) {
  					hooks.stop.call( this, true );
  				}

  				// Look for any active animations, and finish them
  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  						timers[ index ].anim.stop( true );
  						timers.splice( index, 1 );
  					}
  				}

  				// Look for any animations in the old queue and finish them
  				for ( index = 0; index < length; index++ ) {
  					if ( queue[ index ] && queue[ index ].finish ) {
  						queue[ index ].finish.call( this );
  					}
  				}

  				// Turn off finishing flag
  				delete data.finish;
  			} );
  		}
  	} );

  	jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
  		var cssFn = jQuery.fn[ name ];
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return speed == null || typeof speed === "boolean" ?
  				cssFn.apply( this, arguments ) :
  				this.animate( genFx( name, true ), speed, easing, callback );
  		};
  	} );

  	// Generate shortcuts for custom animations
  	jQuery.each( {
  		slideDown: genFx( "show" ),
  		slideUp: genFx( "hide" ),
  		slideToggle: genFx( "toggle" ),
  		fadeIn: { opacity: "show" },
  		fadeOut: { opacity: "hide" },
  		fadeToggle: { opacity: "toggle" }
  	}, function( name, props ) {
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return this.animate( props, speed, easing, callback );
  		};
  	} );

  	jQuery.timers = [];
  	jQuery.fx.tick = function() {
  		var timer,
  			i = 0,
  			timers = jQuery.timers;

  		fxNow = Date.now();

  		for ( ; i < timers.length; i++ ) {
  			timer = timers[ i ];

  			// Run the timer and safely remove it when done (allowing for external removal)
  			if ( !timer() && timers[ i ] === timer ) {
  				timers.splice( i--, 1 );
  			}
  		}

  		if ( !timers.length ) {
  			jQuery.fx.stop();
  		}
  		fxNow = undefined;
  	};

  	jQuery.fx.timer = function( timer ) {
  		jQuery.timers.push( timer );
  		jQuery.fx.start();
  	};

  	jQuery.fx.interval = 13;
  	jQuery.fx.start = function() {
  		if ( inProgress ) {
  			return;
  		}

  		inProgress = true;
  		schedule();
  	};

  	jQuery.fx.stop = function() {
  		inProgress = null;
  	};

  	jQuery.fx.speeds = {
  		slow: 600,
  		fast: 200,

  		// Default speed
  		_default: 400
  	};


  	// Based off of the plugin by Clint Helfers, with permission.
  	jQuery.fn.delay = function( time, type ) {
  		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  		type = type || "fx";

  		return this.queue( type, function( next, hooks ) {
  			var timeout = window.setTimeout( next, time );
  			hooks.stop = function() {
  				window.clearTimeout( timeout );
  			};
  		} );
  	};


  	( function() {
  		var input = document.createElement( "input" ),
  			select = document.createElement( "select" ),
  			opt = select.appendChild( document.createElement( "option" ) );

  		input.type = "checkbox";

  		// Support: Android <=4.3 only
  		// Default value for a checkbox should be "on"
  		support.checkOn = input.value !== "";

  		// Support: IE <=11 only
  		// Must access selectedIndex to make default options select
  		support.optSelected = opt.selected;

  		// Support: IE <=11 only
  		// An input loses its value after becoming a radio
  		input = document.createElement( "input" );
  		input.value = "t";
  		input.type = "radio";
  		support.radioValue = input.value === "t";
  	} )();


  	var boolHook,
  		attrHandle = jQuery.expr.attrHandle;

  	jQuery.fn.extend( {
  		attr: function( name, value ) {
  			return access( this, jQuery.attr, name, value, arguments.length > 1 );
  		},

  		removeAttr: function( name ) {
  			return this.each( function() {
  				jQuery.removeAttr( this, name );
  			} );
  		}
  	} );

  	jQuery.extend( {
  		attr: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set attributes on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			// Fallback to prop when attributes are not supported
  			if ( typeof elem.getAttribute === "undefined" ) {
  				return jQuery.prop( elem, name, value );
  			}

  			// Attribute hooks are determined by the lowercase version
  			// Grab necessary hook if one is defined
  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  			}

  			if ( value !== undefined ) {
  				if ( value === null ) {
  					jQuery.removeAttr( elem, name );
  					return;
  				}

  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				elem.setAttribute( name, value + "" );
  				return value;
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			ret = jQuery.find.attr( elem, name );

  			// Non-existent attributes return null, we normalize to undefined
  			return ret == null ? undefined : ret;
  		},

  		attrHooks: {
  			type: {
  				set: function( elem, value ) {
  					if ( !support.radioValue && value === "radio" &&
  						nodeName( elem, "input" ) ) {
  						var val = elem.value;
  						elem.setAttribute( "type", value );
  						if ( val ) {
  							elem.value = val;
  						}
  						return value;
  					}
  				}
  			}
  		},

  		removeAttr: function( elem, value ) {
  			var name,
  				i = 0,

  				// Attribute names can contain non-HTML whitespace characters
  				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  				attrNames = value && value.match( rnothtmlwhite );

  			if ( attrNames && elem.nodeType === 1 ) {
  				while ( ( name = attrNames[ i++ ] ) ) {
  					elem.removeAttribute( name );
  				}
  			}
  		}
  	} );

  	// Hooks for boolean attributes
  	boolHook = {
  		set: function( elem, value, name ) {
  			if ( value === false ) {

  				// Remove boolean attributes when set to false
  				jQuery.removeAttr( elem, name );
  			} else {
  				elem.setAttribute( name, name );
  			}
  			return name;
  		}
  	};

  	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  		var getter = attrHandle[ name ] || jQuery.find.attr;

  		attrHandle[ name ] = function( elem, name, isXML ) {
  			var ret, handle,
  				lowercaseName = name.toLowerCase();

  			if ( !isXML ) {

  				// Avoid an infinite loop by temporarily removing this function from the getter
  				handle = attrHandle[ lowercaseName ];
  				attrHandle[ lowercaseName ] = ret;
  				ret = getter( elem, name, isXML ) != null ?
  					lowercaseName :
  					null;
  				attrHandle[ lowercaseName ] = handle;
  			}
  			return ret;
  		};
  	} );




  	var rfocusable = /^(?:input|select|textarea|button)$/i,
  		rclickable = /^(?:a|area)$/i;

  	jQuery.fn.extend( {
  		prop: function( name, value ) {
  			return access( this, jQuery.prop, name, value, arguments.length > 1 );
  		},

  		removeProp: function( name ) {
  			return this.each( function() {
  				delete this[ jQuery.propFix[ name ] || name ];
  			} );
  		}
  	} );

  	jQuery.extend( {
  		prop: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set properties on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  				// Fix name and attach hooks
  				name = jQuery.propFix[ name ] || name;
  				hooks = jQuery.propHooks[ name ];
  			}

  			if ( value !== undefined ) {
  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				return ( elem[ name ] = value );
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			return elem[ name ];
  		},

  		propHooks: {
  			tabIndex: {
  				get: function( elem ) {

  					// Support: IE <=9 - 11 only
  					// elem.tabIndex doesn't always return the
  					// correct value when it hasn't been explicitly set
  					// Use proper attribute retrieval (trac-12072)
  					var tabindex = jQuery.find.attr( elem, "tabindex" );

  					if ( tabindex ) {
  						return parseInt( tabindex, 10 );
  					}

  					if (
  						rfocusable.test( elem.nodeName ) ||
  						rclickable.test( elem.nodeName ) &&
  						elem.href
  					) {
  						return 0;
  					}

  					return -1;
  				}
  			}
  		},

  		propFix: {
  			"for": "htmlFor",
  			"class": "className"
  		}
  	} );

  	// Support: IE <=11 only
  	// Accessing the selectedIndex property
  	// forces the browser to respect setting selected
  	// on the option
  	// The getter ensures a default option is selected
  	// when in an optgroup
  	// eslint rule "no-unused-expressions" is disabled for this code
  	// since it considers such accessions noop
  	if ( !support.optSelected ) {
  		jQuery.propHooks.selected = {
  			get: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent && parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  				return null;
  			},
  			set: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent ) {
  					parent.selectedIndex;

  					if ( parent.parentNode ) {
  						parent.parentNode.selectedIndex;
  					}
  				}
  			}
  		};
  	}

  	jQuery.each( [
  		"tabIndex",
  		"readOnly",
  		"maxLength",
  		"cellSpacing",
  		"cellPadding",
  		"rowSpan",
  		"colSpan",
  		"useMap",
  		"frameBorder",
  		"contentEditable"
  	], function() {
  		jQuery.propFix[ this.toLowerCase() ] = this;
  	} );




  		// Strip and collapse whitespace according to HTML spec
  		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  		function stripAndCollapse( value ) {
  			var tokens = value.match( rnothtmlwhite ) || [];
  			return tokens.join( " " );
  		}


  	function getClass( elem ) {
  		return elem.getAttribute && elem.getAttribute( "class" ) || "";
  	}

  	function classesToArray( value ) {
  		if ( Array.isArray( value ) ) {
  			return value;
  		}
  		if ( typeof value === "string" ) {
  			return value.match( rnothtmlwhite ) || [];
  		}
  		return [];
  	}

  	jQuery.fn.extend( {
  		addClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];
  							if ( cur.indexOf( " " + className + " " ) < 0 ) {
  								cur += className + " ";
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		removeClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			if ( !arguments.length ) {
  				return this.attr( "class", "" );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );

  					// This expression is here for better compressibility (see addClass)
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];

  							// Remove *all* instances
  							while ( cur.indexOf( " " + className + " " ) > -1 ) {
  								cur = cur.replace( " " + className + " ", " " );
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		toggleClass: function( value, stateVal ) {
  			var classNames, className, i, self,
  				type = typeof value,
  				isValidValue = type === "string" || Array.isArray( value );

  			if ( isFunction( value ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).toggleClass(
  						value.call( this, i, getClass( this ), stateVal ),
  						stateVal
  					);
  				} );
  			}

  			if ( typeof stateVal === "boolean" && isValidValue ) {
  				return stateVal ? this.addClass( value ) : this.removeClass( value );
  			}

  			classNames = classesToArray( value );

  			return this.each( function() {
  				if ( isValidValue ) {

  					// Toggle individual class names
  					self = jQuery( this );

  					for ( i = 0; i < classNames.length; i++ ) {
  						className = classNames[ i ];

  						// Check each className given, space separated list
  						if ( self.hasClass( className ) ) {
  							self.removeClass( className );
  						} else {
  							self.addClass( className );
  						}
  					}

  				// Toggle whole class name
  				} else if ( value === undefined || type === "boolean" ) {
  					className = getClass( this );
  					if ( className ) {

  						// Store className if set
  						dataPriv.set( this, "__className__", className );
  					}

  					// If the element has a class name or if we're passed `false`,
  					// then remove the whole classname (if there was one, the above saved it).
  					// Otherwise bring back whatever was previously saved (if anything),
  					// falling back to the empty string if nothing was stored.
  					if ( this.setAttribute ) {
  						this.setAttribute( "class",
  							className || value === false ?
  								"" :
  								dataPriv.get( this, "__className__" ) || ""
  						);
  					}
  				}
  			} );
  		},

  		hasClass: function( selector ) {
  			var className, elem,
  				i = 0;

  			className = " " + selector + " ";
  			while ( ( elem = this[ i++ ] ) ) {
  				if ( elem.nodeType === 1 &&
  					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  				}
  			}

  			return false;
  		}
  	} );




  	var rreturn = /\r/g;

  	jQuery.fn.extend( {
  		val: function( value ) {
  			var hooks, ret, valueIsFunction,
  				elem = this[ 0 ];

  			if ( !arguments.length ) {
  				if ( elem ) {
  					hooks = jQuery.valHooks[ elem.type ] ||
  						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  					if ( hooks &&
  						"get" in hooks &&
  						( ret = hooks.get( elem, "value" ) ) !== undefined
  					) {
  						return ret;
  					}

  					ret = elem.value;

  					// Handle most common string cases
  					if ( typeof ret === "string" ) {
  						return ret.replace( rreturn, "" );
  					}

  					// Handle cases where value is null/undef or number
  					return ret == null ? "" : ret;
  				}

  				return;
  			}

  			valueIsFunction = isFunction( value );

  			return this.each( function( i ) {
  				var val;

  				if ( this.nodeType !== 1 ) {
  					return;
  				}

  				if ( valueIsFunction ) {
  					val = value.call( this, i, jQuery( this ).val() );
  				} else {
  					val = value;
  				}

  				// Treat null/undefined as ""; convert numbers to string
  				if ( val == null ) {
  					val = "";

  				} else if ( typeof val === "number" ) {
  					val += "";

  				} else if ( Array.isArray( val ) ) {
  					val = jQuery.map( val, function( value ) {
  						return value == null ? "" : value + "";
  					} );
  				}

  				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  				// If set returns undefined, fall back to normal setting
  				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  					this.value = val;
  				}
  			} );
  		}
  	} );

  	jQuery.extend( {
  		valHooks: {
  			option: {
  				get: function( elem ) {

  					var val = jQuery.find.attr( elem, "value" );
  					return val != null ?
  						val :

  						// Support: IE <=10 - 11 only
  						// option.text throws exceptions (trac-14686, trac-14858)
  						// Strip and collapse whitespace
  						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  						stripAndCollapse( jQuery.text( elem ) );
  				}
  			},
  			select: {
  				get: function( elem ) {
  					var value, option, i,
  						options = elem.options,
  						index = elem.selectedIndex,
  						one = elem.type === "select-one",
  						values = one ? null : [],
  						max = one ? index + 1 : options.length;

  					if ( index < 0 ) {
  						i = max;

  					} else {
  						i = one ? index : 0;
  					}

  					// Loop through all the selected options
  					for ( ; i < max; i++ ) {
  						option = options[ i ];

  						// Support: IE <=9 only
  						// IE8-9 doesn't update selected after form reset (trac-2551)
  						if ( ( option.selected || i === index ) &&

  								// Don't return options that are disabled or in a disabled optgroup
  								!option.disabled &&
  								( !option.parentNode.disabled ||
  									!nodeName( option.parentNode, "optgroup" ) ) ) {

  							// Get the specific value for the option
  							value = jQuery( option ).val();

  							// We don't need an array for one selects
  							if ( one ) {
  								return value;
  							}

  							// Multi-Selects return an array
  							values.push( value );
  						}
  					}

  					return values;
  				},

  				set: function( elem, value ) {
  					var optionSet, option,
  						options = elem.options,
  						values = jQuery.makeArray( value ),
  						i = options.length;

  					while ( i-- ) {
  						option = options[ i ];

  						/* eslint-disable no-cond-assign */

  						if ( option.selected =
  							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  						) {
  							optionSet = true;
  						}

  						/* eslint-enable no-cond-assign */
  					}

  					// Force browsers to behave consistently when non-matching value is set
  					if ( !optionSet ) {
  						elem.selectedIndex = -1;
  					}
  					return values;
  				}
  			}
  		}
  	} );

  	// Radios and checkboxes getter/setter
  	jQuery.each( [ "radio", "checkbox" ], function() {
  		jQuery.valHooks[ this ] = {
  			set: function( elem, value ) {
  				if ( Array.isArray( value ) ) {
  					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  				}
  			}
  		};
  		if ( !support.checkOn ) {
  			jQuery.valHooks[ this ].get = function( elem ) {
  				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  			};
  		}
  	} );




  	// Return jQuery for attributes-only inclusion
  	var location = window.location;

  	var nonce = { guid: Date.now() };

  	var rquery = ( /\?/ );



  	// Cross-browser xml parsing
  	jQuery.parseXML = function( data ) {
  		var xml, parserErrorElem;
  		if ( !data || typeof data !== "string" ) {
  			return null;
  		}

  		// Support: IE 9 - 11 only
  		// IE throws on parseFromString with invalid input.
  		try {
  			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  		} catch ( e ) {}

  		parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
  		if ( !xml || parserErrorElem ) {
  			jQuery.error( "Invalid XML: " + (
  				parserErrorElem ?
  					jQuery.map( parserErrorElem.childNodes, function( el ) {
  						return el.textContent;
  					} ).join( "\n" ) :
  					data
  			) );
  		}
  		return xml;
  	};


  	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  		stopPropagationCallback = function( e ) {
  			e.stopPropagation();
  		};

  	jQuery.extend( jQuery.event, {

  		trigger: function( event, data, elem, onlyHandlers ) {

  			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  				eventPath = [ elem || document ],
  				type = hasOwn.call( event, "type" ) ? event.type : event,
  				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  			cur = lastElement = tmp = elem = elem || document;

  			// Don't do events on text and comment nodes
  			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  				return;
  			}

  			// focus/blur morphs to focusin/out; ensure we're not firing them right now
  			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  				return;
  			}

  			if ( type.indexOf( "." ) > -1 ) {

  				// Namespaced trigger; create a regexp to match event type in handle()
  				namespaces = type.split( "." );
  				type = namespaces.shift();
  				namespaces.sort();
  			}
  			ontype = type.indexOf( ":" ) < 0 && "on" + type;

  			// Caller can pass in a jQuery.Event object, Object, or just an event type string
  			event = event[ jQuery.expando ] ?
  				event :
  				new jQuery.Event( type, typeof event === "object" && event );

  			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  			event.isTrigger = onlyHandlers ? 2 : 3;
  			event.namespace = namespaces.join( "." );
  			event.rnamespace = event.namespace ?
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  				null;

  			// Clean up the event in case it is being reused
  			event.result = undefined;
  			if ( !event.target ) {
  				event.target = elem;
  			}

  			// Clone any incoming data and prepend the event, creating the handler arg list
  			data = data == null ?
  				[ event ] :
  				jQuery.makeArray( data, [ event ] );

  			// Allow special events to draw outside the lines
  			special = jQuery.event.special[ type ] || {};
  			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  				return;
  			}

  			// Determine event propagation path in advance, per W3C events spec (trac-9951)
  			// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
  			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  				bubbleType = special.delegateType || type;
  				if ( !rfocusMorph.test( bubbleType + type ) ) {
  					cur = cur.parentNode;
  				}
  				for ( ; cur; cur = cur.parentNode ) {
  					eventPath.push( cur );
  					tmp = cur;
  				}

  				// Only add window if we got to document (e.g., not plain obj or detached DOM)
  				if ( tmp === ( elem.ownerDocument || document ) ) {
  					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  				}
  			}

  			// Fire handlers on the event path
  			i = 0;
  			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  				lastElement = cur;
  				event.type = i > 1 ?
  					bubbleType :
  					special.bindType || type;

  				// jQuery handler
  				handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
  					dataPriv.get( cur, "handle" );
  				if ( handle ) {
  					handle.apply( cur, data );
  				}

  				// Native handler
  				handle = ontype && cur[ ontype ];
  				if ( handle && handle.apply && acceptData( cur ) ) {
  					event.result = handle.apply( cur, data );
  					if ( event.result === false ) {
  						event.preventDefault();
  					}
  				}
  			}
  			event.type = type;

  			// If nobody prevented the default action, do it now
  			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  				if ( ( !special._default ||
  					special._default.apply( eventPath.pop(), data ) === false ) &&
  					acceptData( elem ) ) {

  					// Call a native DOM method on the target with the same name as the event.
  					// Don't do default actions on window, that's where global variables be (trac-6170)
  					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  						// Don't re-trigger an onFOO event when we call its FOO() method
  						tmp = elem[ ontype ];

  						if ( tmp ) {
  							elem[ ontype ] = null;
  						}

  						// Prevent re-triggering of the same event, since we already bubbled it above
  						jQuery.event.triggered = type;

  						if ( event.isPropagationStopped() ) {
  							lastElement.addEventListener( type, stopPropagationCallback );
  						}

  						elem[ type ]();

  						if ( event.isPropagationStopped() ) {
  							lastElement.removeEventListener( type, stopPropagationCallback );
  						}

  						jQuery.event.triggered = undefined;

  						if ( tmp ) {
  							elem[ ontype ] = tmp;
  						}
  					}
  				}
  			}

  			return event.result;
  		},

  		// Piggyback on a donor event to simulate a different one
  		// Used only for `focus(in | out)` events
  		simulate: function( type, elem, event ) {
  			var e = jQuery.extend(
  				new jQuery.Event(),
  				event,
  				{
  					type: type,
  					isSimulated: true
  				}
  			);

  			jQuery.event.trigger( e, null, elem );
  		}

  	} );

  	jQuery.fn.extend( {

  		trigger: function( type, data ) {
  			return this.each( function() {
  				jQuery.event.trigger( type, data, this );
  			} );
  		},
  		triggerHandler: function( type, data ) {
  			var elem = this[ 0 ];
  			if ( elem ) {
  				return jQuery.event.trigger( type, data, elem, true );
  			}
  		}
  	} );


  	var
  		rbracket = /\[\]$/,
  		rCRLF = /\r?\n/g,
  		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  		rsubmittable = /^(?:input|select|textarea|keygen)/i;

  	function buildParams( prefix, obj, traditional, add ) {
  		var name;

  		if ( Array.isArray( obj ) ) {

  			// Serialize array item.
  			jQuery.each( obj, function( i, v ) {
  				if ( traditional || rbracket.test( prefix ) ) {

  					// Treat each array item as a scalar.
  					add( prefix, v );

  				} else {

  					// Item is non-scalar (array or object), encode its numeric index.
  					buildParams(
  						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  						v,
  						traditional,
  						add
  					);
  				}
  			} );

  		} else if ( !traditional && toType( obj ) === "object" ) {

  			// Serialize object item.
  			for ( name in obj ) {
  				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  			}

  		} else {

  			// Serialize scalar item.
  			add( prefix, obj );
  		}
  	}

  	// Serialize an array of form elements or a set of
  	// key/values into a query string
  	jQuery.param = function( a, traditional ) {
  		var prefix,
  			s = [],
  			add = function( key, valueOrFunction ) {

  				// If value is a function, invoke it and use its return value
  				var value = isFunction( valueOrFunction ) ?
  					valueOrFunction() :
  					valueOrFunction;

  				s[ s.length ] = encodeURIComponent( key ) + "=" +
  					encodeURIComponent( value == null ? "" : value );
  			};

  		if ( a == null ) {
  			return "";
  		}

  		// If an array was passed in, assume that it is an array of form elements.
  		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  			// Serialize the form elements
  			jQuery.each( a, function() {
  				add( this.name, this.value );
  			} );

  		} else {

  			// If traditional, encode the "old" way (the way 1.3.2 or older
  			// did it), otherwise encode params recursively.
  			for ( prefix in a ) {
  				buildParams( prefix, a[ prefix ], traditional, add );
  			}
  		}

  		// Return the resulting serialization
  		return s.join( "&" );
  	};

  	jQuery.fn.extend( {
  		serialize: function() {
  			return jQuery.param( this.serializeArray() );
  		},
  		serializeArray: function() {
  			return this.map( function() {

  				// Can add propHook for "elements" to filter or add form elements
  				var elements = jQuery.prop( this, "elements" );
  				return elements ? jQuery.makeArray( elements ) : this;
  			} ).filter( function() {
  				var type = this.type;

  				// Use .is( ":disabled" ) so that fieldset[disabled] works
  				return this.name && !jQuery( this ).is( ":disabled" ) &&
  					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  					( this.checked || !rcheckableType.test( type ) );
  			} ).map( function( _i, elem ) {
  				var val = jQuery( this ).val();

  				if ( val == null ) {
  					return null;
  				}

  				if ( Array.isArray( val ) ) {
  					return jQuery.map( val, function( val ) {
  						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  					} );
  				}

  				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  			} ).get();
  		}
  	} );


  	var
  		r20 = /%20/g,
  		rhash = /#.*$/,
  		rantiCache = /([?&])_=[^&]*/,
  		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  		// trac-7653, trac-8125, trac-8152: local protocol detection
  		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  		rnoContent = /^(?:GET|HEAD)$/,
  		rprotocol = /^\/\//,

  		/* Prefilters
  		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  		 * 2) These are called:
  		 *    - BEFORE asking for a transport
  		 *    - AFTER param serialization (s.data is a string if s.processData is true)
  		 * 3) key is the dataType
  		 * 4) the catchall symbol "*" can be used
  		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  		 */
  		prefilters = {},

  		/* Transports bindings
  		 * 1) key is the dataType
  		 * 2) the catchall symbol "*" can be used
  		 * 3) selection will start with transport dataType and THEN go to "*" if needed
  		 */
  		transports = {},

  		// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
  		allTypes = "*/".concat( "*" ),

  		// Anchor tag for parsing the document origin
  		originAnchor = document.createElement( "a" );

  	originAnchor.href = location.href;

  	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  	function addToPrefiltersOrTransports( structure ) {

  		// dataTypeExpression is optional and defaults to "*"
  		return function( dataTypeExpression, func ) {

  			if ( typeof dataTypeExpression !== "string" ) {
  				func = dataTypeExpression;
  				dataTypeExpression = "*";
  			}

  			var dataType,
  				i = 0,
  				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  			if ( isFunction( func ) ) {

  				// For each dataType in the dataTypeExpression
  				while ( ( dataType = dataTypes[ i++ ] ) ) {

  					// Prepend if requested
  					if ( dataType[ 0 ] === "+" ) {
  						dataType = dataType.slice( 1 ) || "*";
  						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  					// Otherwise append
  					} else {
  						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  					}
  				}
  			}
  		};
  	}

  	// Base inspection function for prefilters and transports
  	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  		var inspected = {},
  			seekingTransport = ( structure === transports );

  		function inspect( dataType ) {
  			var selected;
  			inspected[ dataType ] = true;
  			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  				if ( typeof dataTypeOrTransport === "string" &&
  					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  					options.dataTypes.unshift( dataTypeOrTransport );
  					inspect( dataTypeOrTransport );
  					return false;
  				} else if ( seekingTransport ) {
  					return !( selected = dataTypeOrTransport );
  				}
  			} );
  			return selected;
  		}

  		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  	}

  	// A special extend for ajax options
  	// that takes "flat" options (not to be deep extended)
  	// Fixes trac-9887
  	function ajaxExtend( target, src ) {
  		var key, deep,
  			flatOptions = jQuery.ajaxSettings.flatOptions || {};

  		for ( key in src ) {
  			if ( src[ key ] !== undefined ) {
  				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  			}
  		}
  		if ( deep ) {
  			jQuery.extend( true, target, deep );
  		}

  		return target;
  	}

  	/* Handles responses to an ajax request:
  	 * - finds the right dataType (mediates between content-type and expected dataType)
  	 * - returns the corresponding response
  	 */
  	function ajaxHandleResponses( s, jqXHR, responses ) {

  		var ct, type, finalDataType, firstDataType,
  			contents = s.contents,
  			dataTypes = s.dataTypes;

  		// Remove auto dataType and get content-type in the process
  		while ( dataTypes[ 0 ] === "*" ) {
  			dataTypes.shift();
  			if ( ct === undefined ) {
  				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  			}
  		}

  		// Check if we're dealing with a known content-type
  		if ( ct ) {
  			for ( type in contents ) {
  				if ( contents[ type ] && contents[ type ].test( ct ) ) {
  					dataTypes.unshift( type );
  					break;
  				}
  			}
  		}

  		// Check to see if we have a response for the expected dataType
  		if ( dataTypes[ 0 ] in responses ) {
  			finalDataType = dataTypes[ 0 ];
  		} else {

  			// Try convertible dataTypes
  			for ( type in responses ) {
  				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  					finalDataType = type;
  					break;
  				}
  				if ( !firstDataType ) {
  					firstDataType = type;
  				}
  			}

  			// Or just use first one
  			finalDataType = finalDataType || firstDataType;
  		}

  		// If we found a dataType
  		// We add the dataType to the list if needed
  		// and return the corresponding response
  		if ( finalDataType ) {
  			if ( finalDataType !== dataTypes[ 0 ] ) {
  				dataTypes.unshift( finalDataType );
  			}
  			return responses[ finalDataType ];
  		}
  	}

  	/* Chain conversions given the request and the original response
  	 * Also sets the responseXXX fields on the jqXHR instance
  	 */
  	function ajaxConvert( s, response, jqXHR, isSuccess ) {
  		var conv2, current, conv, tmp, prev,
  			converters = {},

  			// Work with a copy of dataTypes in case we need to modify it for conversion
  			dataTypes = s.dataTypes.slice();

  		// Create converters map with lowercased keys
  		if ( dataTypes[ 1 ] ) {
  			for ( conv in s.converters ) {
  				converters[ conv.toLowerCase() ] = s.converters[ conv ];
  			}
  		}

  		current = dataTypes.shift();

  		// Convert to each sequential dataType
  		while ( current ) {

  			if ( s.responseFields[ current ] ) {
  				jqXHR[ s.responseFields[ current ] ] = response;
  			}

  			// Apply the dataFilter if provided
  			if ( !prev && isSuccess && s.dataFilter ) {
  				response = s.dataFilter( response, s.dataType );
  			}

  			prev = current;
  			current = dataTypes.shift();

  			if ( current ) {

  				// There's only work to do if current dataType is non-auto
  				if ( current === "*" ) {

  					current = prev;

  				// Convert response if prev dataType is non-auto and differs from current
  				} else if ( prev !== "*" && prev !== current ) {

  					// Seek a direct converter
  					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  					// If none found, seek a pair
  					if ( !conv ) {
  						for ( conv2 in converters ) {

  							// If conv2 outputs current
  							tmp = conv2.split( " " );
  							if ( tmp[ 1 ] === current ) {

  								// If prev can be converted to accepted input
  								conv = converters[ prev + " " + tmp[ 0 ] ] ||
  									converters[ "* " + tmp[ 0 ] ];
  								if ( conv ) {

  									// Condense equivalence converters
  									if ( conv === true ) {
  										conv = converters[ conv2 ];

  									// Otherwise, insert the intermediate dataType
  									} else if ( converters[ conv2 ] !== true ) {
  										current = tmp[ 0 ];
  										dataTypes.unshift( tmp[ 1 ] );
  									}
  									break;
  								}
  							}
  						}
  					}

  					// Apply converter (if not an equivalence)
  					if ( conv !== true ) {

  						// Unless errors are allowed to bubble, catch and return them
  						if ( conv && s.throws ) {
  							response = conv( response );
  						} else {
  							try {
  								response = conv( response );
  							} catch ( e ) {
  								return {
  									state: "parsererror",
  									error: conv ? e : "No conversion from " + prev + " to " + current
  								};
  							}
  						}
  					}
  				}
  			}
  		}

  		return { state: "success", data: response };
  	}

  	jQuery.extend( {

  		// Counter for holding the number of active queries
  		active: 0,

  		// Last-Modified header cache for next request
  		lastModified: {},
  		etag: {},

  		ajaxSettings: {
  			url: location.href,
  			type: "GET",
  			isLocal: rlocalProtocol.test( location.protocol ),
  			global: true,
  			processData: true,
  			async: true,
  			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  			/*
  			timeout: 0,
  			data: null,
  			dataType: null,
  			username: null,
  			password: null,
  			cache: null,
  			throws: false,
  			traditional: false,
  			headers: {},
  			*/

  			accepts: {
  				"*": allTypes,
  				text: "text/plain",
  				html: "text/html",
  				xml: "application/xml, text/xml",
  				json: "application/json, text/javascript"
  			},

  			contents: {
  				xml: /\bxml\b/,
  				html: /\bhtml/,
  				json: /\bjson\b/
  			},

  			responseFields: {
  				xml: "responseXML",
  				text: "responseText",
  				json: "responseJSON"
  			},

  			// Data converters
  			// Keys separate source (or catchall "*") and destination types with a single space
  			converters: {

  				// Convert anything to text
  				"* text": String,

  				// Text to html (true = no transformation)
  				"text html": true,

  				// Evaluate text as a json expression
  				"text json": JSON.parse,

  				// Parse text as xml
  				"text xml": jQuery.parseXML
  			},

  			// For options that shouldn't be deep extended:
  			// you can add your own custom options here if
  			// and when you create one that shouldn't be
  			// deep extended (see ajaxExtend)
  			flatOptions: {
  				url: true,
  				context: true
  			}
  		},

  		// Creates a full fledged settings object into target
  		// with both ajaxSettings and settings fields.
  		// If target is omitted, writes into ajaxSettings.
  		ajaxSetup: function( target, settings ) {
  			return settings ?

  				// Building a settings object
  				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  				// Extending ajaxSettings
  				ajaxExtend( jQuery.ajaxSettings, target );
  		},

  		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  		ajaxTransport: addToPrefiltersOrTransports( transports ),

  		// Main method
  		ajax: function( url, options ) {

  			// If url is an object, simulate pre-1.5 signature
  			if ( typeof url === "object" ) {
  				options = url;
  				url = undefined;
  			}

  			// Force options to be an object
  			options = options || {};

  			var transport,

  				// URL without anti-cache param
  				cacheURL,

  				// Response headers
  				responseHeadersString,
  				responseHeaders,

  				// timeout handle
  				timeoutTimer,

  				// Url cleanup var
  				urlAnchor,

  				// Request state (becomes false upon send and true upon completion)
  				completed,

  				// To know if global events are to be dispatched
  				fireGlobals,

  				// Loop variable
  				i,

  				// uncached part of the url
  				uncached,

  				// Create the final options object
  				s = jQuery.ajaxSetup( {}, options ),

  				// Callbacks context
  				callbackContext = s.context || s,

  				// Context for global events is callbackContext if it is a DOM node or jQuery collection
  				globalEventContext = s.context &&
  					( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  				// Deferreds
  				deferred = jQuery.Deferred(),
  				completeDeferred = jQuery.Callbacks( "once memory" ),

  				// Status-dependent callbacks
  				statusCode = s.statusCode || {},

  				// Headers (they are sent all at once)
  				requestHeaders = {},
  				requestHeadersNames = {},

  				// Default abort message
  				strAbort = "canceled",

  				// Fake xhr
  				jqXHR = {
  					readyState: 0,

  					// Builds headers hashtable if needed
  					getResponseHeader: function( key ) {
  						var match;
  						if ( completed ) {
  							if ( !responseHeaders ) {
  								responseHeaders = {};
  								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  									responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
  										( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
  											.concat( match[ 2 ] );
  								}
  							}
  							match = responseHeaders[ key.toLowerCase() + " " ];
  						}
  						return match == null ? null : match.join( ", " );
  					},

  					// Raw string
  					getAllResponseHeaders: function() {
  						return completed ? responseHeadersString : null;
  					},

  					// Caches the header
  					setRequestHeader: function( name, value ) {
  						if ( completed == null ) {
  							name = requestHeadersNames[ name.toLowerCase() ] =
  								requestHeadersNames[ name.toLowerCase() ] || name;
  							requestHeaders[ name ] = value;
  						}
  						return this;
  					},

  					// Overrides response content-type header
  					overrideMimeType: function( type ) {
  						if ( completed == null ) {
  							s.mimeType = type;
  						}
  						return this;
  					},

  					// Status-dependent callbacks
  					statusCode: function( map ) {
  						var code;
  						if ( map ) {
  							if ( completed ) {

  								// Execute the appropriate callbacks
  								jqXHR.always( map[ jqXHR.status ] );
  							} else {

  								// Lazy-add the new callbacks in a way that preserves old ones
  								for ( code in map ) {
  									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  								}
  							}
  						}
  						return this;
  					},

  					// Cancel the request
  					abort: function( statusText ) {
  						var finalText = statusText || strAbort;
  						if ( transport ) {
  							transport.abort( finalText );
  						}
  						done( 0, finalText );
  						return this;
  					}
  				};

  			// Attach deferreds
  			deferred.promise( jqXHR );

  			// Add protocol if not provided (prefilters might expect it)
  			// Handle falsy url in the settings object (trac-10093: consistency with old signature)
  			// We also use the url parameter if available
  			s.url = ( ( url || s.url || location.href ) + "" )
  				.replace( rprotocol, location.protocol + "//" );

  			// Alias method option to type as per ticket trac-12004
  			s.type = options.method || options.type || s.method || s.type;

  			// Extract dataTypes list
  			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  			// A cross-domain request is in order when the origin doesn't match the current origin.
  			if ( s.crossDomain == null ) {
  				urlAnchor = document.createElement( "a" );

  				// Support: IE <=8 - 11, Edge 12 - 15
  				// IE throws exception on accessing the href property if url is malformed,
  				// e.g. http://example.com:80x/
  				try {
  					urlAnchor.href = s.url;

  					// Support: IE <=8 - 11 only
  					// Anchor's host property isn't correctly set when s.url is relative
  					urlAnchor.href = urlAnchor.href;
  					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  						urlAnchor.protocol + "//" + urlAnchor.host;
  				} catch ( e ) {

  					// If there is an error parsing the URL, assume it is crossDomain,
  					// it can be rejected by the transport if it is invalid
  					s.crossDomain = true;
  				}
  			}

  			// Convert data if not already a string
  			if ( s.data && s.processData && typeof s.data !== "string" ) {
  				s.data = jQuery.param( s.data, s.traditional );
  			}

  			// Apply prefilters
  			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  			// If request was aborted inside a prefilter, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// We can fire global events as of now if asked to
  			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
  			fireGlobals = jQuery.event && s.global;

  			// Watch for a new set of requests
  			if ( fireGlobals && jQuery.active++ === 0 ) {
  				jQuery.event.trigger( "ajaxStart" );
  			}

  			// Uppercase the type
  			s.type = s.type.toUpperCase();

  			// Determine if request has content
  			s.hasContent = !rnoContent.test( s.type );

  			// Save the URL in case we're toying with the If-Modified-Since
  			// and/or If-None-Match header later on
  			// Remove hash to simplify url manipulation
  			cacheURL = s.url.replace( rhash, "" );

  			// More options handling for requests with no content
  			if ( !s.hasContent ) {

  				// Remember the hash so we can put it back
  				uncached = s.url.slice( cacheURL.length );

  				// If data is available and should be processed, append data to url
  				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  					// trac-9682: remove data so that it's not used in an eventual retry
  					delete s.data;
  				}

  				// Add or update anti-cache param if needed
  				if ( s.cache === false ) {
  					cacheURL = cacheURL.replace( rantiCache, "$1" );
  					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
  						uncached;
  				}

  				// Put hash and anti-cache on the URL that will be requested (gh-1732)
  				s.url = cacheURL + uncached;

  			// Change '%20' to '+' if this is encoded form body content (gh-2658)
  			} else if ( s.data && s.processData &&
  				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  				s.data = s.data.replace( r20, "+" );
  			}

  			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  			if ( s.ifModified ) {
  				if ( jQuery.lastModified[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  				}
  				if ( jQuery.etag[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  				}
  			}

  			// Set the correct header, if data is being sent
  			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  				jqXHR.setRequestHeader( "Content-Type", s.contentType );
  			}

  			// Set the Accepts header for the server, depending on the dataType
  			jqXHR.setRequestHeader(
  				"Accept",
  				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  					s.accepts[ s.dataTypes[ 0 ] ] +
  						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  					s.accepts[ "*" ]
  			);

  			// Check for headers option
  			for ( i in s.headers ) {
  				jqXHR.setRequestHeader( i, s.headers[ i ] );
  			}

  			// Allow custom headers/mimetypes and early abort
  			if ( s.beforeSend &&
  				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  				// Abort if not done already and return
  				return jqXHR.abort();
  			}

  			// Aborting is no longer a cancellation
  			strAbort = "abort";

  			// Install callbacks on deferreds
  			completeDeferred.add( s.complete );
  			jqXHR.done( s.success );
  			jqXHR.fail( s.error );

  			// Get transport
  			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  			// If no transport, we auto-abort
  			if ( !transport ) {
  				done( -1, "No Transport" );
  			} else {
  				jqXHR.readyState = 1;

  				// Send global event
  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  				}

  				// If request was aborted inside ajaxSend, stop there
  				if ( completed ) {
  					return jqXHR;
  				}

  				// Timeout
  				if ( s.async && s.timeout > 0 ) {
  					timeoutTimer = window.setTimeout( function() {
  						jqXHR.abort( "timeout" );
  					}, s.timeout );
  				}

  				try {
  					completed = false;
  					transport.send( requestHeaders, done );
  				} catch ( e ) {

  					// Rethrow post-completion exceptions
  					if ( completed ) {
  						throw e;
  					}

  					// Propagate others as results
  					done( -1, e );
  				}
  			}

  			// Callback for when everything is done
  			function done( status, nativeStatusText, responses, headers ) {
  				var isSuccess, success, error, response, modified,
  					statusText = nativeStatusText;

  				// Ignore repeat invocations
  				if ( completed ) {
  					return;
  				}

  				completed = true;

  				// Clear timeout if it exists
  				if ( timeoutTimer ) {
  					window.clearTimeout( timeoutTimer );
  				}

  				// Dereference transport for early garbage collection
  				// (no matter how long the jqXHR object will be used)
  				transport = undefined;

  				// Cache response headers
  				responseHeadersString = headers || "";

  				// Set readyState
  				jqXHR.readyState = status > 0 ? 4 : 0;

  				// Determine if successful
  				isSuccess = status >= 200 && status < 300 || status === 304;

  				// Get response data
  				if ( responses ) {
  					response = ajaxHandleResponses( s, jqXHR, responses );
  				}

  				// Use a noop converter for missing script but not if jsonp
  				if ( !isSuccess &&
  					jQuery.inArray( "script", s.dataTypes ) > -1 &&
  					jQuery.inArray( "json", s.dataTypes ) < 0 ) {
  					s.converters[ "text script" ] = function() {};
  				}

  				// Convert no matter what (that way responseXXX fields are always set)
  				response = ajaxConvert( s, response, jqXHR, isSuccess );

  				// If successful, handle type chaining
  				if ( isSuccess ) {

  					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  					if ( s.ifModified ) {
  						modified = jqXHR.getResponseHeader( "Last-Modified" );
  						if ( modified ) {
  							jQuery.lastModified[ cacheURL ] = modified;
  						}
  						modified = jqXHR.getResponseHeader( "etag" );
  						if ( modified ) {
  							jQuery.etag[ cacheURL ] = modified;
  						}
  					}

  					// if no content
  					if ( status === 204 || s.type === "HEAD" ) {
  						statusText = "nocontent";

  					// if not modified
  					} else if ( status === 304 ) {
  						statusText = "notmodified";

  					// If we have data, let's convert it
  					} else {
  						statusText = response.state;
  						success = response.data;
  						error = response.error;
  						isSuccess = !error;
  					}
  				} else {

  					// Extract error from statusText and normalize for non-aborts
  					error = statusText;
  					if ( status || !statusText ) {
  						statusText = "error";
  						if ( status < 0 ) {
  							status = 0;
  						}
  					}
  				}

  				// Set data for the fake xhr object
  				jqXHR.status = status;
  				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  				// Success/Error
  				if ( isSuccess ) {
  					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  				} else {
  					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  				}

  				// Status-dependent callbacks
  				jqXHR.statusCode( statusCode );
  				statusCode = undefined;

  				if ( fireGlobals ) {
  					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  						[ jqXHR, s, isSuccess ? success : error ] );
  				}

  				// Complete
  				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  					// Handle the global AJAX counter
  					if ( !( --jQuery.active ) ) {
  						jQuery.event.trigger( "ajaxStop" );
  					}
  				}
  			}

  			return jqXHR;
  		},

  		getJSON: function( url, data, callback ) {
  			return jQuery.get( url, data, callback, "json" );
  		},

  		getScript: function( url, callback ) {
  			return jQuery.get( url, undefined, callback, "script" );
  		}
  	} );

  	jQuery.each( [ "get", "post" ], function( _i, method ) {
  		jQuery[ method ] = function( url, data, callback, type ) {

  			// Shift arguments if data argument was omitted
  			if ( isFunction( data ) ) {
  				type = type || callback;
  				callback = data;
  				data = undefined;
  			}

  			// The url can be an options object (which then must have .url)
  			return jQuery.ajax( jQuery.extend( {
  				url: url,
  				type: method,
  				dataType: type,
  				data: data,
  				success: callback
  			}, jQuery.isPlainObject( url ) && url ) );
  		};
  	} );

  	jQuery.ajaxPrefilter( function( s ) {
  		var i;
  		for ( i in s.headers ) {
  			if ( i.toLowerCase() === "content-type" ) {
  				s.contentType = s.headers[ i ] || "";
  			}
  		}
  	} );


  	jQuery._evalUrl = function( url, options, doc ) {
  		return jQuery.ajax( {
  			url: url,

  			// Make this explicit, since user can override this through ajaxSetup (trac-11264)
  			type: "GET",
  			dataType: "script",
  			cache: true,
  			async: false,
  			global: false,

  			// Only evaluate the response if it is successful (gh-4126)
  			// dataFilter is not invoked for failure responses, so using it instead
  			// of the default converter is kludgy but it works.
  			converters: {
  				"text script": function() {}
  			},
  			dataFilter: function( response ) {
  				jQuery.globalEval( response, options, doc );
  			}
  		} );
  	};


  	jQuery.fn.extend( {
  		wrapAll: function( html ) {
  			var wrap;

  			if ( this[ 0 ] ) {
  				if ( isFunction( html ) ) {
  					html = html.call( this[ 0 ] );
  				}

  				// The elements to wrap the target around
  				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  				if ( this[ 0 ].parentNode ) {
  					wrap.insertBefore( this[ 0 ] );
  				}

  				wrap.map( function() {
  					var elem = this;

  					while ( elem.firstElementChild ) {
  						elem = elem.firstElementChild;
  					}

  					return elem;
  				} ).append( this );
  			}

  			return this;
  		},

  		wrapInner: function( html ) {
  			if ( isFunction( html ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).wrapInner( html.call( this, i ) );
  				} );
  			}

  			return this.each( function() {
  				var self = jQuery( this ),
  					contents = self.contents();

  				if ( contents.length ) {
  					contents.wrapAll( html );

  				} else {
  					self.append( html );
  				}
  			} );
  		},

  		wrap: function( html ) {
  			var htmlIsFunction = isFunction( html );

  			return this.each( function( i ) {
  				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  			} );
  		},

  		unwrap: function( selector ) {
  			this.parent( selector ).not( "body" ).each( function() {
  				jQuery( this ).replaceWith( this.childNodes );
  			} );
  			return this;
  		}
  	} );


  	jQuery.expr.pseudos.hidden = function( elem ) {
  		return !jQuery.expr.pseudos.visible( elem );
  	};
  	jQuery.expr.pseudos.visible = function( elem ) {
  		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  	};




  	jQuery.ajaxSettings.xhr = function() {
  		try {
  			return new window.XMLHttpRequest();
  		} catch ( e ) {}
  	};

  	var xhrSuccessStatus = {

  			// File protocol always yields status code 0, assume 200
  			0: 200,

  			// Support: IE <=9 only
  			// trac-1450: sometimes IE returns 1223 when it should be 204
  			1223: 204
  		},
  		xhrSupported = jQuery.ajaxSettings.xhr();

  	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  	support.ajax = xhrSupported = !!xhrSupported;

  	jQuery.ajaxTransport( function( options ) {
  		var callback, errorCallback;

  		// Cross domain only allowed if supported through XMLHttpRequest
  		if ( support.cors || xhrSupported && !options.crossDomain ) {
  			return {
  				send: function( headers, complete ) {
  					var i,
  						xhr = options.xhr();

  					xhr.open(
  						options.type,
  						options.url,
  						options.async,
  						options.username,
  						options.password
  					);

  					// Apply custom fields if provided
  					if ( options.xhrFields ) {
  						for ( i in options.xhrFields ) {
  							xhr[ i ] = options.xhrFields[ i ];
  						}
  					}

  					// Override mime type if needed
  					if ( options.mimeType && xhr.overrideMimeType ) {
  						xhr.overrideMimeType( options.mimeType );
  					}

  					// X-Requested-With header
  					// For cross-domain requests, seeing as conditions for a preflight are
  					// akin to a jigsaw puzzle, we simply never set it to be sure.
  					// (it can always be set on a per-request basis or even using ajaxSetup)
  					// For same-domain requests, won't change header if already provided.
  					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  						headers[ "X-Requested-With" ] = "XMLHttpRequest";
  					}

  					// Set headers
  					for ( i in headers ) {
  						xhr.setRequestHeader( i, headers[ i ] );
  					}

  					// Callback
  					callback = function( type ) {
  						return function() {
  							if ( callback ) {
  								callback = errorCallback = xhr.onload =
  									xhr.onerror = xhr.onabort = xhr.ontimeout =
  										xhr.onreadystatechange = null;

  								if ( type === "abort" ) {
  									xhr.abort();
  								} else if ( type === "error" ) {

  									// Support: IE <=9 only
  									// On a manual native abort, IE9 throws
  									// errors on any property access that is not readyState
  									if ( typeof xhr.status !== "number" ) {
  										complete( 0, "error" );
  									} else {
  										complete(

  											// File: protocol always yields status 0; see trac-8605, trac-14207
  											xhr.status,
  											xhr.statusText
  										);
  									}
  								} else {
  									complete(
  										xhrSuccessStatus[ xhr.status ] || xhr.status,
  										xhr.statusText,

  										// Support: IE <=9 only
  										// IE9 has no XHR2 but throws on binary (trac-11426)
  										// For XHR2 non-text, let the caller handle it (gh-2498)
  										( xhr.responseType || "text" ) !== "text"  ||
  										typeof xhr.responseText !== "string" ?
  											{ binary: xhr.response } :
  											{ text: xhr.responseText },
  										xhr.getAllResponseHeaders()
  									);
  								}
  							}
  						};
  					};

  					// Listen to events
  					xhr.onload = callback();
  					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  					// Support: IE 9 only
  					// Use onreadystatechange to replace onabort
  					// to handle uncaught aborts
  					if ( xhr.onabort !== undefined ) {
  						xhr.onabort = errorCallback;
  					} else {
  						xhr.onreadystatechange = function() {

  							// Check readyState before timeout as it changes
  							if ( xhr.readyState === 4 ) {

  								// Allow onerror to be called first,
  								// but that will not handle a native abort
  								// Also, save errorCallback to a variable
  								// as xhr.onerror cannot be accessed
  								window.setTimeout( function() {
  									if ( callback ) {
  										errorCallback();
  									}
  								} );
  							}
  						};
  					}

  					// Create the abort callback
  					callback = callback( "abort" );

  					try {

  						// Do send the request (this may raise an exception)
  						xhr.send( options.hasContent && options.data || null );
  					} catch ( e ) {

  						// trac-14683: Only rethrow if this hasn't been notified as an error yet
  						if ( callback ) {
  							throw e;
  						}
  					}
  				},

  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  	jQuery.ajaxPrefilter( function( s ) {
  		if ( s.crossDomain ) {
  			s.contents.script = false;
  		}
  	} );

  	// Install script dataType
  	jQuery.ajaxSetup( {
  		accepts: {
  			script: "text/javascript, application/javascript, " +
  				"application/ecmascript, application/x-ecmascript"
  		},
  		contents: {
  			script: /\b(?:java|ecma)script\b/
  		},
  		converters: {
  			"text script": function( text ) {
  				jQuery.globalEval( text );
  				return text;
  			}
  		}
  	} );

  	// Handle cache's special case and crossDomain
  	jQuery.ajaxPrefilter( "script", function( s ) {
  		if ( s.cache === undefined ) {
  			s.cache = false;
  		}
  		if ( s.crossDomain ) {
  			s.type = "GET";
  		}
  	} );

  	// Bind script tag hack transport
  	jQuery.ajaxTransport( "script", function( s ) {

  		// This transport only deals with cross domain or forced-by-attrs requests
  		if ( s.crossDomain || s.scriptAttrs ) {
  			var script, callback;
  			return {
  				send: function( _, complete ) {
  					script = jQuery( "<script>" )
  						.attr( s.scriptAttrs || {} )
  						.prop( { charset: s.scriptCharset, src: s.url } )
  						.on( "load error", callback = function( evt ) {
  							script.remove();
  							callback = null;
  							if ( evt ) {
  								complete( evt.type === "error" ? 404 : 200, evt.type );
  							}
  						} );

  					// Use native DOM manipulation to avoid our domManip AJAX trickery
  					document.head.appendChild( script[ 0 ] );
  				},
  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	var oldCallbacks = [],
  		rjsonp = /(=)\?(?=&|$)|\?\?/;

  	// Default jsonp settings
  	jQuery.ajaxSetup( {
  		jsonp: "callback",
  		jsonpCallback: function() {
  			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
  			this[ callback ] = true;
  			return callback;
  		}
  	} );

  	// Detect, normalize options and install callbacks for jsonp requests
  	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  		var callbackName, overwritten, responseContainer,
  			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  				"url" :
  				typeof s.data === "string" &&
  					( s.contentType || "" )
  						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  					rjsonp.test( s.data ) && "data"
  			);

  		// Handle iff the expected data type is "jsonp" or we have a parameter to set
  		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  			// Get callback name, remembering preexisting value associated with it
  			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  				s.jsonpCallback() :
  				s.jsonpCallback;

  			// Insert callback into url or form data
  			if ( jsonProp ) {
  				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  			} else if ( s.jsonp !== false ) {
  				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  			}

  			// Use data converter to retrieve json after script execution
  			s.converters[ "script json" ] = function() {
  				if ( !responseContainer ) {
  					jQuery.error( callbackName + " was not called" );
  				}
  				return responseContainer[ 0 ];
  			};

  			// Force json dataType
  			s.dataTypes[ 0 ] = "json";

  			// Install callback
  			overwritten = window[ callbackName ];
  			window[ callbackName ] = function() {
  				responseContainer = arguments;
  			};

  			// Clean-up function (fires after converters)
  			jqXHR.always( function() {

  				// If previous value didn't exist - remove it
  				if ( overwritten === undefined ) {
  					jQuery( window ).removeProp( callbackName );

  				// Otherwise restore preexisting value
  				} else {
  					window[ callbackName ] = overwritten;
  				}

  				// Save back as free
  				if ( s[ callbackName ] ) {

  					// Make sure that re-using the options doesn't screw things around
  					s.jsonpCallback = originalSettings.jsonpCallback;

  					// Save the callback name for future use
  					oldCallbacks.push( callbackName );
  				}

  				// Call if it was a function and we have a response
  				if ( responseContainer && isFunction( overwritten ) ) {
  					overwritten( responseContainer[ 0 ] );
  				}

  				responseContainer = overwritten = undefined;
  			} );

  			// Delegate to script
  			return "script";
  		}
  	} );




  	// Support: Safari 8 only
  	// In Safari 8 documents created via document.implementation.createHTMLDocument
  	// collapse sibling forms: the second one becomes a child of the first one.
  	// Because of that, this security measure has to be disabled in Safari 8.
  	// https://bugs.webkit.org/show_bug.cgi?id=137337
  	support.createHTMLDocument = ( function() {
  		var body = document.implementation.createHTMLDocument( "" ).body;
  		body.innerHTML = "<form></form><form></form>";
  		return body.childNodes.length === 2;
  	} )();


  	// Argument "data" should be string of html
  	// context (optional): If specified, the fragment will be created in this context,
  	// defaults to document
  	// keepScripts (optional): If true, will include scripts passed in the html string
  	jQuery.parseHTML = function( data, context, keepScripts ) {
  		if ( typeof data !== "string" ) {
  			return [];
  		}
  		if ( typeof context === "boolean" ) {
  			keepScripts = context;
  			context = false;
  		}

  		var base, parsed, scripts;

  		if ( !context ) {

  			// Stop scripts or inline event handlers from being executed immediately
  			// by using document.implementation
  			if ( support.createHTMLDocument ) {
  				context = document.implementation.createHTMLDocument( "" );

  				// Set the base href for the created document
  				// so any parsed elements with URLs
  				// are based on the document's URL (gh-2965)
  				base = context.createElement( "base" );
  				base.href = document.location.href;
  				context.head.appendChild( base );
  			} else {
  				context = document;
  			}
  		}

  		parsed = rsingleTag.exec( data );
  		scripts = !keepScripts && [];

  		// Single tag
  		if ( parsed ) {
  			return [ context.createElement( parsed[ 1 ] ) ];
  		}

  		parsed = buildFragment( [ data ], context, scripts );

  		if ( scripts && scripts.length ) {
  			jQuery( scripts ).remove();
  		}

  		return jQuery.merge( [], parsed.childNodes );
  	};


  	/**
  	 * Load a url into a page
  	 */
  	jQuery.fn.load = function( url, params, callback ) {
  		var selector, type, response,
  			self = this,
  			off = url.indexOf( " " );

  		if ( off > -1 ) {
  			selector = stripAndCollapse( url.slice( off ) );
  			url = url.slice( 0, off );
  		}

  		// If it's a function
  		if ( isFunction( params ) ) {

  			// We assume that it's the callback
  			callback = params;
  			params = undefined;

  		// Otherwise, build a param string
  		} else if ( params && typeof params === "object" ) {
  			type = "POST";
  		}

  		// If we have elements to modify, make the request
  		if ( self.length > 0 ) {
  			jQuery.ajax( {
  				url: url,

  				// If "type" variable is undefined, then "GET" method will be used.
  				// Make value of this field explicit since
  				// user can override it through ajaxSetup method
  				type: type || "GET",
  				dataType: "html",
  				data: params
  			} ).done( function( responseText ) {

  				// Save response for use in complete callback
  				response = arguments;

  				self.html( selector ?

  					// If a selector was specified, locate the right elements in a dummy div
  					// Exclude scripts to avoid IE 'Permission Denied' errors
  					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  					// Otherwise use the full result
  					responseText );

  			// If the request succeeds, this function gets "data", "status", "jqXHR"
  			// but they are ignored because response was set above.
  			// If it fails, this function gets "jqXHR", "status", "error"
  			} ).always( callback && function( jqXHR, status ) {
  				self.each( function() {
  					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  				} );
  			} );
  		}

  		return this;
  	};




  	jQuery.expr.pseudos.animated = function( elem ) {
  		return jQuery.grep( jQuery.timers, function( fn ) {
  			return elem === fn.elem;
  		} ).length;
  	};




  	jQuery.offset = {
  		setOffset: function( elem, options, i ) {
  			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  				position = jQuery.css( elem, "position" ),
  				curElem = jQuery( elem ),
  				props = {};

  			// Set position first, in-case top/left are set even on static elem
  			if ( position === "static" ) {
  				elem.style.position = "relative";
  			}

  			curOffset = curElem.offset();
  			curCSSTop = jQuery.css( elem, "top" );
  			curCSSLeft = jQuery.css( elem, "left" );
  			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  			// Need to be able to calculate position if either
  			// top or left is auto and position is either absolute or fixed
  			if ( calculatePosition ) {
  				curPosition = curElem.position();
  				curTop = curPosition.top;
  				curLeft = curPosition.left;

  			} else {
  				curTop = parseFloat( curCSSTop ) || 0;
  				curLeft = parseFloat( curCSSLeft ) || 0;
  			}

  			if ( isFunction( options ) ) {

  				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  			}

  			if ( options.top != null ) {
  				props.top = ( options.top - curOffset.top ) + curTop;
  			}
  			if ( options.left != null ) {
  				props.left = ( options.left - curOffset.left ) + curLeft;
  			}

  			if ( "using" in options ) {
  				options.using.call( elem, props );

  			} else {
  				curElem.css( props );
  			}
  		}
  	};

  	jQuery.fn.extend( {

  		// offset() relates an element's border box to the document origin
  		offset: function( options ) {

  			// Preserve chaining for setter
  			if ( arguments.length ) {
  				return options === undefined ?
  					this :
  					this.each( function( i ) {
  						jQuery.offset.setOffset( this, options, i );
  					} );
  			}

  			var rect, win,
  				elem = this[ 0 ];

  			if ( !elem ) {
  				return;
  			}

  			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  			// Support: IE <=11 only
  			// Running getBoundingClientRect on a
  			// disconnected node in IE throws an error
  			if ( !elem.getClientRects().length ) {
  				return { top: 0, left: 0 };
  			}

  			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  			rect = elem.getBoundingClientRect();
  			win = elem.ownerDocument.defaultView;
  			return {
  				top: rect.top + win.pageYOffset,
  				left: rect.left + win.pageXOffset
  			};
  		},

  		// position() relates an element's margin box to its offset parent's padding box
  		// This corresponds to the behavior of CSS absolute positioning
  		position: function() {
  			if ( !this[ 0 ] ) {
  				return;
  			}

  			var offsetParent, offset, doc,
  				elem = this[ 0 ],
  				parentOffset = { top: 0, left: 0 };

  			// position:fixed elements are offset from the viewport, which itself always has zero offset
  			if ( jQuery.css( elem, "position" ) === "fixed" ) {

  				// Assume position:fixed implies availability of getBoundingClientRect
  				offset = elem.getBoundingClientRect();

  			} else {
  				offset = this.offset();

  				// Account for the *real* offset parent, which can be the document or its root element
  				// when a statically positioned element is identified
  				doc = elem.ownerDocument;
  				offsetParent = elem.offsetParent || doc.documentElement;
  				while ( offsetParent &&
  					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  					jQuery.css( offsetParent, "position" ) === "static" ) {

  					offsetParent = offsetParent.parentNode;
  				}
  				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  					// Incorporate borders into its offset, since they are outside its content origin
  					parentOffset = jQuery( offsetParent ).offset();
  					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  				}
  			}

  			// Subtract parent offsets and element margins
  			return {
  				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  			};
  		},

  		// This method will return documentElement in the following cases:
  		// 1) For the element inside the iframe without offsetParent, this method will return
  		//    documentElement of the parent window
  		// 2) For the hidden or detached element
  		// 3) For body or html element, i.e. in case of the html node - it will return itself
  		//
  		// but those exceptions were never presented as a real life use-cases
  		// and might be considered as more preferable results.
  		//
  		// This logic, however, is not guaranteed and can change at any point in the future
  		offsetParent: function() {
  			return this.map( function() {
  				var offsetParent = this.offsetParent;

  				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  					offsetParent = offsetParent.offsetParent;
  				}

  				return offsetParent || documentElement;
  			} );
  		}
  	} );

  	// Create scrollLeft and scrollTop methods
  	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  		var top = "pageYOffset" === prop;

  		jQuery.fn[ method ] = function( val ) {
  			return access( this, function( elem, method, val ) {

  				// Coalesce documents and windows
  				var win;
  				if ( isWindow( elem ) ) {
  					win = elem;
  				} else if ( elem.nodeType === 9 ) {
  					win = elem.defaultView;
  				}

  				if ( val === undefined ) {
  					return win ? win[ prop ] : elem[ method ];
  				}

  				if ( win ) {
  					win.scrollTo(
  						!top ? val : win.pageXOffset,
  						top ? val : win.pageYOffset
  					);

  				} else {
  					elem[ method ] = val;
  				}
  			}, method, val, arguments.length );
  		};
  	} );

  	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
  	// Add the top/left cssHooks using jQuery.fn.position
  	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  	// getComputedStyle returns percent when specified for top/left/bottom/right;
  	// rather than make the css module depend on the offset module, just check for it here
  	jQuery.each( [ "top", "left" ], function( _i, prop ) {
  		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  			function( elem, computed ) {
  				if ( computed ) {
  					computed = curCSS( elem, prop );

  					// If curCSS returns percentage, fallback to offset
  					return rnumnonpx.test( computed ) ?
  						jQuery( elem ).position()[ prop ] + "px" :
  						computed;
  				}
  			}
  		);
  	} );


  	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  		jQuery.each( {
  			padding: "inner" + name,
  			content: type,
  			"": "outer" + name
  		}, function( defaultExtra, funcName ) {

  			// Margin is only for outerHeight, outerWidth
  			jQuery.fn[ funcName ] = function( margin, value ) {
  				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  				return access( this, function( elem, type, value ) {
  					var doc;

  					if ( isWindow( elem ) ) {

  						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  						return funcName.indexOf( "outer" ) === 0 ?
  							elem[ "inner" + name ] :
  							elem.document.documentElement[ "client" + name ];
  					}

  					// Get document width or height
  					if ( elem.nodeType === 9 ) {
  						doc = elem.documentElement;

  						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  						// whichever is greatest
  						return Math.max(
  							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  							elem.body[ "offset" + name ], doc[ "offset" + name ],
  							doc[ "client" + name ]
  						);
  					}

  					return value === undefined ?

  						// Get width or height on the element, requesting but not forcing parseFloat
  						jQuery.css( elem, type, extra ) :

  						// Set width or height on the element
  						jQuery.style( elem, type, value, extra );
  				}, type, chainable ? margin : undefined, chainable );
  			};
  		} );
  	} );


  	jQuery.each( [
  		"ajaxStart",
  		"ajaxStop",
  		"ajaxComplete",
  		"ajaxError",
  		"ajaxSuccess",
  		"ajaxSend"
  	], function( _i, type ) {
  		jQuery.fn[ type ] = function( fn ) {
  			return this.on( type, fn );
  		};
  	} );




  	jQuery.fn.extend( {

  		bind: function( types, data, fn ) {
  			return this.on( types, null, data, fn );
  		},
  		unbind: function( types, fn ) {
  			return this.off( types, null, fn );
  		},

  		delegate: function( selector, types, data, fn ) {
  			return this.on( types, selector, data, fn );
  		},
  		undelegate: function( selector, types, fn ) {

  			// ( namespace ) or ( selector, types [, fn] )
  			return arguments.length === 1 ?
  				this.off( selector, "**" ) :
  				this.off( types, selector || "**", fn );
  		},

  		hover: function( fnOver, fnOut ) {
  			return this
  				.on( "mouseenter", fnOver )
  				.on( "mouseleave", fnOut || fnOver );
  		}
  	} );

  	jQuery.each(
  		( "blur focus focusin focusout resize scroll click dblclick " +
  		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  		function( _i, name ) {

  			// Handle event binding
  			jQuery.fn[ name ] = function( data, fn ) {
  				return arguments.length > 0 ?
  					this.on( name, null, data, fn ) :
  					this.trigger( name );
  			};
  		}
  	);




  	// Support: Android <=4.0 only
  	// Make sure we trim BOM and NBSP
  	// Require that the "whitespace run" starts from a non-whitespace
  	// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
  	var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

  	// Bind a function to a context, optionally partially applying any
  	// arguments.
  	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  	// However, it is not slated for removal any time soon
  	jQuery.proxy = function( fn, context ) {
  		var tmp, args, proxy;

  		if ( typeof context === "string" ) {
  			tmp = fn[ context ];
  			context = fn;
  			fn = tmp;
  		}

  		// Quick check to determine if target is callable, in the spec
  		// this throws a TypeError, but we will just return undefined.
  		if ( !isFunction( fn ) ) {
  			return undefined;
  		}

  		// Simulated bind
  		args = slice.call( arguments, 2 );
  		proxy = function() {
  			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  		};

  		// Set the guid of unique handler to the same of original handler, so it can be removed
  		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  		return proxy;
  	};

  	jQuery.holdReady = function( hold ) {
  		if ( hold ) {
  			jQuery.readyWait++;
  		} else {
  			jQuery.ready( true );
  		}
  	};
  	jQuery.isArray = Array.isArray;
  	jQuery.parseJSON = JSON.parse;
  	jQuery.nodeName = nodeName;
  	jQuery.isFunction = isFunction;
  	jQuery.isWindow = isWindow;
  	jQuery.camelCase = camelCase;
  	jQuery.type = toType;

  	jQuery.now = Date.now;

  	jQuery.isNumeric = function( obj ) {

  		// As of jQuery 3.0, isNumeric is limited to
  		// strings and numbers (primitives or objects)
  		// that can be coerced to finite numbers (gh-2662)
  		var type = jQuery.type( obj );
  		return ( type === "number" || type === "string" ) &&

  			// parseFloat NaNs numeric-cast false positives ("")
  			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  			// subtraction forces infinities to NaN
  			!isNaN( obj - parseFloat( obj ) );
  	};

  	jQuery.trim = function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "$1" );
  	};




  	var

  		// Map over jQuery in case of overwrite
  		_jQuery = window.jQuery,

  		// Map over the $ in case of overwrite
  		_$ = window.$;

  	jQuery.noConflict = function( deep ) {
  		if ( window.$ === jQuery ) {
  			window.$ = _$;
  		}

  		if ( deep && window.jQuery === jQuery ) {
  			window.jQuery = _jQuery;
  		}

  		return jQuery;
  	};

  	// Expose jQuery and $ identifiers, even in AMD
  	// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  	// and CommonJS for browser emulators (trac-13566)
  	if ( typeof noGlobal === "undefined" ) {
  		window.jQuery = window.$ = jQuery;
  	}




  	return jQuery;
  	} ); 
  } (jquery));

  var jqueryExports = jquery.exports;
  var $$1 = /*@__PURE__*/getDefaultExportFromCjs(jqueryExports);

  /*
   * utility
   * 
   */
  var Utility = /*#__PURE__*/function () {
    function Utility() {
      _classCallCheck(this, Utility);
    }
    return _createClass$1(Utility, null, [{
      key: "isSP",
      value: function isSP() {
        return window.matchMedia('screen and (min-width: 320px) and (max-width: 749px)').matches;
      }
    }, {
      key: "isTAB",
      value: function isTAB() {
        return window.matchMedia('screen and (min-width: 750px) and (max-width: 1023px)').matches;
      }
    }, {
      key: "isPC",
      value: function isPC() {
        return window.matchMedia('screen and (min-width: 1024px)').matches;
      }
    }, {
      key: "convertSpiltSpan",
      value: function convertSpiltSpan(selector) {
        // vars
        var target = convertElement(selector);
        var nodes = _toConsumableArray(target.childNodes);
        var spanWrapText = "";

        // functions
        nodes.forEach(function (node) {
          if (node.nodeType == 3) {
            //
            var text = node.textContent.replace(/\r?\n/g, '');
            spanWrapText = spanWrapText + text.split('').reduce(function (acc, v) {
              v = v != ' ' ? v : '&nbsp';
              return acc + "<span>".concat(v, "</span>");
            }, "");
          } else {
            spanWrapText = spanWrapText + node.outerHTML;
          }
        });
        target.innerHTML = spanWrapText;
        function convertElement(element) {
          if (element instanceof HTMLElement) {
            return element;
          }
          return document.querySelector(element);
        }
      }
    }]);
  }();

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  /*!
   * GSAP 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var _config$1 = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  },
      _defaults$1 = {
    duration: .5,
    overwrite: false,
    delay: 0
  },
      _suppressOverwrites$1,
      _reverting$1,
      _context$2,
      _bigNum$1 = 1e8,
      _tinyNum = 1 / _bigNum$1,
      _2PI = Math.PI * 2,
      _HALF_PI = _2PI / 4,
      _gsID = 0,
      _sqrt = Math.sqrt,
      _cos = Math.cos,
      _sin = Math.sin,
      _isString$2 = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction$2 = function _isFunction(value) {
    return typeof value === "function";
  },
      _isNumber$1 = function _isNumber(value) {
    return typeof value === "number";
  },
      _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
      _isObject$1 = function _isObject(value) {
    return typeof value === "object";
  },
      _isNotFalse = function _isNotFalse(value) {
    return value !== false;
  },
      _windowExists$3 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _isFuncOrString = function _isFuncOrString(value) {
    return _isFunction$2(value) || _isString$2(value);
  },
      _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
      // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
  _isArray = Array.isArray,
      _randomExp = /random\([^)]+\)/g,
      _commaDelimExp = /,\s*/g,
      _strictNumExp = /(?:-?\.?\d|\.)+/gi,
      //only numbers (including negatives and decimals) but NOT relative values.
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
      //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
      //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
  _relExp = /[+-]=-?[.\d]+/,
      _delimitedValueExp = /[^,'"\[\]\s]+/gi,
      // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
  _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
      _globalTimeline,
      _win$3,
      _coreInitted$3,
      _doc$3,
      _globals = {},
      _installScope = {},
      _coreReady,
      _install = function _install(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap$3;
  },
      _missingPlugin = function _missingPlugin(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  },
      _warn = function _warn(message, suppress) {
    return !suppress && console.warn(message);
  },
      _addGlobal = function _addGlobal(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  },
      _emptyFunc = function _emptyFunc() {
    return 0;
  },
      _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  },
      _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  },
      _revertConfig = {
    suppressEvents: true
  },
      _reservedProps = {},
      _lazyTweens = [],
      _lazyLookup = {},
      _lastRenderedFrame,
      _plugins = {},
      _effects = {},
      _nextGCFrame = 30,
      _harnessPlugins = [],
      _callbackNames = "",
      _harness = function _harness(targets) {
    var target = targets[0],
        harnessPlugin,
        i;
    _isObject$1(target) || _isFunction$2(target) || (targets = [targets]);

    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
      i = _harnessPlugins.length;

      while (i-- && !_harnessPlugins[i].targetTest(target)) {}

      harnessPlugin = _harnessPlugins[i];
    }

    i = targets.length;

    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }

    return targets;
  },
      _getCache = function _getCache(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  },
      _getProperty = function _getProperty(target, property, v) {
    return (v = target[property]) && _isFunction$2(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  },
      _forEachName = function _forEachName(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  },
      //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
  _round$1 = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
      _roundPrecise = function _roundPrecise(value) {
    return Math.round(value * 10000000) / 10000000 || 0;
  },
      // increased precision mostly for timing values.
  _parseRelative = function _parseRelative(start, value) {
    var operator = value.charAt(0),
        end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  },
      _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
    var l = toFind.length,
        i = 0;

    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

    return i < l;
  },
      _lazyRender = function _lazyRender() {
    var l = _lazyTweens.length,
        a = _lazyTweens.slice(0),
        i,
        tween;

    _lazyLookup = {};
    _lazyTweens.length = 0;

    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  },
      _isRevertWorthy = function _isRevertWorthy(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  },
      _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting$1 && _lazyRender();
    animation.render(time, suppressEvents, force || !!(_reverting$1 && time < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting$1 && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
  },
      _numericIfPossible = function _numericIfPossible(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString$2(value) ? value.trim() : value;
  },
      _passThrough$1 = function _passThrough(p) {
    return p;
  },
      _setDefaults$1 = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }

    return obj;
  },
      _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
    return function (obj, defaults) {
      for (var p in defaults) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
      }
    };
  },
      _merge = function _merge(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }

    return base;
  },
      _mergeDeep = function _mergeDeep(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject$1(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }

    return base;
  },
      _copyExcluding = function _copyExcluding(obj, excluding) {
    var copy = {},
        p;

    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }

    return copy;
  },
      _inheritDefaults = function _inheritDefaults(vars) {
    var parent = vars.parent || _globalTimeline,
        func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults$1;

    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }

    return vars;
  },
      _arraysMatch = function _arraysMatch(a1, a2) {
    var i = a1.length,
        match = i === a2.length;

    while (match && i-- && a1[i] === a2[i]) {}

    return i < 0;
  },
      _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = parent[lastProp],
        t;

    if (sortBy) {
      t = child[sortBy];

      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }

    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }

    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  },
      _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = child._prev,
        next = child._next;

    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }

    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }

    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
  },
      _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  },
      _uncache = function _uncache(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
      var a = animation;

      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }

    return animation;
  },
      _recacheAncestors = function _recacheAncestors(animation) {
    var parent = animation.parent;

    while (parent && parent.parent) {
      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }

    return animation;
  },
      _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  },
      _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
  },
      _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  },
      // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
  _animationCycle = function _animationCycle(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  },
      _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  },
      _setEnd = function _setEnd(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  },
      _alignPlayhead = function _alignPlayhead(animation, totalTime) {
    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
    var parent = animation._dp;

    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

      _setEnd(animation);

      parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
    }

    return animation;
  },

  /*
  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
  	let cycleDuration = duration + repeatDelay,
  		time = _round(clampedTotalTime % cycleDuration);
  	if (time > duration) {
  		time = duration;
  	}
  	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
  },
  */
  _postAddChecks = function _postAddChecks(timeline, child) {
    var t;

    if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
      // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).
      t = _parentToChildTotalTime(timeline.rawTime(), child);

      if (!child._dur || _clamp$1(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
      //in case any of the ancestors had completed but should now be enabled...
      if (timeline._dur < timeline.duration()) {
        t = timeline;

        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

          t = t._dp;
        }
      }

      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
    }
  },
      _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber$1(position) ? position : position || timeline !== _globalTimeline ? _parsePosition$1(timeline, position, child) : timeline._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

    _isFromOrFromStart(child) || (timeline._recent = child);
    skipChecks || _postAddChecks(timeline, child);
    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

    return timeline;
  },
      _scrollTrigger = function _scrollTrigger(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  },
      _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);

    if (!tween._initted) {
      return 1;
    }

    if (!force && tween._pt && !_reverting$1 && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);

      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  },
      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
  },
      // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
  _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  },
      _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio,
        ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
        // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
    repeatDelay = tween._rDelay,
        tTime = 0,
        pt,
        iteration,
        prevIteration;

    if (repeatDelay && tween._repeat) {
      // in case there's a zero-duration tween that has a repeat with a repeatDelay
      tTime = _clamp$1(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        // if iteration changed
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }

    if (ratio !== prevRatio || _reverting$1 || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        return;
      }

      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback$1(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback$1(tween, "onRepeat");

      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);

        if (!suppressEvents && !_reverting$1) {
          _callback$1(tween, ratio ? "onComplete" : "onReverseComplete", true);

          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  },
      _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
    var child;

    if (time > prevTime) {
      child = animation._first;

      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }

        child = child._next;
      }
    } else {
      child = animation._last;

      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }

        child = child._prev;
      }
    }
  },
      _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat,
        dur = _roundPrecise(duration) || 0,
        totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  },
      _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  },
      _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  },
      _parsePosition$1 = function _parsePosition(animation, position, percentAnimation) {
    var labels = animation.labels,
        recent = animation._recent || _zeroPosition,
        clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur,
        //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
    i,
        offset,
        isPercent;

    if (_isString$2(position) && (isNaN(position) || position in labels)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");

      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }

      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }

      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }

      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }

    return position == null ? clippedDuration : +position;
  },
      _createTweenType = function _createTweenType(type, params, timeline) {
    var isLegacy = _isNumber$1(params[1]),
        varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
        vars = params[varsIndex],
        irVars,
        parent;

    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline;

    if (type) {
      irVars = vars;
      parent = timeline;

      while (parent && !("immediateRender" in irVars)) {
        // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }

      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
    }

    return new Tween(params[0], vars, params[varsIndex + 1]);
  },
      _conditionalReturn = function _conditionalReturn(value, func) {
    return value || value === 0 ? func(value) : func;
  },
      _clamp$1 = function _clamp(min, max, value) {
    return value < min ? min : value > max ? max : value;
  },
      getUnit = function getUnit(value, v) {
    return !_isString$2(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  },
      // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
  clamp = function clamp(min, max, value) {
    return _conditionalReturn(value, function (v) {
      return _clamp$1(min, max, v);
    });
  },
      _slice = [].slice,
      _isArrayLike = function _isArrayLike(value, nonEmpty) {
    return value && _isObject$1(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject$1(value[0])) && !value.nodeType && value !== _win$3;
  },
      _flatten = function _flatten(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }

    return ar.forEach(function (value) {
      var _accumulator;

      return _isString$2(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  },
      // takes any value and returns an Array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  toArray = function toArray(value, scope, leaveStrings) {
    return _context$2 && !scope && _context$2.selector ? _context$2.selector(value) : _isString$2(value) && !leaveStrings && (_coreInitted$3 || !_wake()) ? _slice.call((scope || _doc$3).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  },
      selector = function selector(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function (v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$3.createElement("div") : value);
    };
  },
      shuffle = function shuffle(a) {
    return a.sort(function () {
      return .5 - Math.random();
    });
  },
      // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;
  // for distributing values across an Array. Can accept a number, a function or (most commonly) an object which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array.
  distribute = function distribute(v) {
    if (_isFunction$2(v)) {
      return v;
    }

    var vars = _isObject$1(v) ? v : {
      each: v
    },
        //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
    ease = _parseEase(vars.ease),
        from = vars.from || 0,
        base = parseFloat(vars.base) || 0,
        cache = {},
        isDecimal = from > 0 && from < 1,
        ratios = isNaN(from) || isDecimal,
        axis = vars.axis,
        ratioX = from,
        ratioY = from;

    if (_isString$2(from)) {
      ratioX = ratioY = {
        center: .5,
        edges: .5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }

    return function (i, target, a) {
      var l = (a || vars).length,
          distances = cache[l],
          originX,
          originY,
          x,
          y,
          d,
          j,
          max,
          min,
          wrapAt;

      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];

        if (!wrapAt) {
          max = -_bigNum$1;

          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

          wrapAt < l && wrapAt--;
        }

        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
        originY = wrapAt === _bigNum$1 ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum$1;

        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }

        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0; //unit

        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }

      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
    };
  },
      _roundModifier = function _roundModifier(v) {
    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

    return function (raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);

      return (n - n % 1) / p + (_isNumber$1(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
    };
  },
      snap = function snap(snapTo, value) {
    var isArray = _isArray(snapTo),
        radius,
        is2D;

    if (!isArray && _isObject$1(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum$1;

      if (snapTo.values) {
        snapTo = toArray(snapTo.values);

        if (is2D = !_isNumber$1(snapTo[0])) {
          radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }

    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction$2(snapTo) ? function (raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function (raw) {
      var x = parseFloat(is2D ? raw.x : raw),
          y = parseFloat(is2D ? raw.y : 0),
          min = _bigNum$1,
          closest = 0,
          i = snapTo.length,
          dx,
          dy;

      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }

        if (dx < min) {
          min = dx;
          closest = i;
        }
      }

      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber$1(raw) ? closest : closest + getUnit(raw);
    });
  },
      random = function random(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  },
      pipe = function pipe() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }

    return function (value) {
      return functions.reduce(function (v, f) {
        return f(v);
      }, value);
    };
  },
      unitize = function unitize(func, unit) {
    return function (value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  },
      normalize = function normalize(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  },
      _wrapArray = function _wrapArray(a, wrapper, value) {
    return _conditionalReturn(value, function (index) {
      return a[~~wrapper(index)];
    });
  },
      wrap = function wrap(min, max, value) {
    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
      return (range + (value - min) % range) % range + min;
    });
  },
      wrapYoyo = function wrapYoyo(min, max, value) {
    var range = max - min,
        total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
      value = (total + (value - min) % total) % total || 0;
      return min + (value > range ? total - value : value);
    });
  },
      _replaceRandom = function _replaceRandom(s) {
    return s.replace(_randomExp, function (match) {
      //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
      var arIndex = match.indexOf("[") + 1,
          values = match.substring(arIndex || 7, arIndex ? match.indexOf("]") : match.length - 1).split(_commaDelimExp);
      return random(arIndex ? values : +values[0], arIndex ? 0 : +values[1], +values[2] || 1e-5);
    });
  },
      mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin,
        outRange = outMax - outMin;
    return _conditionalReturn(value, function (value) {
      return outMin + ((value - inMin) / inRange * outRange || 0);
    });
  },
      interpolate = function interpolate(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function (p) {
      return (1 - p) * start + p * end;
    };

    if (!func) {
      var isString = _isString$2(start),
          master = {},
          p,
          i,
          interpolators,
          l,
          il;

      progress === true && (mutate = 1) && (progress = null);

      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;

        for (i = 1; i < l; i++) {
          interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
        }

        l--;

        func = function func(p) {
          p *= l;
          var i = Math.min(il, ~~p);
          return interpolators[i](p - i);
        };

        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }

      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }

        func = function func(p) {
          return _renderPropTweens(p, master) || (isString ? start.p : start);
        };
      }
    }

    return _conditionalReturn(progress, func);
  },
      _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
    //used for nextLabel() and previousLabel()
    var labels = timeline.labels,
        min = _bigNum$1,
        p,
        distance,
        label;

    for (p in labels) {
      distance = labels[p] - fromTime;

      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }

    return label;
  },
      _callback$1 = function _callback(animation, type, executeLazyFirst) {
    var v = animation.vars,
        callback = v[type],
        prevContext = _context$2,
        context = animation._ctx,
        params,
        scope,
        result;

    if (!callback) {
      return;
    }

    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

    context && (_context$2 = context);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context$2 = prevContext;
    return result;
  },
      _interrupt = function _interrupt(animation) {
    _removeFromParent(animation);

    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting$1);
    animation.progress() < 1 && _callback$1(animation, "onInterrupt");
    return animation;
  },
      _quickTween,
      _registerPluginQueue = [],
      _createPlugin = function _createPlugin(config) {
    if (!config) return;
    config = !config.name && config["default"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

    if (_windowExists$3() || config.headless) {
      // edge case: some build tools may pass in a null/undefined value
      var name = config.name,
          isFunc = _isFunction$2(config),
          Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
          //in case someone passes in an object that's not a plugin, like CustomEase
      instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
          statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };

      _wake();

      if (config !== Plugin) {
        if (_plugins[name]) {
          return;
        }

        _setDefaults$1(Plugin, _setDefaults$1(_copyExcluding(config, instanceDefaults), statics)); //static methods


        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


        _plugins[Plugin.prop = name] = Plugin;

        if (config.targetTest) {
          _harnessPlugins.push(Plugin);

          _reservedProps[name] = 1;
        }

        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
      }

      _addGlobal(name, Plugin);

      config.register && config.register(gsap$3, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config);
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * COLORS
   * --------------------------------------------------------------------------------------
   */
  _255 = 255,
      _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  },
      // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
  // let ctx = _doc.createElement("canvas").getContext("2d");
  // _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
  _hue = function _hue(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
  },
      splitColor = function splitColor(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber$1(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
        r,
        g,
        b,
        h,
        s,
        l,
        max,
        min,
        d,
        wasHSL;

    if (!a) {
      if (v.substr(-1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }

      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          //for shorthand like #9F0 or #9F0F (could have alpha)
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }

        if (v.length === 9) {
          // hex with alpha, like #fd5e53ff
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }

        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);

        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= .5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1); //cast as number

          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }

      a = a.map(Number);
    }

    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }

      a[0] = ~~(h + .5);
      a[1] = ~~(s * 100 + .5);
      a[2] = ~~(l * 100 + .5);
    }

    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  },
      _colorOrderData = function _colorOrderData(v) {
    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
    var values = [],
        c = [],
        i = -1;
    v.split(_colorExp).forEach(function (v) {
      var a = v.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  },
      _formatColors = function _formatColors(s, toHSL, orderMatchData) {
    var result = "",
        colors = (s + result).match(_colorExp),
        type = toHSL ? "hsla(" : "rgba(",
        i = 0,
        c,
        shell,
        d,
        l;

    if (!colors) {
      return s;
    }

    colors = colors.map(function (color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });

    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;

      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;

        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }

    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }

    return result + shell[l];
  },
      _colorExp = function () {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
        //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
    p;

    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }

    return new RegExp(s + ")", "gi");
  }(),
      _hslExp = /hsl[a]?\(/,
      _colorStringFilter = function _colorStringFilter(a) {
    var combined = a.join(" "),
        toHSL;
    _colorExp.lastIndex = 0;

    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

      return true;
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * TICKER
   * --------------------------------------------------------------------------------------
   */
  _tickerActive,
      _ticker = function () {
    var _getTime = Date.now,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _startTime = _getTime(),
        _lastUpdate = _startTime,
        _gap = 1000 / 240,
        _nextTime = _gap,
        _listeners = [],
        _id,
        _req,
        _raf,
        _self,
        _delta,
        _i,
        _tick = function _tick(v) {
      var elapsed = _getTime() - _lastUpdate,
          manual = v === true,
          overlap,
          dispatch,
          time,
          frame;

      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;

      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1000;
        _self.time = time = time / 1000;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }

      manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

      if (dispatch) {
        for (_i = 0; _i < _listeners.length; _i++) {
          // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
          _listeners[_i](time, _delta, frame, v);
        }
      }
    };

    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1000 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted$3 && _windowExists$3()) {
            _win$3 = _coreInitted$3 = window;
            _doc$3 = _win$3.document || {};
            _globals.gsap = gsap$3;
            (_win$3.gsapVersions || (_win$3.gsapVersions = [])).push(gsap$3.version);

            _install(_installScope || _win$3.GreenSockGlobals || !_win$3.gsap && _win$3 || {});

            _registerPluginQueue.forEach(_createPlugin);
          }

          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();

          _req = _raf || function (f) {
            return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
          };

          _tickerActive = 1;

          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited

        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1000 / (_fps || 240);
        _nextTime = _self.time * 1000 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function (t, d, f, v) {
          callback(t, d, f, v);

          _self.remove(func);
        } : callback;

        _self.remove(callback);

        _listeners[prioritize ? "unshift" : "push"](func);

        _wake();

        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
      },
      _listeners: _listeners
    };
    return _self;
  }(),
      _wake = function _wake() {
    return !_tickerActive && _ticker.wake();
  },
      //also ensures the core classes are initialized.

  /*
  * -------------------------------------------------
  * EASING
  * -------------------------------------------------
  */
  _easeMap = {},
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
      _quotesExp = /["']/g,
      _parseObjectInString = function _parseObjectInString(value) {
    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
    var obj = {},
        split = value.substr(1, value.length - 3).split(":"),
        key = split[0],
        i = 1,
        l = split.length,
        index,
        val,
        parsedVal;

    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }

    return obj;
  },
      _valueInParentheses = function _valueInParentheses(value) {
    var open = value.indexOf("(") + 1,
        close = value.indexOf(")"),
        nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  },
      _configEaseFromString = function _configEaseFromString(name) {
    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
    var split = (name + "").split("("),
        ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  },
      _invertEase = function _invertEase(ease) {
    return function (p) {
      return 1 - ease(1 - p);
    };
  },
      // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
  _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
    var child = timeline._first,
        ease;

    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }

      child = child._next;
    }
  },
      _parseEase = function _parseEase(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction$2(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  },
      _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut(p) {
        return 1 - easeIn(1 - p);
      };
    }

    if (easeInOut === void 0) {
      easeInOut = function easeInOut(p) {
        return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }

    var ease = {
      easeIn: easeIn,
      easeOut: easeOut,
      easeInOut: easeInOut
    },
        lowercaseName;

    _forEachName(names, function (name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });

    return ease;
  },
      _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
    return function (p) {
      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
    };
  },
      _configElastic = function _configElastic(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1,
        //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
        p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
        easeOut = function easeOut(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    p2 = _2PI / p2; //precalculate to optimize

    ease.config = function (amplitude, period) {
      return _configElastic(type, amplitude, period);
    };

    return ease;
  },
      _configBack = function _configBack(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }

    var easeOut = function easeOut(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    ease.config = function (overshoot) {
      return _configBack(type, overshoot);
    };

    return ease;
  }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEase = ratio => {
  // 	let y = 0.5 + ratio / 2;
  // 	return p => (2 * (1 - p) * p * y + p * p);
  // },
  // a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEaseStrong = ratio => {
  // 	ratio = .5 + ratio / 2;
  // 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
  // 		b = ratio - o,
  // 		c = ratio + o;
  // 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
  // };


  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
    var power = i < 5 ? i + 1 : i;

    _insertEase(name + ",Power" + (power - 1), i ? function (p) {
      return Math.pow(p, power);
    } : function (p) {
      return p;
    }, function (p) {
      return 1 - Math.pow(1 - p, power);
    }, function (p) {
      return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });

  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

  (function (n, c) {
    var n1 = 1 / c,
        n2 = 2 * n1,
        n3 = 2.5 * n1,
        easeOut = function easeOut(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
    };

    _insertEase("Bounce", function (p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);

  _insertEase("Expo", function (p) {
    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
  }); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.


  _insertEase("Circ", function (p) {
    return -(_sqrt(1 - p * p) - 1);
  });

  _insertEase("Sine", function (p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });

  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }

      var p1 = 1 / steps,
          p2 = steps + (immediateStart ? 0 : 1),
          p3 = immediateStart ? 1 : 0,
          max = 1 - _tinyNum;
      return function (p) {
        return ((p2 * _clamp$1(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults$1.ease = _easeMap["quad.out"];

  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  /*
   * --------------------------------------------------------------------------------------
   * CACHE
   * --------------------------------------------------------------------------------------
   */


  var GSCache = function GSCache(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  /*
   * --------------------------------------------------------------------------------------
   * ANIMATION
   * --------------------------------------------------------------------------------------
   */

  var Animation = /*#__PURE__*/function () {
    function Animation(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;

      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }

      this._ts = 1;

      _setDuration(this, +vars.duration, 1, 1);

      this.data = vars.data;

      if (_context$2) {
        this._ctx = _context$2;

        _context$2.data.push(this);
      }

      _tickerActive || _ticker.wake();
    }

    var _proto = Animation.prototype;

    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }

      return this._delay;
    };

    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };

    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }

      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };

    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();

      if (!arguments.length) {
        return this._tTime;
      }

      var parent = this._dp;

      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);

        !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }

          parent = parent.parent;
        }

        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }

      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !this._initted && this._dur && _totalTime || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
        this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
        //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
        //   this._lock = 1;

        _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
        //}

      }

      return this;
    };

    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
    };

    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };

    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };

    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;

      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    } // potential future addition:
    // isPlayingBackwards() {
    // 	let animation = this,
    // 		orientation = 1; // 1 = forward, -1 = backward
    // 	while (animation) {
    // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
    // 		animation = animation.parent;
    // 	}
    // 	return orientation < 0;
    // }
    ;

    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
      }

      if (this._rts === value) {
        return this;
      }

      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
      // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
      //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
      // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

      this.totalTime(_clamp$1(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);

      _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


      return _recacheAncestors(this);
    };

    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.
      // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);


      if (this._ps !== value) {
        this._ps = value;

        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

          this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
        } else {
          _wake();

          this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
        }
      }

      return this;
    };

    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = _roundPrecise(value);
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, this._start - this._delay);
        return this;
      }

      return this._start;
    };

    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };

    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp; // _dp = detached parent

      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };

    _proto.revert = function revert(config) {
      if (config === void 0) {
        config = _revertConfig;
      }

      var prevIsReverting = _reverting$1;
      _reverting$1 = config;

      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config);
        this.totalTime(-0.01, config.suppressEvents);
      }

      this.data !== "nested" && config.kill !== false && this.kill();
      _reverting$1 = prevIsReverting;
      return this;
    };

    _proto.globalTime = function globalTime(rawTime) {
      var animation = this,
          time = arguments.length ? rawTime : animation.rawTime();

      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }

      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). "_sat" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().
    };

    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }

      return this._repeat === -2 ? Infinity : this._repeat;
    };

    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;

        _onUpdateTotalDuration(this);

        return time ? this.time(time) : this;
      }

      return this._rDelay;
    };

    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }

      return this._yoyo;
    };

    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition$1(this, position), _isNotFalse(suppressEvents));
    };

    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.

      return this;
    };

    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };

    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };

    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };

    _proto.resume = function resume() {
      return this.paused(false);
    };

    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

        return this;
      }

      return this._rts < 0;
    };

    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };

    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp,
          start = this._start,
          rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };

    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;

      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }

        return this;
      }

      return vars[type];
    };

    _proto.then = function then(onFulfilled) {
      var self = this,
          prevProm = self._prom;
      return new Promise(function (resolve) {
        var f = _isFunction$2(onFulfilled) ? onFulfilled : _passThrough$1,
            _resolve = function _resolve() {
          var _then = self.then;
          self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

          prevProm && prevProm();
          _isFunction$2(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
          resolve(f);
          self.then = _then;
        };

        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    };

    _proto.kill = function kill() {
      _interrupt(this);
    };

    return Animation;
  }();

  _setDefaults$1(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  /*
   * -------------------------------------------------
   * TIMELINE
   * -------------------------------------------------
   */


  var Timeline = /*#__PURE__*/function (_Animation) {
    _inheritsLoose(Timeline, _Animation);

    function Timeline(vars, position) {
      var _this;

      if (vars === void 0) {
        vars = {};
      }

      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }

    var _proto2 = Timeline.prototype;

    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);

      return this;
    };

    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);

      return this;
    };

    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);

      return this;
    };

    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition$1(this, position), 1);
      return this;
    };

    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    } //ONLY for backward compatibility! Maybe delete?
    ;

    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition$1(this, position));
      return this;
    };

    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._dirty ? this.totalDuration() : this._tDur,
          dur = this._dur,
          tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
          // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
      crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
          time,
          child,
          next,
          iteration,
          cycleDuration,
          prevPaused,
          pauseTween,
          timeScale,
          prevStart,
          prevIteration,
          yoyo,
          isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }

        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;

        if (crossingStart) {
          dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;

          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }

          time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

            iteration = ~~prevIteration;

            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }

            time > dur && (time = dur);
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the "repeatDelay" portion

          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          /*
          make sure children at the end/beginning of the timeline are rendered properly. If, for example,
          a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
          would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
          could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
          we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
          ensure that zero-duration tweens at the very beginning or end of the Timeline work.
          */


          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1,
                doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.

            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

            !suppressEvents && this.parent && _callback$1(this, "onRepeat");

            if (this.vars.repeatRefresh && !isYoyo) {
              this.invalidate()._lock = 1;
              prevIteration = iteration; // otherwise, the onStart() may fire on the 2nd iteration.
            }

            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
              return this;
            }

            dur = this._dur; // in case the duration changed in the onRepeat

            tDur = this._tDur;

            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -0.0001;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }

            this._lock = 0;

            if (!this._ts && !prevPaused) {
              return this;
            } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


            _propagateYoyoEase(this, isYoyo);
          }
        }

        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }

        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
        }

        if (!prevTime && tTime && dur && !suppressEvents && !prevIteration) {
          _callback$1(this, "onStart");

          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }

        if (time >= prevTime && totalTime >= 0) {
          child = this._first;

          while (child) {
            next = child._next;

            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

          while (child) {
            next = child._prev;

            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting$1 && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        }

        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

          if (this._ts) {
            //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
            this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

            _setEnd(this);

            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._onUpdate && !suppressEvents && _callback$1(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
          // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
            _callback$1(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto2.add = function add(child, position) {
      var _this2 = this;

      _isNumber$1(position) || (position = _parsePosition$1(this, position, child));

      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function (obj) {
            return _this2.add(obj, position);
          });
          return this;
        }

        if (_isString$2(child)) {
          return this.addLabel(child, position);
        }

        if (_isFunction$2(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }

      return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
    };

    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }

      if (tweens === void 0) {
        tweens = true;
      }

      if (timelines === void 0) {
        timelines = true;
      }

      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum$1;
      }

      var a = [],
          child = this._first;

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }

        child = child._next;
      }

      return a;
    };

    _proto2.getById = function getById(id) {
      var animations = this.getChildren(1, 1, 1),
          i = animations.length;

      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };

    _proto2.remove = function remove(child) {
      if (_isString$2(child)) {
        return this.removeLabel(child);
      }

      if (_isFunction$2(child)) {
        return this.killTweensOf(child);
      }

      child.parent === this && _removeLinkedListItem(this, child);

      if (child === this._recent) {
        this._recent = this._last;
      }

      return _uncache(this);
    };

    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }

      this._forcing = 1;

      if (!this._dp && this._ts) {
        //special case for the global timeline (or any other that has no parent or detached parent).
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }

      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

      this._forcing = 0;
      return this;
    };

    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition$1(this, position);
      return this;
    };

    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };

    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition$1(this, position));
    };

    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition$1(this, position);

      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }

        child = child._next;
      }
    };

    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive),
          i = tweens.length;

      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }

      return this;
    };

    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
      var a = [],
          parsedTargets = toArray(targets),
          child = this._first,
          isGlobalTime = _isNumber$1(onlyActive),
          // a number is interpreted as a global time. If the animation spans
      children;

      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }

        child = child._next;
      }

      return a;
    } // potential future feature - targets() on timelines
    // targets() {
    // 	let result = [];
    // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
    // 	return result.filter((v, i) => result.indexOf(v) === i);
    // }
    ;

    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};

      var tl = this,
          endTime = _parsePosition$1(tl, position),
          _vars = vars,
          startAt = _vars.startAt,
          _onStart = _vars.onStart,
          onStartParams = _vars.onStartParams,
          immediateRender = _vars.immediateRender,
          initted,
          tween = Tween.to(tl, _setDefaults$1({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();

          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }

          _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
        }
      }, vars));

      return immediateRender ? tween.render(0) : tween;
    };

    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults$1({
        startAt: {
          time: _parsePosition$1(this, fromPosition)
        }
      }, vars));
    };

    _proto2.recent = function recent() {
      return this._recent;
    };

    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition$1(this, afterTime));
    };

    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition$1(this, beforeTime), 1);
    };

    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };

    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }

      var child = this._first,
          labels = this.labels,
          p;
      amount = _roundPrecise(amount);

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }

        child = child._next;
      }

      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }

      return _uncache(this);
    };

    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;

      while (child) {
        child.invalidate(soft);
        child = child._next;
      }

      return _Animation.prototype.invalidate.call(this, soft);
    };

    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }

      var child = this._first,
          next;

      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }

      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };

    _proto2.totalDuration = function totalDuration(value) {
      var max = 0,
          self = this,
          child = self._last,
          prevStart = _bigNum$1,
          prev,
          start,
          parent;

      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }

      if (self._dirty) {
        parent = self.parent;

        while (child) {
          prev = child._prev; //record it here in case the tween changes position in the sequence...

          child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

          start = child._start;

          if (start > prevStart && self._sort && child._ts && !self._lock) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }

          if (start < 0 && child._ts) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= start;

            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += _roundPrecise(start / self._ts);
              self._time -= start;
              self._tTime -= start;
            }

            self.shiftChildren(-start, false, -1e999);
            prevStart = 0;
          }

          child._end > max && child._ts && (max = child._end);
          child = prev;
        }

        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

        self._dirty = 0;
      }

      return self._tDur;
    };

    Timeline.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

        _lastRenderedFrame = _ticker.frame;
      }

      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config$1.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) if (_config$1.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }

          child || _ticker.sleep();
        }
      }
    };

    return Timeline;
  }(Animation);

  _setDefaults$1(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });

  var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
        index = 0,
        matchIndex = 0,
        result,
        startNums,
        color,
        endNum,
        chunk,
        startNum,
        hasRandom,
        a;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings

    end += "";

    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    startNums = start.match(_complexStringNumExp) || [];

    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }

      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

    pt.fp = funcParam;

    if (_relExp.test(end) || hasRandom) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction$2(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop],
        parsedStart = start !== "get" ? start : !_isFunction$2(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction$2(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
        setter = !_isFunction$2(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
        pt;

    if (_isString$2(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }

      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

        if (pt || pt === 0) {
          // to avoid isNaN, like if someone passes in a value like "!= whatever"
          end = pt;
        }
      }
    }

    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        // fun fact: any number multiplied by "" is evaluated as the number 0!
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }

      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config$1.stringFilter, funcParam);
    }
  },
      //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
  _processVars = function _processVars(vars, index, target, targets, tween) {
    _isFunction$2(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

    if (!_isObject$1(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString$2(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }

    var copy = {},
        p;

    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }

    return copy;
  },
      _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;

    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

        i = plugin._props.length;

        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }

    return plugin;
  },
      _overwritingTween,
      //store a reference temporarily so we can avoid overwriting itself.
  _forceAllPropTweens,
      _initTween = function _initTween(tween, time, tTime) {
    var vars = tween.vars,
        ease = vars.ease,
        startAt = vars.startAt,
        immediateRender = vars.immediateRender,
        lazy = vars.lazy,
        onUpdate = vars.onUpdate,
        runBackwards = vars.runBackwards,
        yoyoEase = vars.yoyoEase,
        keyframes = vars.keyframes,
        autoRevert = vars.autoRevert,
        dur = tween._dur,
        prevStartAt = tween._startAt,
        targets = tween._targets,
        parent = tween.parent,
        fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
        autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites$1,
        tl = tween.timeline,
        cleanVars,
        i,
        p,
        pt,
        target,
        hasPriority,
        gsData,
        harness,
        plugin,
        ptLookup,
        index,
        harnessVars,
        overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults$1.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults$1.ease)) : 0;

    if (yoyoEase && tween._yoyo && !tween._repeat) {
      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }

    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

    if (!tl || keyframes && !vars.stagger) {
      //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

      cleanVars = _copyExcluding(vars, _reservedProps);

      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.

        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
        // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

        prevStartAt._lazy = 0;
      }

      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults$1({
          data: "isStart",
          overwrite: false,
          parent: parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function () {
            return _callback$1(tween, "onUpdate");
          },
          stagger: 0
        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


        tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.

        tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween

        time < 0 && (_reverting$1 || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.
            time && (tween._zTime = time);
            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          }
        }
      } else if (runBackwards && dur) {
        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
        if (!prevStartAt) {
          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

          p = _setDefaults$1({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender: immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})

          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

          _removeFromParent(tween._startAt = Tween.set(targets, p));

          tween._startAt._dp = 0; // don't allow it to get put back into root timeline!

          tween._startAt._sat = tween; // used in globalTime()

          time < 0 && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;

          if (!immediateRender) {
            _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded

          } else if (!time) {
            return;
          }
        }
      }

      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;

      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

        index = fullTargets === targets ? i : fullTargets.indexOf(target);

        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

          plugin._props.forEach(function (name) {
            ptLookup[name] = pt;
          });

          plugin.priority && (hasPriority = 1);
        }

        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }

        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;

          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


          overwritten = !tween.parent;
          _overwritingTween = 0;
        }

        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }

      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
    }

    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

    keyframes && time <= 0 && tl.render(_bigNum$1, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
  },
      _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
        pt,
        rootPT,
        lookup,
        i;

    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;

      while (i--) {
        pt = lookup[i][property];

        if (pt && pt.d && pt.d._pt) {
          // it's a plugin, so find the nested PropTween
          pt = pt.d._pt;

          while (pt && pt.p !== property && pt.fp !== property) {
            // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
            pt = pt._next;
          }
        }

        if (!pt) {
          // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
          // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
          _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

          tween.vars[property] = "+=0";

          _initTween(tween, time);

          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().
        }

        ptCache.push(pt);
      }
    }

    i = ptCache.length;

    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round$1(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
    }
  },
      _addAliasesToVars = function _addAliasesToVars(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0,
        propertyAliases = harness && harness.aliases,
        copy,
        p,
        i,
        aliases;

    if (!propertyAliases) {
      return vars;
    }

    copy = _merge({}, vars);

    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;

        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }

    return copy;
  },
      // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
  _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut",
        p,
        a;

    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

      obj.forEach(function (value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  },
      _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
    return _isFunction$2(value) ? value.call(tween, i, target, targets) : _isString$2(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  },
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
      _staggerPropsToSkip = {};

  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
    return _staggerPropsToSkip[name] = 1;
  });
  /*
   * --------------------------------------------------------------------------------------
   * TWEEN
   * --------------------------------------------------------------------------------------
   */


  var Tween = /*#__PURE__*/function (_Animation2) {
    _inheritsLoose(Tween, _Animation2);

    function Tween(targets, vars, position, skipInherit) {
      var _this3;

      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }

      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars,
          duration = _this3$vars.duration,
          delay = _this3$vars.delay,
          immediateRender = _this3$vars.immediateRender,
          stagger = _this3$vars.stagger,
          overwrite = _this3$vars.overwrite,
          keyframes = _this3$vars.keyframes,
          defaults = _this3$vars.defaults,
          scrollTrigger = _this3$vars.scrollTrigger,
          yoyoEase = _this3$vars.yoyoEase,
          parent = vars.parent || _globalTimeline,
          parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber$1(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
          tl,
          i,
          copy,
          l,
          p,
          curTarget,
          staggerFunc,
          staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config$1.nullTargetWarn) || [];
      _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

      _this3._overwrite = overwrite;

      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;

        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);

          if (_isObject$1(stagger)) {
            //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }

          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

            if (!stagger && l === 1 && copy.delay) {
              // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }

            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }

          tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
        } else if (keyframes) {
          _inheritDefaults(_setDefaults$1(tl.vars.defaults, {
            ease: "none"
          }));

          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0,
              a,
              kf,
              v;

          if (_isArray(keyframes)) {
            keyframes.forEach(function (frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
          } else {
            copy = {};

            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }

            for (p in copy) {
              a = copy[p].sort(function (a, b) {
                return a.t - b.t;
              });
              time = 0;

              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v[p] = kf.v;
                tl.to(parsedTargets, v, time);
                time += v.duration;
              }
            }

            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            }); // in case keyframes didn't go to 100%
          }
        }

        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
      }

      if (overwrite === true && !_suppressOverwrites$1) {
        _overwritingTween = _assertThisInitialized(_this3);

        _globalTimeline.killTweensOf(parsedTargets);

        _overwritingTween = 0;
      }

      _addToTimeline(parent, _assertThisInitialized(_this3), position);

      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);

      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

        _this3.render(Math.max(0, -delay) || 0); //in case delay is negative

      }

      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }

    var _proto3 = Tween.prototype;

    _proto3.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._tDur,
          dur = this._dur,
          isNegative = totalTime < 0,
          tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
          time,
          pt,
          iteration,
          cycleDuration,
          prevIteration,
          isYoyo,
          ratio,
          timeline,
          yoyoEase;

      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
        time = tTime;
        timeline = this.timeline;

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          cycleDuration = dur + this._rDelay;

          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }

          time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

            iteration = ~~prevIteration;

            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }

          isYoyo = this._yoyo && iteration & 1;

          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);

          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            //could be during the repeatDelay part. No need to render and fire callbacks.
            this._tTime = tTime;
            return this;
          }

          if (iteration !== prevIteration) {
            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).
              this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }

        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

            return this;
          }

          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!
            return this;
          }

          if (dur !== this._dur) {
            // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._tTime = tTime;
        this._time = time;

        if (!this._act && this._ts) {
          this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

          this._lazy = 0;
        }

        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }

        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback$1(this, "onStart");

          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }

        pt = this._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }

        timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

          _callback$1(this, "onUpdate");
        }

        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback$1(this, "onRepeat");

        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
            _callback$1(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto3.targets = function targets() {
      return this._targets;
    };

    _proto3.invalidate = function invalidate(soft) {
      // "soft" gives us a way to clear out everything EXCEPT the recorded pre-"from" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the "from" values would persist and then on the next render, the from() tweens would initialize and the current value would match the "from" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };

    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
          ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
      // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
      // if (_isObject(property)) { // performance optimization
      // 	for (p in property) {
      // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
      // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
      // 		}
      // 	}
      // } else {

      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
      } //}


      _alignPlayhead(this, 0);

      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };

    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }

      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting$1);
        return this;
      }

      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

        return this;
      }

      var parsedTargets = this._targets,
          killingTargets = targets ? toArray(targets) : parsedTargets,
          propTweenLookup = this._ptLookup,
          firstPT = this._pt,
          overwrittenProps,
          curLookup,
          curOverwriteProps,
          props,
          p,
          pt,
          i;

      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }

      overwrittenProps = this._op = this._op || [];

      if (vars !== "all") {
        //so people can pass in a comma-delimited list of property names
        if (_isString$2(vars)) {
          p = {};

          _forEachName(vars, function (name) {
            return p[name] = 1;
          });

          vars = p;
        }

        vars = _addAliasesToVars(parsedTargets, vars);
      }

      i = parsedTargets.length;

      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];

          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }

          for (p in props) {
            pt = curLookup && curLookup[p];

            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }

              delete curLookup[p];
            }

            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }

      this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

      return this;
    };

    Tween.to = function to(targets, vars) {
      return new Tween(targets, vars, arguments[2]);
    };

    Tween.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };

    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
    };

    Tween.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };

    Tween.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween(targets, vars);
    };

    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };

    return Tween;
  }(Animation);

  _setDefaults$1(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
  // _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
  // 	Tween.prototype[name] = function() {
  // 		let tl = new Timeline();
  // 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
  // 	}
  // });
  //for backward compatibility. Leverage the timeline calls.


  _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
    Tween[name] = function () {
      var tl = new Timeline(),
          params = _slice.call(arguments, 0);

      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  /*
   * --------------------------------------------------------------------------------------
   * PROPTWEEN
   * --------------------------------------------------------------------------------------
   */


  var _setterPlain = function _setterPlain(target, property, value) {
    return target[property] = value;
  },
      _setterFunc = function _setterFunc(target, property, value) {
    return target[property](value);
  },
      _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
    return target[property](data.fp, value);
  },
      _setterAttribute = function _setterAttribute(target, property, value) {
    return target.setAttribute(property, value);
  },
      _getSetter = function _getSetter(target, property) {
    return _isFunction$2(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  },
      _renderPlain = function _renderPlain(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
  },
      _renderBoolean = function _renderBoolean(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  },
      _renderComplexString = function _renderComplexString(ratio, data) {
    var pt = data._pt,
        s = "";

    if (!ratio && data.b) {
      //b = beginning string
      s = data.b;
    } else if (ratio === 1 && data.e) {
      //e = ending string
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

        pt = pt._next;
      }

      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
    }

    data.set(data.t, data.p, s, data);
  },
      _renderPropTweens = function _renderPropTweens(ratio, data) {
    var pt = data._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  },
      _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
    var pt = this._pt,
        next;

    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  },
      _killPropTweensOf = function _killPropTweensOf(property) {
    var pt = this._pt,
        hasNonDependentRemaining,
        next;

    while (pt) {
      next = pt._next;

      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }

      pt = next;
    }

    return !hasNonDependentRemaining;
  },
      _setterWithModifier = function _setterWithModifier(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  },
      _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
    var pt = parent._pt,
        next,
        pt2,
        first,
        last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

    while (pt) {
      next = pt._next;
      pt2 = first;

      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }

      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }

      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }

      pt = next;
    }

    parent._pt = first;
  }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


  var PropTween = /*#__PURE__*/function () {
    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;

      if (next) {
        next._prev = this;
      }
    }

    var _proto4 = PropTween.prototype;

    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target; //modifier target

      this.tween = tween;
    };

    return PropTween;
  }(); //Initialization tasks

  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
    return _reservedProps[name] = 1;
  });

  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults$1,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config$1.stringFilter = _colorStringFilter;

  var _media = [],
      _listeners$1 = {},
      _emptyArray$1 = [],
      _lastMediaTime = 0,
      _contextID = 0,
      _dispatch$1 = function _dispatch(type) {
    return (_listeners$1[type] || _emptyArray$1).map(function (f) {
      return f();
    });
  },
      _onMediaChange = function _onMediaChange() {
    var time = Date.now(),
        matches = [];

    if (time - _lastMediaTime > 2) {
      _dispatch$1("matchMediaInit");

      _media.forEach(function (c) {
        var queries = c.queries,
            conditions = c.conditions,
            match,
            p,
            anyMatch,
            toggled;

        for (p in queries) {
          match = _win$3.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

          match && (anyMatch = 1);

          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }

        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });

      _dispatch$1("matchMediaRevert");

      matches.forEach(function (c) {
        return c.onMatch(c, function (func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time;

      _dispatch$1("matchMedia");
    }
  };

  var Context = /*#__PURE__*/function () {
    function Context(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = []; // returned/cleanup functions

      this.isReverted = false;
      this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because "this" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely

      func && this.add(func);
    }

    var _proto5 = Context.prototype;

    _proto5.add = function add(name, func, scope) {
      // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.
      // if (name && _isFunction(name.revert)) {
      // 	this.data.push(name);
      // 	return (name._ctx = this);
      // }
      if (_isFunction$2(name)) {
        scope = func;
        func = name;
        name = _isFunction$2;
      }

      var self = this,
          f = function f() {
        var prev = _context$2,
            prevSelector = self.selector,
            result;
        prev && prev !== self && prev.data.push(self);
        scope && (self.selector = selector(scope));
        _context$2 = self;
        result = func.apply(self, arguments);
        _isFunction$2(result) && self._r.push(result);
        _context$2 = prev;
        self.selector = prevSelector;
        self.isReverted = false;
        return result;
      };

      self.last = f;
      return name === _isFunction$2 ? f(self, function (func) {
        return self.add(null, func);
      }) : name ? self[name] = f : f;
    };

    _proto5.ignore = function ignore(func) {
      var prev = _context$2;
      _context$2 = null;
      func(this);
      _context$2 = prev;
    };

    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function (e) {
        return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };

    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };

    _proto5.kill = function kill(revert, matchMedia) {
      var _this4 = this;

      if (revert) {
        (function () {
          var tweens = _this4.getTweens(),
              i = _this4.data.length,
              t;

          while (i--) {
            // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.
            t = _this4.data[i];

            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function (tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort


          tweens.map(function (t) {
            return {
              g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
              t: t
            };
          }).sort(function (a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function (o) {
            return o.t.revert(revert);
          }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

          i = _this4.data.length;

          while (i--) {
            // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first
            t = _this4.data[i];

            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }

          _this4._r.forEach(function (f) {
            return f(revert, _this4);
          });

          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function (e) {
          return e.kill && e.kill();
        });
      }

      this.clear();

      if (matchMedia) {
        var i = _media.length;

        while (i--) {
          // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    } // killWithCleanup() {
    // 	this.kill();
    // 	this._r.forEach(f => f(false, this));
    // }
    ;

    _proto5.revert = function revert(config) {
      this.kill(config || {});
    };

    return Context;
  }();

  var MatchMedia = /*#__PURE__*/function () {
    function MatchMedia(scope) {
      this.contexts = [];
      this.scope = scope;
      _context$2 && _context$2.data.push(this);
    }

    var _proto6 = MatchMedia.prototype;

    _proto6.add = function add(conditions, func, scope) {
      _isObject$1(conditions) || (conditions = {
        matches: conditions
      });
      var context = new Context(0, scope || this.scope),
          cond = context.conditions = {},
          mq,
          p,
          active;
      _context$2 && !context.selector && (context.selector = _context$2.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()

      this.contexts.push(context);
      func = context.add("onMatch", func);
      context.queries = conditions;

      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win$3.matchMedia(conditions[p]);

          if (mq) {
            _media.indexOf(context) < 0 && _media.push(context);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }

      active && func(context, function (f) {
        return context.add(null, f);
      });
      return this;
    } // refresh() {
    // 	let time = _lastMediaTime,
    // 		media = _media;
    // 	_lastMediaTime = -1;
    // 	_media = this.contexts;
    // 	_onMediaChange();
    // 	_lastMediaTime = time;
    // 	_media = media;
    // }
    ;

    _proto6.revert = function revert(config) {
      this.kill(config || {});
    };

    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function (c) {
        return c.kill(revert, true);
      });
    };

    return MatchMedia;
  }();
  /*
   * --------------------------------------------------------------------------------------
   * GSAP
   * --------------------------------------------------------------------------------------
   */


  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(function (config) {
        return _createPlugin(config);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString$2(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

      var getter = _getCache(target || {}).get,
          format = unit ? _passThrough$1 : _numericIfPossible;

      unit === "native" && (unit = "");
      return !target ? target : !property ? function (property, unit, uncache) {
        return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);

      if (target.length > 1) {
        var setters = target.map(function (t) {
          return gsap$3.quickSetter(t, property, unit);
        }),
            l = setters.length;
        return function (value) {
          var i = l;

          while (i--) {
            setters[i](value);
          }
        };
      }

      target = target[0] || {};

      var Plugin = _plugins[property],
          cache = _getCache(target),
          p = cache.harness && (cache.harness.aliases || {})[property] || property,
          // in case it's an alias, like "rotate" for "rotation".
      setter = Plugin ? function (value) {
        var p = new Plugin();
        _quickTween._pt = 0;
        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p.render(1, p);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);

      return Plugin ? setter : function (value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults2;

      var tween = gsap$3.to(target, _setDefaults$1((_setDefaults2 = {}, _setDefaults2[property] = "+=0.1", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})),
          func = function func(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };

      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults$1.ease));
      return _mergeDeep(_defaults$1, value || {});
    },
    config: function config(value) {
      return _mergeDeep(_config$1, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name,
          effect = _ref3.effect,
          plugins = _ref3.plugins,
          defaults = _ref3.defaults,
          extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function (pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });

      _effects[name] = function (targets, vars, tl) {
        return effect(toArray(targets), _setDefaults$1(vars || {}, defaults), tl);
      };

      if (extendTimeline) {
        Timeline.prototype[name] = function (targets, vars, position) {
          return this.add(_effects[name](targets, _isObject$1(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }

      var tl = new Timeline(vars),
          child,
          next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

      _globalTimeline.remove(tl);

      tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;

      while (child) {
        next = child._next;

        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }

        child = next;
      }

      _addToTimeline(_globalTimeline, tl, 0);

      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context$2;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function (c) {
        var cond = c.conditions,
            found,
            p;

        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }

        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a = _listeners$1[type] || (_listeners$1[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a = _listeners$1[type],
          i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap: wrap,
      wrapYoyo: wrapYoyo,
      distribute: distribute,
      random: random,
      snap: snap,
      normalize: normalize,
      getUnit: getUnit,
      clamp: clamp,
      splitColor: splitColor,
      toArray: toArray,
      selector: selector,
      mapRange: mapRange,
      pipe: pipe,
      unitize: unitize,
      interpolate: interpolate,
      shuffle: shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween: PropTween,
      globals: _addGlobal,
      Tween: Tween,
      Timeline: Timeline,
      Animation: Animation,
      getCache: _getCache,
      _removeLinkedListItem: _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting$1;
      },
      context: function context(toAdd) {
        if (toAdd && _context$2) {
          _context$2.data.push(toAdd);

          toAdd._ctx = _context$2;
        }

        return _context$2;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites$1 = value;
      }
    }
  };

  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
    return _gsap[name] = Tween[name];
  });

  _ticker.add(Timeline.updateRoot);

  _quickTween = _gsap.to({}, {
    duration: 0
  }); // ---- EXTRA PLUGINS --------------------------------------------------------

  var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
    var pt = plugin._pt;

    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }

    return pt;
  },
      _addModifiers = function _addModifiers(tween, modifiers) {
    var targets = tween._targets,
        p,
        i,
        pt;

    for (p in modifiers) {
      i = targets.length;

      while (i--) {
        pt = tween._ptLookup[i][p];

        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            // is a plugin
            pt = _getPluginPropTween(pt, p);
          }

          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  },
      _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
    return {
      name: name,
      headless: 1,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init(target, vars, tween) {
        tween._onInit = function (tween) {
          var temp, p;

          if (_isString$2(vars)) {
            temp = {};

            _forEachName(vars, function (name) {
              return temp[name] = 1;
            }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


            vars = temp;
          }

          if (modifier) {
            temp = {};

            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }

            vars = temp;
          }

          _addModifiers(tween, vars);
        };
      }
    };
  }; //register core plugins


  var gsap$3 = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v;
      this.tween = tween;

      for (p in vars) {
        v = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v; // record the beginning value so we can revert()

        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;

      while (pt) {
        _reverting$1 ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init(target, value) {
      var i = value.length;

      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

  Tween.version = Timeline.version = gsap$3.version = "3.14.2";
  _coreReady = 1;
  _windowExists$3() && _wake();
  _easeMap.Power0;
      _easeMap.Power1;
      _easeMap.Power2;
      _easeMap.Power3;
      _easeMap.Power4;
      _easeMap.Linear;
      _easeMap.Quad;
      _easeMap.Cubic;
      _easeMap.Quart;
      _easeMap.Quint;
      _easeMap.Strong;
      _easeMap.Elastic;
      _easeMap.Back;
      _easeMap.SteppedEase;
      _easeMap.Bounce;
      _easeMap.Sine;
      _easeMap.Expo;
      _easeMap.Circ;

  /*!
   * CSSPlugin 3.14.2
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */


  var _win$2,
      _doc$2,
      _docElement,
      _pluginInitted,
      _tempDiv,
      _recentSetterPlugin,
      _reverting,
      _windowExists$2 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _transformProps = {},
      _RAD2DEG = 180 / Math.PI,
      _DEG2RAD = Math.PI / 180,
      _atan2 = Math.atan2,
      _bigNum = 1e8,
      _capsExp$1 = /([A-Z])/g,
      _horizontalExp = /(left|right|width|margin|padding|x)/i,
      _complexExp = /[\s,\(]\S/,
      _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  },
      _renderCSSProp = function _renderCSSProp(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
      //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderCSSPropWithBeginningAndEnd = function _renderCSSPropWithBeginningAndEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
      //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
  },
      _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  },
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  },
      _setterCSSStyle = function _setterCSSStyle(target, property, value) {
    return target.style[property] = value;
  },
      _setterCSSProp = function _setterCSSProp(target, property, value) {
    return target.style.setProperty(property, value);
  },
      _setterTransform = function _setterTransform(target, property, value) {
    return target._gsap[property] = value;
  },
      _setterScale = function _setterScale(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  },
      _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  },
      _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  },
      _transformProp$1 = "transform",
      _transformOriginProp = _transformProp$1 + "Origin",
      _saveStyle = function _saveStyle(property, isNotCSS) {
    var _this = this;

    var target = this.target,
        style = target.style,
        cache = target._gsap;

    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};

      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function (a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.

        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function (p) {
          return _saveStyle.call(_this, p, isNotCSS);
        });
      }

      if (this.props.indexOf(_transformProp$1) >= 0) {
        return;
      }

      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }

      property = _transformProp$1;
    }

    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  },
      _removeIndependentTransforms = function _removeIndependentTransforms(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  },
      _revertStyle = function _revertStyle() {
    var props = this.props,
        target = this.target,
        style = target.style,
        cache = target._gsap,
        i,
        p;

    for (i = 0; i < props.length; i += 3) {
      // stored like this: property, isNotCSS, value
      if (!props[i + 1]) {
        props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp$1, "-$1").toLowerCase());
      } else if (props[i + 1] === 2) {
        // non-CSS value (function-based)
        target[props[i]](props[i + 2]);
      } else {
        // non-CSS value (not function-based)
        target[props[i]] = props[i + 2];
      }
    }

    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }

      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }

      i = _reverting();

      if ((!i || !i.isStart) && !style[_transformProp$1]) {
        _removeIndependentTransforms(style);

        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.

          cache.zOrigin = 0;
          cache.renderTransform();
        }

        cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
      }
    }
  },
      _getStyleSaver = function _getStyleSaver(target, properties) {
    var saver = {
      target: target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap$3.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.

    properties && target.style && target.nodeType && properties.split(",").forEach(function (p) {
      return saver.save(p);
    }); // make sure it's a DOM node too.

    return saver;
  },
      _supports3D,
      _createElement = function _createElement(type, ns) {
    var e = _doc$2.createElementNS ? _doc$2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$2.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

    return e && e.style ? e : _doc$2.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  },
      _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp$1, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
  },
      _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
      _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
    var e = element || _tempDiv,
        s = e.style,
        i = 5;

    if (property in s && !preferPrefix) {
      return property;
    }

    property = property.charAt(0).toUpperCase() + property.substr(1);

    while (i-- && !(_prefixes[i] + property in s)) {}

    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  },
      _initCore$2 = function _initCore() {
    if (_windowExists$2() && window.document) {
      _win$2 = window;
      _doc$2 = _win$2.document;
      _docElement = _doc$2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _createElement("div");
      _transformProp$1 = _checkPropPrefix(_transformProp$1);
      _transformOriginProp = _transformProp$1 + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

      _supports3D = !!_checkPropPrefix("perspective");
      _reverting = gsap$3.core.reverting;
      _pluginInitted = 1;
    }
  },
      _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var owner = target.ownerSVGElement,
        svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        clone = target.cloneNode(true),
        bbox;

    clone.style.display = "block";
    svg.appendChild(clone);

    _docElement.appendChild(svg);

    try {
      bbox = clone.getBBox();
    } catch (e) {}

    svg.removeChild(clone);

    _docElement.removeChild(svg);

    return bbox;
  },
      _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
    var i = attributesArray.length;

    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  },
      _getBBox = function _getBBox(target) {
    var bounds, cloned;

    try {
      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }

    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  },
      _isSVG = function _isSVG(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
      //reports if the element is an SVG on which getBBox() actually works
  _removeProperty = function _removeProperty(target, property) {
    if (property) {
      var style = target.style,
          first2Chars;

      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp$1;
      }

      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);

        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          property = "-" + property;
        }

        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp$1, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        style.removeAttribute(property);
      }
    }
  },
      _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;

    plugin._props.push(property);

    return pt;
  },
      _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  },
      _nonStandardLayouts = {
    grid: 1,
    flex: 1
  },
      //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
  _convertToUnit = function _convertToUnit(target, property, value, unit) {
    var curValue = parseFloat(value) || 0,
        curUnit = (value + "").trim().substr((curValue + "").length) || "px",
        // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
    style = _tempDiv.style,
        horizontal = _horizontalExp.test(property),
        isRootSVG = target.tagName.toLowerCase() === "svg",
        measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
        amount = 100,
        toPixels = unit === "px",
        toPercent = unit === "%",
        px,
        parent,
        cache,
        isSVG;

    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }

    curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);

    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round$1(toPercent ? curValue / px * amount : curValue / 100 * px);
    }

    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }

    if (!parent || parent === _doc$2 || !parent.appendChild) {
      parent = _doc$2.body;
    }

    cache = parent._gsap;

    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round$1(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.
        var v = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v ? target.style[property] = v : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }

      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }

    return _round$1(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  },
      _get = function _get(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore$2();

    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];

      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }

    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];

      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
      }
    }

    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  },
      _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    if (!start || start === "none") {
      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/
      var p = _checkPropPrefix(prop, target, 1),
          s = p && _getComputedProperty(target, p, 1);

      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
      }
    }

    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
        index = 0,
        matchIndex = 0,
        a,
        result,
        startValues,
        startNum,
        color,
        startValue,
        endValue,
        endNum,
        chunk,
        endUnit,
        startUnit,
        endValues;
    pt.b = start;
    pt.e = end;
    start += ""; // ensure values are strings

    end += "";

    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }

    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }

    a = [start, end];

    _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];

    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);

        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }

        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;

          if (!endUnit) {
            //if something like "perspective:300" is passed in and we must add a unit to the end
            endUnit = endUnit || _config$1.units[prop] || startUnit;

            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }

          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }

      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }

    _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  },
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
    var split = value.split(" "),
        x = split[0],
        y = split[1] || "50%";

    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      //the user provided them in the wrong order, so flip them
      value = x;
      x = y;
      y = value;
    }

    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  },
      _renderClearProps = function _renderClearProps(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t,
          style = target.style,
          props = data.u,
          cache = target._gsap,
          prop,
          clearTransforms,
          i;

      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;

        while (--i > -1) {
          prop = props[i];

          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp$1;
          }

          _removeProperty(target, prop);
        }
      }

      if (clearTransforms) {
        _removeProperty(target, _transformProp$1);

        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";

          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


          cache.uncache = 1;

          _removeIndependentTransforms(style);
        }
      }
    }
  },
      // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
  _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;

        plugin._props.push(property);

        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */

  },

  /*
   * --------------------------------------------------------------------------------------
   * TRANSFORMS
   * --------------------------------------------------------------------------------------
   */
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _rotationalProperties = {},
      _isNullTransform = function _isNullTransform(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  },
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
    var matrixString = _getComputedProperty(target, _transformProp$1);

    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round$1);
  },
      _getMatrix = function _getMatrix(target, force2D) {
    var cache = target._gsap || _getCache(target),
        style = target.style,
        matrix = _getComputedTransformMatrixAsArray(target),
        parent,
        nextSibling,
        temp,
        addedToDOM;

    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;

      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.
        addedToDOM = 1; //flag

        nextSibling = target.nextElementSibling;

        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

      }

      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");

      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }

    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  },
      _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap,
        matrix = matrixArray || _getMatrix(target, true),
        xOriginOld = cache.xOrigin || 0,
        yOriginOld = cache.yOrigin || 0,
        xOffsetOld = cache.xOffset || 0,
        yOffsetOld = cache.yOffset || 0,
        a = matrix[0],
        b = matrix[1],
        c = matrix[2],
        d = matrix[3],
        tx = matrix[4],
        ty = matrix[5],
        originSplit = origin.split(" "),
        xOrigin = parseFloat(originSplit[0]) || 0,
        yOrigin = parseFloat(originSplit[1]) || 0,
        bounds,
        determinant,
        x,
        y;

    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin); // if (!("xOrigin" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration
      // 	xOrigin -= bounds.x;
      // 	yOrigin -= bounds.y;
      // }
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.
    }

    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }

    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }

    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  },
      _parseTransform = function _parseTransform(target, uncache) {
    var cache = target._gsap || new GSCache(target);

    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }

    var style = target.style,
        invertedScaleX = cache.scaleX < 0,
        px = "px",
        deg = "deg",
        cs = getComputedStyle(target),
        origin = _getComputedProperty(target, _transformOriginProp) || "0",
        x,
        y,
        z,
        scaleX,
        scaleY,
        rotation,
        rotationX,
        rotationY,
        skewX,
        skewY,
        perspective,
        xOrigin,
        yOrigin,
        matrix,
        angle,
        cos,
        sin,
        a,
        b,
        c,
        d,
        a12,
        a22,
        t1,
        t2,
        t3,
        a13,
        a23,
        a33,
        a42,
        a43,
        a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));

    if (cs.translate) {
      // accommodate independent transforms by combining them into normal ones.
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp$1] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp$1] !== "none" ? cs[_transformProp$1] : "");
      }

      style.scale = style.rotate = style.translate = "none";
    }

    matrix = _getMatrix(target, cache.svg);

    if (cache.svg) {
      if (cache.uncache) {
        // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
      }

      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }

    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;

    if (matrix !== _identity2DMatrix) {
      a = matrix[0]; //a11

      b = matrix[1]; //a21

      c = matrix[2]; //a31

      d = matrix[3]; //a41

      x = a12 = matrix[4];
      y = a22 = matrix[5]; //2D matrix

      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        } //3D matrix

      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG; //rotationX

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        } //rotationY


        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        } //rotationZ


        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }

        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }

        scaleX = _round$1(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round$1(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }

      if (cache.svg) {
        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp$1));
        t1 && target.setAttribute("transform", t1);
      }
    }

    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }

    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round$1(scaleX);
    cache.scaleY = _round$1(scaleY);
    cache.rotation = _round$1(rotation) + deg;
    cache.rotationX = _round$1(rotationX) + deg;
    cache.rotationY = _round$1(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;

    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }

    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config$1.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  },
      _firstTwoOnly = function _firstTwoOnly(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  },
      //for handling transformOrigin values, stripping out the 3rd dimension
  _addPxTranslate = function _addPxTranslate(target, start, value) {
    var unit = getUnit(start);
    return _round$1(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  },
      _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;

    _renderCSSTransforms(ratio, cache);
  },
      _zeroDeg = "0deg",
      _zeroPx = "0px",
      _endParenthesis = ") ",
      _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
    var _ref = cache || this,
        xPercent = _ref.xPercent,
        yPercent = _ref.yPercent,
        x = _ref.x,
        y = _ref.y,
        z = _ref.z,
        rotation = _ref.rotation,
        rotationY = _ref.rotationY,
        rotationX = _ref.rotationX,
        skewX = _ref.skewX,
        skewY = _ref.skewY,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        transformPerspective = _ref.transformPerspective,
        force3D = _ref.force3D,
        target = _ref.target,
        zOrigin = _ref.zOrigin,
        transforms = "",
        use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD,
          a13 = Math.sin(angle),
          a33 = Math.cos(angle),
          cos;

      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }

    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }

    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }

    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }

    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }

    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }

    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }

    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }

    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }

    target.style[_transformProp$1] = transforms || "translate(0, 0)";
  },
      _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
    var _ref2 = cache || this,
        xPercent = _ref2.xPercent,
        yPercent = _ref2.yPercent,
        x = _ref2.x,
        y = _ref2.y,
        rotation = _ref2.rotation,
        skewX = _ref2.skewX,
        skewY = _ref2.skewY,
        scaleX = _ref2.scaleX,
        scaleY = _ref2.scaleY,
        target = _ref2.target,
        xOrigin = _ref2.xOrigin,
        yOrigin = _ref2.yOrigin,
        xOffset = _ref2.xOffset,
        yOffset = _ref2.yOffset,
        forceCSS = _ref2.forceCSS,
        tx = parseFloat(x),
        ty = parseFloat(y),
        a11,
        a21,
        a12,
        a22,
        temp;

    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);

    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }

    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;

      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;

        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }

      a11 = _round$1(a11);
      a21 = _round$1(a21);
      a12 = _round$1(a12);
      a22 = _round$1(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }

    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }

    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round$1(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round$1(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }

    if (xPercent || yPercent) {
      //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
      temp = target.getBBox();
      tx = _round$1(tx + xPercent / 100 * temp.width);
      ty = _round$1(ty + yPercent / 100 * temp.height);
    }

    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp$1] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
  },
      _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
    var cap = 360,
        isString = _isString$2(endValue),
        endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
        change = endNum - startNum,
        finalValue = startNum + change + "deg",
        direction,
        pt;

    if (isString) {
      direction = endValue.split("_")[1];

      if (direction === "short") {
        change %= cap;

        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }

      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
      }
    }

    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";

    plugin._props.push(property);

    return pt;
  },
      _assign = function _assign(target, source) {
    // Internet Explorer doesn't have Object.assign(), so we recreate it here.
    for (var p in source) {
      target[p] = source[p];
    }

    return target;
  },
      _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
    var startCache = _assign({}, target._gsap),
        exclude = "perspective,force3D,transformOrigin,svgOrigin",
        style = target.style,
        endCache,
        p,
        startValue,
        endValue,
        startNum,
        endNum,
        startUnit,
        endUnit;

    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp$1] = transforms;
      endCache = _parseTransform(target, 1);

      _removeProperty(target, _transformProp$1);

      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp$1];
      style[_transformProp$1] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp$1] = startValue;
    }

    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];

      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;

        plugin._props.push(p);
      }
    }

    _assign(endCache, startCache);
  }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


  _forEachName("padding,margin,Width,Radius", function (name, index) {
    var t = "Top",
        r = "Right",
        b = "Bottom",
        l = "Left",
        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
      return index < 2 ? name + side : "border" + side + name;
    });

    _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
      var a, vars;

      if (arguments.length < 4) {
        // getter, passed target, property, and unit (from _get())
        a = props.map(function (prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }

      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function (prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });

  var CSSPlugin = {
    name: "css",
    register: _initCore$2,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init(target, vars, tween, index, targets) {
      var props = this._props,
          style = target.style,
          startAt = tween.vars.startAt,
          startValue,
          endValue,
          endNum,
          startNum,
          type,
          specialProp,
          p,
          startUnit,
          endUnit,
          relative,
          isTransformRelated,
          transformPropTween,
          cache,
          smooth,
          hasPriority,
          inlineProps,
          finalTransformValue;
      _pluginInitted || _initCore$2(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;

      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }

        endValue = vars[p];

        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          // plugins
          continue;
        }

        type = typeof endValue;
        specialProp = _specialProps[p];

        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }

        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }

        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          //CSS variable
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;

          if (!_colorExp.test(startValue)) {
            // colors don't have units
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          }

          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString$2(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config$1.units[p] || getUnit(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
          } else {
            startValue = _get(target, p);
          }

          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);

          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                startNum = 0;
              }

              inlineProps.push("visibility", 0, style.visibility);

              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }

            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }

          isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

          if (isTransformRelated) {
            this.styles.save(p);
            finalTransformValue = endValue; // this is always the same as endValue except when it's a var(--) value, in which case we need to calculate the end value.

            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));

              if (endValue.substring(0, 5) === "calc(") {
                var origPerspective = target.style.perspective;
                target.style.perspective = endValue;
                endValue = _getComputedProperty(target, "perspective");
                origPerspective ? target.style.perspective = origPerspective : _removeProperty(target, "perspective");
              }

              endNum = parseFloat(endValue);
            }

            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp$1, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

              transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
            }

            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }

              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);

              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);

              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);

              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }

          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0); // protect against NaN

            endUnit = getUnit(endValue) || (p in _config$1.units ? _config$1.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;

            if (isTransformRelated && finalTransformValue !== endValue) {
              this._pt.b = startValue;
              this._pt.e = finalTransformValue;
              this._pt.r = _renderCSSPropWithBeginningAndEnd;
            } else if (startUnit !== endUnit && endUnit !== "%") {
              //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);

              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }

          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }

      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render(ratio, data) {
      if (data.tween._time || !_reverting()) {
        var pt = data._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty: _removeProperty,
      _getMatrix: _getMatrix
    }
  };
  gsap$3.utils.checkPrefix = _checkPropPrefix;
  gsap$3.core.getStyleSaver = _getStyleSaver;

  (function (positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
      _transformProps[name] = 1;
    });

    _forEachName(rotation, function (name) {
      _config$1.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });

    _propertyAliases[all[13]] = positionAndScale + "," + rotation;

    _forEachName(aliases, function (name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
    _config$1.units[name] = "px";
  });

  gsap$3.registerPlugin(CSSPlugin);

  var gsapWithCSS = gsap$3.registerPlugin(CSSPlugin) || gsap$3;
      // to protect from tree shaking
  gsapWithCSS.core.Tween;

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /*!
   * Observer 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var gsap$2,
      _coreInitted$2,
      _win$1,
      _doc$1,
      _docEl$2,
      _body$2,
      _isTouch,
      _pointerType,
      ScrollTrigger$2,
      _root$1,
      _normalizer$1,
      _eventTypes,
      _context$1,
      _getGSAP$2 = function _getGSAP() {
    return gsap$2 || typeof window !== "undefined" && (gsap$2 = window.gsap) && gsap$2.registerPlugin && gsap$2;
  },
      _startup$1 = 1,
      _observers = [],
      _scrollers = [],
      _proxies = [],
      _getTime$1 = Date.now,
      _bridge = function _bridge(name, value) {
    return value;
  },
      _integrate = function _integrate() {
    var core = ScrollTrigger$2.core,
        data = core.bridge || {},
        scrollers = core._scrollers,
        proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;

    _bridge = function _bridge(name, value) {
      return data[name](value);
    };
  },
      _getProxyProp = function _getProxyProp(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  },
      _isViewport$1 = function _isViewport(el) {
    return !!~_root$1.indexOf(el);
  },
      _addListener$1 = function _addListener(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  },
      _removeListener$1 = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
      _scrollLeft = "scrollLeft",
      _scrollTop = "scrollTop",
      _onScroll$1 = function _onScroll() {
    return _normalizer$1 && _normalizer$1.isPressed || _scrollers.cache++;
  },
      _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
    var cachingFunc = function cachingFunc(value) {
      // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
      if (value || value === 0) {
        _startup$1 && (_win$1.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

        var isNormalizing = _normalizer$1 && _normalizer$1.isPressed;
        value = cachingFunc.v = Math.round(value) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

        f(value);
        cachingFunc.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
      } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
        cachingFunc.cacheID = _scrollers.cache;
        cachingFunc.v = f();
      }

      return cachingFunc.v + cachingFunc.offset;
    };

    cachingFunc.offset = 0;
    return f && cachingFunc;
  },
      _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win$1.scrollTo(value, _vertical.sc()) : _win$1.pageXOffset || _doc$1[_scrollLeft] || _docEl$2[_scrollLeft] || _body$2[_scrollLeft] || 0;
    })
  },
      _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win$1.scrollTo(_horizontal.sc(), value) : _win$1.pageYOffset || _doc$1[_scrollTop] || _docEl$2[_scrollTop] || _body$2[_scrollTop] || 0;
    })
  },
      _getTarget = function _getTarget(t, self) {
    return (self && self._ctx && self._ctx.selector || gsap$2.utils.toArray)(t)[0] || (typeof t === "string" && gsap$2.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  },
      _isWithin = function _isWithin(element, list) {
    // check if the element is in the list or is a descendant of an element in the list.
    var i = list.length;

    while (i--) {
      if (list[i] === element || list[i].contains(element)) {
        return true;
      }
    }

    return false;
  },
      _getScrollFunc = function _getScrollFunc(element, _ref) {
    var s = _ref.s,
        sc = _ref.sc;
    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
    _isViewport$1(element) && (element = _doc$1.scrollingElement || _docEl$2);

    var i = _scrollers.indexOf(element),
        offset = sc === _vertical.sc ? 1 : 2;

    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || _addListener$1(element, "scroll", _onScroll$1); // clear the cache when a scroll occurs

    var prev = _scrollers[i + offset],
        func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport$1(element) ? sc : _scrollCacheFunc(function (value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap$2.getProperty(element, "scrollBehavior") === "smooth"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.

    return func;
  },
      _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
    var v1 = value,
        v2 = value,
        t1 = _getTime$1(),
        t2 = t1,
        min = minTimeRefresh || 50,
        dropToZeroTime = Math.max(500, min * 3),
        update = function update(value, force) {
      var t = _getTime$1();

      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value;
      } else {
        // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
        v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
      }
    },
        reset = function reset() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    },
        getVelocity = function getVelocity(latestValue) {
      var tOld = t2,
          vOld = v2,
          t = _getTime$1();

      (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
    };

    return {
      update: update,
      reset: reset,
      getVelocity: getVelocity
    };
  },
      _getEvent = function _getEvent(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  },
      _getAbsoluteMax = function _getAbsoluteMax(a) {
    var max = Math.max.apply(Math, a),
        min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  },
      _setScrollTrigger = function _setScrollTrigger() {
    ScrollTrigger$2 = gsap$2.core.globals().ScrollTrigger;
    ScrollTrigger$2 && ScrollTrigger$2.core && _integrate();
  },
      _initCore$1 = function _initCore(core) {
    gsap$2 = core || _getGSAP$2();

    if (!_coreInitted$2 && gsap$2 && typeof document !== "undefined" && document.body) {
      _win$1 = window;
      _doc$1 = document;
      _docEl$2 = _doc$1.documentElement;
      _body$2 = _doc$1.body;
      _root$1 = [_win$1, _doc$1, _docEl$2, _body$2];
      gsap$2.utils.clamp;

      _context$1 = gsap$2.core.context || function () {};

      _pointerType = "onpointerenter" in _body$2 ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

      _isTouch = Observer$1.isTouch = _win$1.matchMedia && _win$1.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win$1 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer$1.eventTypes = ("ontouchstart" in _docEl$2 ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl$2) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function () {
        return _startup$1 = 0;
      }, 500);

      _setScrollTrigger();

      _coreInitted$2 = 1;
    }

    return _coreInitted$2;
  };

  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer$1 = /*#__PURE__*/function () {
    function Observer(vars) {
      this.init(vars);
    }

    var _proto = Observer.prototype;

    _proto.init = function init(vars) {
      _coreInitted$2 || _initCore$1(gsap$2) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger$2 || _setScrollTrigger();
      var tolerance = vars.tolerance,
          dragMinimum = vars.dragMinimum,
          type = vars.type,
          target = vars.target,
          lineHeight = vars.lineHeight,
          debounce = vars.debounce,
          preventDefault = vars.preventDefault,
          onStop = vars.onStop,
          onStopDelay = vars.onStopDelay,
          ignore = vars.ignore,
          wheelSpeed = vars.wheelSpeed,
          event = vars.event,
          onDragStart = vars.onDragStart,
          onDragEnd = vars.onDragEnd,
          onDrag = vars.onDrag,
          onPress = vars.onPress,
          onRelease = vars.onRelease,
          onRight = vars.onRight,
          onLeft = vars.onLeft,
          onUp = vars.onUp,
          onDown = vars.onDown,
          onChangeX = vars.onChangeX,
          onChangeY = vars.onChangeY,
          onChange = vars.onChange,
          onToggleX = vars.onToggleX,
          onToggleY = vars.onToggleY,
          onHover = vars.onHover,
          onHoverEnd = vars.onHoverEnd,
          onMove = vars.onMove,
          ignoreCheck = vars.ignoreCheck,
          isNormalizer = vars.isNormalizer,
          onGestureStart = vars.onGestureStart,
          onGestureEnd = vars.onGestureEnd,
          onWheel = vars.onWheel,
          onEnable = vars.onEnable,
          onDisable = vars.onDisable,
          onClick = vars.onClick,
          scrollSpeed = vars.scrollSpeed,
          capture = vars.capture,
          allowClicks = vars.allowClicks,
          lockAxis = vars.lockAxis,
          onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl$2;
      this.vars = vars;
      ignore && (ignore = gsap$2.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win$1.getComputedStyle(_body$2).lineHeight) || 22); // note: browser may report "normal", so default to 22.

      var id,
          onStopDelayedCall,
          dragged,
          moved,
          wheeled,
          locked,
          axis,
          self = this,
          prevDeltaX = 0,
          prevDeltaY = 0,
          passive = vars.passive || !preventDefault && vars.passive !== false,
          scrollFuncX = _getScrollFunc(target, _horizontal),
          scrollFuncY = _getScrollFunc(target, _vertical),
          scrollX = scrollFuncX(),
          scrollY = scrollFuncY(),
          limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
          // for devices that accommodate mouse events and touch events, we need to distinguish.
      isViewport = _isViewport$1(target),
          ownerDoc = target.ownerDocument || _doc$1,
          deltaX = [0, 0, 0],
          // wheel, scroll, pointer/touch
      deltaY = [0, 0, 0],
          onClickTime = 0,
          clickCapture = function clickCapture() {
        return onClickTime = _getTime$1();
      },
          _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
        return (self.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      },
          onStopFunc = function onStopFunc() {
        self._vx.reset();

        self._vy.reset();

        onStopDelayedCall.pause();
        onStop && onStop(self);
      },
          update = function update() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX),
            dy = self.deltaY = _getAbsoluteMax(deltaY),
            changedX = Math.abs(dx) >= tolerance,
            changedY = Math.abs(dy) >= tolerance;

        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }

        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }

        if (moved || dragged) {
          onMove && onMove(self);

          if (dragged) {
            onDragStart && dragged === 1 && onDragStart(self);
            onDrag && onDrag(self);
            dragged = 0;
          }

          moved = false;
        }

        locked && !(locked = false) && onLockAxis && onLockAxis(self);

        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }

        id = 0;
      },
          onDelta = function onDelta(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;

        self._vx.update(x);

        self._vy.update(y);

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }

        if (axis !== "y") {
          deltaX[2] += x;

          self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

        }

        if (axis !== "x") {
          deltaY[2] += y;

          self._vy.update(y, true);
        }

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          _onDrag = function _onDrag(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y,
            isDragging = self.isDragging;
        self.x = x;
        self.y = y;

        if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {
          dragged || (dragged = isDragging ? 2 : 1); // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag

          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
        }
      },
          _onPress = self.onPress = function (e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }

        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e.clientX;
        self.startY = self.y = e.clientY;

        self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


        self._vy.reset();

        _addListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);

        self.deltaX = self.deltaY = 0;
        onPress && onPress(self);
      },
          _onRelease = self.onRelease = function (e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

        var isTrackingDrag = !isNaN(self.y - self.startY),
            wasDragging = self.isDragging,
            isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
            // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
        eventData = _getEvent(e);

        if (!isDragNotClick && isTrackingDrag) {
          self._vx.reset();

          self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.


          if (preventDefault && allowClicks) {
            gsap$2.delayedCall(0.08, function () {
              // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
              if (_getTime$1() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  //some browsers (like mobile Safari) don't properly trigger the click event
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win$1, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }

        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().

        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, isDragNotClick);
      },
          _onGestureStart = function _onGestureStart(e) {
        return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
      },
          _onGestureEnd = function _onGestureEnd() {
        return (self.isGesturing = false) || onGestureEnd(self);
      },
          onScroll = function onScroll(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = scrollFuncX(),
            y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      },
          _onWheel = function _onWheel(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win$1.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      },
          _onMove = function _onMove(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y;
        self.x = x;
        self.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      },
          _onHover = function _onHover(e) {
        self.event = e;
        onHover(self);
      },
          _onHoverEnd = function _onHoverEnd(e) {
        self.event = e;
        onHoverEnd(self);
      },
          _onClick = function _onClick(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
      };

      onStopDelayedCall = self._dc = gsap$2.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;

      _context$1(this);

      self.enable = function (e) {
        if (!self.isEnabled) {
          _addListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

          type.indexOf("scroll") >= 0 && _addListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener$1(target, "wheel", _onWheel, passive, capture);

          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener$1(target, _eventTypes[0], _onPress, passive, capture);

            _addListener$1(ownerDoc, _eventTypes[2], _onRelease);

            _addListener$1(ownerDoc, _eventTypes[3], _onRelease);

            allowClicks && _addListener$1(target, "click", clickCapture, true, true);
            onClick && _addListener$1(target, "click", _onClick);
            onGestureStart && _addListener$1(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener$1(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener$1(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener$1(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener$1(target, _pointerType + "move", _onMove);
          }

          self.isEnabled = true;
          self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;

          self._vx.reset();

          self._vy.reset();

          scrollX = scrollFuncX();
          scrollY = scrollFuncY();
          e && e.type && _onPress(e);
          onEnable && onEnable(self);
        }

        return self;
      };

      self.disable = function () {
        if (self.isEnabled) {
          // only remove the _onScroll listener if there aren't any others that rely on the functionality.
          _observers.filter(function (o) {
            return o !== self && _isViewport$1(o.target);
          }).length || _removeListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

          if (self.isPressed) {
            self._vx.reset();

            self._vy.reset();

            _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }

          _removeListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

          _removeListener$1(target, "wheel", _onWheel, capture);

          _removeListener$1(target, _eventTypes[0], _onPress, capture);

          _removeListener$1(ownerDoc, _eventTypes[2], _onRelease);

          _removeListener$1(ownerDoc, _eventTypes[3], _onRelease);

          _removeListener$1(target, "click", clickCapture, true);

          _removeListener$1(target, "click", _onClick);

          _removeListener$1(ownerDoc, "gesturestart", _onGestureStart);

          _removeListener$1(ownerDoc, "gestureend", _onGestureEnd);

          _removeListener$1(target, _pointerType + "enter", _onHover);

          _removeListener$1(target, _pointerType + "leave", _onHoverEnd);

          _removeListener$1(target, _pointerType + "move", _onMove);

          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };

      self.kill = self.revert = function () {
        self.disable();

        var i = _observers.indexOf(self);

        i >= 0 && _observers.splice(i, 1);
        _normalizer$1 === self && (_normalizer$1 = 0);
      };

      _observers.push(self);

      isNormalizer && _isViewport$1(target) && (_normalizer$1 = self);
      self.enable(event);
    };

    _createClass(Observer, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);

    return Observer;
  }();
  Observer$1.version = "3.14.2";

  Observer$1.create = function (vars) {
    return new Observer$1(vars);
  };

  Observer$1.register = _initCore$1;

  Observer$1.getAll = function () {
    return _observers.slice();
  };

  Observer$1.getById = function (id) {
    return _observers.filter(function (o) {
      return o.vars.id === id;
    })[0];
  };

  _getGSAP$2() && gsap$2.registerPlugin(Observer$1);

  /*!
   * ScrollTrigger 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */


  var gsap$1,
      _coreInitted$1,
      _win,
      _doc,
      _docEl$1,
      _body$1,
      _root,
      _resizeDelay,
      _toArray$1,
      _clamp,
      _time2,
      _syncInterval,
      _refreshing,
      _pointerIsDown,
      _transformProp,
      _i,
      _prevWidth,
      _prevHeight,
      _autoRefresh,
      _sort,
      _suppressOverwrites,
      _ignoreResize,
      _normalizer,
      _ignoreMobileResize,
      _baseScreenHeight,
      _baseScreenWidth,
      _fixIOSBug,
      _context,
      _scrollRestoration,
      _div100vh,
      _100vh,
      _isReverted,
      _clampingMax,
      _limitCallbacks,
      // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
  _startup = 1,
      _getTime = Date.now,
      _time1 = _getTime(),
      _lastScrollTime = 0,
      _enabled = 0,
      _parseClamp = function _parseClamp(value, type, self) {
    var clamp = _isString$1(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self["_" + type + "Clamp"] = clamp;
    return clamp ? value.substr(6, value.length - 7) : value;
  },
      _keepClamp = function _keepClamp(value, clamp) {
    return clamp && (!_isString$1(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  },
      _rafBugFix = function _rafBugFix() {
    return _enabled && requestAnimationFrame(_rafBugFix);
  },
      // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.
  _pointerDownHandler = function _pointerDownHandler() {
    return _pointerIsDown = 1;
  },
      _pointerUpHandler = function _pointerUpHandler() {
    return _pointerIsDown = 0;
  },
      _passThrough = function _passThrough(v) {
    return v;
  },
      _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
      _windowExists$1 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _getGSAP$1 = function _getGSAP() {
    return gsap$1 || _windowExists$1() && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
  },
      _isViewport = function _isViewport(e) {
    return !!~_root.indexOf(e);
  },
      _getViewportDimension = function _getViewportDimension(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win["inner" + dimensionProperty]) || _docEl$1["client" + dimensionProperty] || _body$1["client" + dimensionProperty];
  },
      _getBoundsFunc = function _getBoundsFunc(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
      _winOffsets.width = _win.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function () {
      return _getBounds(element);
    });
  },
      _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
    var d = _ref.d,
        d2 = _ref.d2,
        a = _ref.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
      return a()[d];
    } : function () {
      return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
    };
  },
      _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
      return _winOffsets;
    };
  },
      _maxScroll = function _maxScroll(element, _ref2) {
    var s = _ref2.s,
        d2 = _ref2.d2,
        d = _ref2.d,
        a = _ref2.a;
    return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl$1[s] || _body$1[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
  },
      _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  },
      _isString$1 = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction$1 = function _isFunction(value) {
    return typeof value === "function";
  },
      _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
      _isObject = function _isObject(value) {
    return typeof value === "object";
  },
      _endAnimation = function _endAnimation(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  },
      _callback = function _callback(self, func) {
    if (self.enabled) {
      var result = self._ctx ? self._ctx.add(function () {
        return func(self);
      }) : func(self);
      result && result.totalTime && (self.callbackAnimation = result);
    }
  },
      _abs = Math.abs,
      _left = "left",
      _top = "top",
      _right = "right",
      _bottom = "bottom",
      _width = "width",
      _height = "height",
      _Right = "Right",
      _Left = "Left",
      _Top = "Top",
      _Bottom = "Bottom",
      _padding = "padding",
      _margin = "margin",
      _Width = "Width",
      _Height = "Height",
      _px = "px",
      _getComputedStyle = function _getComputedStyle(element) {
    return _win.getComputedStyle(element);
  },
      _makePositionable = function _makePositionable(element) {
    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
    var position = _getComputedStyle(element).position;

    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  },
      _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }

    return obj;
  },
      _getBounds = function _getBounds(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$1.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1),
        bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  },
      _getSize = function _getSize(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  },
      _getLabelRatioArray = function _getLabelRatioArray(timeline) {
    var a = [],
        labels = timeline.labels,
        duration = timeline.duration(),
        p;

    for (p in labels) {
      a.push(labels[p] / duration);
    }

    return a;
  },
      _getClosestLabel = function _getClosestLabel(animation) {
    return function (value) {
      return gsap$1.utils.snap(_getLabelRatioArray(animation), value);
    };
  },
      _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
    var snap = gsap$1.utils.snap(snapIncrementOrArray),
        a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
      return a - b;
    });
    return a ? function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }

      var i;

      if (!direction) {
        return snap(value);
      }

      if (direction > 0) {
        value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }

        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;

        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }

      return a[0];
    } : function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }

      var snapped = snap(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  },
      _getLabelAtDirection = function _getLabelAtDirection(timeline) {
    return function (value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
    };
  },
      _multiListener = function _multiListener(func, element, types, callback) {
    return types.split(",").forEach(function (type) {
      return func(element, type, callback);
    });
  },
      _addListener = function _addListener(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  },
      _removeListener = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
      _wheelListener = function _wheelListener(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;

    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  },
      _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  },
      _defaults = {
    toggleActions: "play",
    anticipatePin: 0
  },
      _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  },
      _offsetToPx = function _offsetToPx(value, size) {
    if (_isString$1(value)) {
      var eqIndex = value.indexOf("="),
          relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }

      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }

    return value;
  },
      _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor,
        endColor = _ref4.endColor,
        fontSize = _ref4.fontSize,
        indent = _ref4.indent,
        fontWeight = _ref4.fontWeight;

    var e = _doc.createElement("div"),
        useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
        isScroller = type.indexOf("scroller") !== -1,
        parent = useFixedPosition ? _body$1 : container,
        isStart = type.indexOf("start") !== -1,
        color = isStart ? startColor : endColor,
        css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];

    _positionMarker(e, 0, direction, isStart);

    return e;
  },
      _positionMarker = function _positionMarker(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    },
        side = direction[flipped ? "os2" : "p2"],
        oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap$1.set(marker, vars);
  },
      _triggers = [],
      _ids = {},
      _rafID,
      _sync = function _sync() {
    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  },
      _onScroll = function _onScroll() {
    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body$1.clientWidth) {
      // if the user is dragging the scrollbar, allow it.
      _scrollers.cache++;

      if (_normalizer) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110

      }

      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    }
  },
      _setBaseDimensions = function _setBaseDimensions() {
    _baseScreenWidth = _win.innerWidth;
    _baseScreenHeight = _win.innerHeight;
  },
      _onResize = function _onResize(force) {
    _scrollers.cache++;
    (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25)) && _resizeDelay.restart(true);
  },
      // ignore resizes triggered by refresh()
  _listeners = {},
      _emptyArray = [],
      _softRefresh = function _softRefresh() {
    return _removeListener(ScrollTrigger$1, "scrollEnd", _softRefresh) || _refreshAll(true);
  },
      _dispatch = function _dispatch(type) {
    return _listeners[type] && _listeners[type].map(function (f) {
      return f();
    }) || _emptyArray;
  },
      _savedStyles = [],
      // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
  _revertRecorded = function _revertRecorded(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  },
      _recordScrollPositions = function _recordScrollPositions() {
    return _scrollers.forEach(function (obj) {
      return _isFunction$1(obj) && ++obj.cacheID && (obj.rec = obj());
    });
  },
      // record the current scroll position. Also force the clearing of the cache because some browsers take a little while to dispatch the "scroll" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away
  _revertAll = function _revertAll(kill, media) {
    var trigger;

    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];

      if (trigger && (!media || trigger._ctx === media)) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }

    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch("revert");
  },
      _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function (obj) {
      return _isFunction$1(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString$1(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  },
      _refreshingAll,
      _refreshID = 0,
      _queueRefreshID,
      _queueRefreshAll = function _queueRefreshAll() {
    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's "load" or "DOMContentLoaded" events to trigger it.
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function () {
        return id === _refreshID && _refreshAll(true);
      });
    }
  },
      _refresh100vh = function _refresh100vh() {
    _body$1.appendChild(_div100vh);

    _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;

    _body$1.removeChild(_div100vh);
  },
      _hideAllMarkers = function _hideAllMarkers(hide) {
    return _toArray$1(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (el) {
      return el.style.display = hide ? "none" : "block";
    });
  },
      _refreshAll = function _refreshAll(force, skipRevert) {
    _docEl$1 = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).

    _body$1 = _doc.body;
    _root = [_win, _doc, _docEl$1, _body$1];

    if (_lastScrollTime && !force && !_isReverted) {
      _addListener(ScrollTrigger$1, "scrollEnd", _softRefresh);

      return;
    }

    _refresh100vh();

    _refreshingAll = ScrollTrigger$1.isRefreshing = true;
    _isReverted || _recordScrollPositions();

    var refreshInits = _dispatch("refreshInit");

    _sort && ScrollTrigger$1.sort();
    skipRevert || _revertAll();

    _scrollers.forEach(function (obj) {
      if (_isFunction$1(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto"); // smooth scrolling interferes

        obj(0);
      }
    });

    _triggers.slice(0).forEach(function (t) {
      return t.refresh();
    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


    _isReverted = false;

    _triggers.forEach(function (t) {
      // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
            original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.refresh();
      }
    });

    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.

    _hideAllMarkers(true);

    _triggers.forEach(function (t) {
      // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max". Same for anything with a clamped end
      var max = _maxScroll(t.scroller, t._dir),
          endClamp = t.vars.end === "max" || t._endClamp && t.end > max,
          startClamp = t._startClamp && t.start >= max;

      (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
    });

    _hideAllMarkers(false);

    _clampingMax = 0;
    refreshInits.forEach(function (result) {
      return result && result.render && result.render(-1);
    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

    _scrollers.forEach(function (obj) {
      if (_isFunction$1(obj)) {
        obj.smooth && requestAnimationFrame(function () {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });

    _clearScrollMemory(_scrollRestoration, 1);

    _resizeDelay.pause();

    _refreshID++;
    _refreshingAll = 2;

    _updateAll(2);

    _triggers.forEach(function (t) {
      return _isFunction$1(t.vars.onRefresh) && t.vars.onRefresh(t);
    });

    _refreshingAll = ScrollTrigger$1.isRefreshing = false;

    _dispatch("refresh");
  },
      _lastScroll = 0,
      _direction = 1,
      _primary,
      _updateAll = function _updateAll(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.
      ScrollTrigger$1.isUpdating = true;
      _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

      var l = _triggers.length,
          time = _getTime(),
          recordVelocity = time - _time1 >= 50,
          scroll = l && _triggers[0].scroll();

      _direction = _lastScroll > scroll ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll);

      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;

          _dispatch("scrollEnd");
        }

        _time2 = _time1;
        _time1 = time;
      }

      if (_direction < 0) {
        _i = l;

        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }

        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }

      ScrollTrigger$1.isUpdating = false;
    }

    _rafID = 0;
  },
      _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
      _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
      _swapPinOut = function _swapPinOut(pin, spacer, state) {
    _setState(state);

    var cache = pin._gsap;

    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;

      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }

    pin._gsap.swappedIn = false;
  },
      _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length,
          spacerStyle = spacer.style,
          pinStyle = pin.style,
          p;

      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }

      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

      _setState(spacerState);

      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];

      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }

      pin._gsap.swappedIn = true;
    }
  },
      _capsExp = /([A-Z])/g,
      _setState = function _setState(state) {
    if (state) {
      var style = state.t.style,
          l = state.length,
          i = 0,
          p,
          value;
      (state.t._gsap || gsap$1.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];

        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
        }
      }
    }
  },
      _getState = function _getState(element) {
    // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
    var l = _stateProps.length,
        style = element.style,
        state = [],
        i = 0;

    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }

    state.t = element;
    return state;
  },
      _copyState = function _copyState(state, override, omitOffsets) {
    var result = [],
        l = state.length,
        i = omitOffsets ? 8 : 0,
        // skip top, left, right, bottom if omitOffsets is true
    p;

    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }

    result.t = state.t;
    return result;
  },
      _winOffsets = {
    left: 0,
    top: 0
  },
      // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
  // _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
  // 	scroller = _getTarget(scroller || _win);
  // 	let direction = horizontal ? _horizontal : _vertical,
  // 		isViewport = _isViewport(scroller);
  // 	_getSizeFunc(scroller, isViewport, direction);
  // 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
  // },
  _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction$1(value) && (value = value(self));

    if (_isString$1(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }

    var time = containerAnimation ? containerAnimation.time() : 0,
        p1,
        p2,
        element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value); // convert a string number like "45" to an actual number

    if (!_isNumber(value)) {
      _isFunction$1(trigger) && (trigger = trigger(self));
      var offsets = (value || "0").split(" "),
          bounds,
          localOffset,
          globalOffset,
          display;
      element = _getTarget(trigger, self) || _body$1;
      bounds = _getBounds(element) || {};

      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        // if display is "none", it won't report getBoundingClientRect() properly
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }

      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
    } else {
      containerAnimation && (value = gsap$1.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }

    if (clampZeroProp) {
      self[clampZeroProp] = value || -0.001;
      value < 0 && (value = 0);
    }

    if (marker) {
      var position = value + scrollerSize,
          isStart = marker._isStart;
      p1 = "scroll" + direction.d2;

      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body$1[p1], _docEl$1[p1]) : marker.parentNode[p1]) <= position + 1);

      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }

    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }

    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  },
      _prefixExp = /(webkit|moz|length|cssText|inset)/i,
      _reparent = function _reparent(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style,
          p,
          cs;

      if (parent === _body$1) {
        element._stOrig = style.cssText; // record original inline styles so we can revert them later

        cs = _getComputedStyle(element);

        for (p in cs) {
          // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }

        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }

      gsap$1.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  },
      _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue,
        last2 = last1;
    return function (value) {
      var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.

      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        value = current;
        onInterrupt && onInterrupt();
      }

      last2 = last1;
      last1 = Math.round(value);
      return last1;
    };
  },
      _shiftMarker = function _shiftMarker(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap$1.set(marker, vars);
  },
      // _mergeAnimations = animations => {
  // 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
  // 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
  // 	tl.smoothChildTiming = false;
  // 	return tl;
  // },
  // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
  _getTweenCreator = function _getTweenCreator(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction),
        prop = "_scroll" + direction.p2,
        // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween.tween,
          onComplete = vars.onComplete,
          modifiers = {};
      initialValue = initialValue || getScroll();

      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function () {
        tween.kill();
        getTween.tween = 0;
      });

      change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;

      modifiers[prop] = function () {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };

      vars.onUpdate = function () {
        _scrollers.cache++;
        getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()
      };

      vars.onComplete = function () {
        getTween.tween = 0;
        onComplete && onComplete.call(tween);
      };

      tween = getTween.tween = gsap$1.to(scroller, vars);
      return tween;
    };

    scroller[prop] = getScroll;

    getScroll.wheelHandler = function () {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };

    _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


    ScrollTrigger$1.isTouch && _addListener(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };

  var ScrollTrigger$1 = /*#__PURE__*/function () {
    function ScrollTrigger(vars, animation) {
      _coreInitted$1 || ScrollTrigger.register(gsap$1) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");

      _context(this);

      this.init(vars, animation);
    }

    var _proto = ScrollTrigger.prototype;

    _proto.init = function init(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true); // in case it's being initted again

      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough;
        return;
      }

      vars = _setDefaults(_isString$1(vars) || _isNumber(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults);

      var _vars = vars,
          onUpdate = _vars.onUpdate,
          toggleClass = _vars.toggleClass,
          id = _vars.id,
          onToggle = _vars.onToggle,
          onRefresh = _vars.onRefresh,
          scrub = _vars.scrub,
          trigger = _vars.trigger,
          pin = _vars.pin,
          pinSpacing = _vars.pinSpacing,
          invalidateOnRefresh = _vars.invalidateOnRefresh,
          anticipatePin = _vars.anticipatePin,
          onScrubComplete = _vars.onScrubComplete,
          onSnapComplete = _vars.onSnapComplete,
          once = _vars.once,
          snap = _vars.snap,
          pinReparent = _vars.pinReparent,
          pinSpacer = _vars.pinSpacer,
          containerAnimation = _vars.containerAnimation,
          fastScrollEnd = _vars.fastScrollEnd,
          preventOverlaps = _vars.preventOverlaps,
          direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
          isToggle = !scrub && scrub !== 0,
          scroller = _getTarget(vars.scroller || _win),
          scrollerCache = gsap$1.core.getCache(scroller),
          isViewport = _isViewport(scroller),
          useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
          callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
          toggleActions = isToggle && vars.toggleActions.split(" "),
          markers = "markers" in vars ? vars.markers : _defaults.markers,
          borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
          self = this,
          onRefreshInit = vars.onRefreshInit && function () {
        return vars.onRefreshInit(self);
      },
          getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
          getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
          lastSnap = 0,
          lastRefresh = 0,
          prevProgress = 0,
          scrollFunc = _getScrollFunc(scroller, direction),
          tweenTo,
          pinCache,
          snapFunc,
          scroll1,
          scroll2,
          start,
          end,
          markerStart,
          markerEnd,
          markerStartTrigger,
          markerEndTrigger,
          markerVars,
          executingOnRefresh,
          change,
          pinOriginalState,
          pinActiveState,
          pinState,
          spacer,
          offset,
          pinGetter,
          pinSetter,
          pinStart,
          pinChange,
          spacingStart,
          spacerState,
          markerStartSetter,
          pinMoves,
          markerEndSetter,
          cs,
          snap1,
          snap2,
          scrubTween,
          scrubSmooth,
          snapDurClamp,
          snapDelayedCall,
          prevScroll,
          prevAnimProgress,
          caMarkerSetter,
          customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start="clamp(top bottom)" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.


      self._startClamp = self._endClamp = false;
      self._dir = direction;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self.vars = vars;
      animation = animation || vars.animation;

      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
      }

      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

      self.scrubDuration = function (value) {
        scrubSmooth = _isNumber(value) && value;

        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap$1.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self);
            }
          });
        }
      };

      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010

        self.animation = animation.pause();
        animation.scrollTrigger = self;
        self.scrubDuration(scrub);
        snap1 = 0;
        id || (id = animation.vars.id);
      }

      if (snap) {
        // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.
        if (!_isObject(snap) || snap.push) {
          snap = {
            snapTo: snap
          };
        }

        "scrollBehavior" in _body$1.style && gsap$1.set(isViewport ? [_body$1, _docEl$1] : scroller, {
          scrollBehavior: "auto"
        }); // smooth scrolling doesn't work with snap.

        _scrollers.forEach(function (o) {
          return _isFunction$1(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl$1 : scroller) && (o.smooth = false);
        }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters


        snapFunc = _isFunction$1(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
          return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap$1.utils.snap(snap.snapTo);
        snapDurClamp = snap.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap$1.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
          var scroll = scrollFunc(),
              refreshedRecently = _getTime() - lastRefresh < 500,
              tween = tweenTo.tween;

          if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change,
                totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
                change1 = gsap$1.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                naturalEnd = progress + (snap.inertia === false ? 0 : change1),
                endValue,
                endScroll,
                _snap = snap,
                onStart = _snap.onStart,
                _onInterrupt = _snap.onInterrupt,
                _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self);
            _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd

            endScroll = Math.max(0, Math.round(start + endValue * change));

            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
                return;
              }

              if (snap.inertia === false) {
                change1 = endValue - progress;
              }

              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap.ease || "power3",
                data: _abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  self.update();
                  lastSnap = scrollFunc();

                  if (animation && !isToggle) {
                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }

                  snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }

      id && (_ids[id] = self);
      trigger = self.trigger = _getTarget(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString$1(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });

      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)

        self.pin = pin;
        pinCache = gsap$1.core.getCache(pin);

        if (!pinCache.spacer) {
          // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }

          pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }

        vars.force3D !== false && gsap$1.set(pin, {
          force3D: true
        });
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap$1.getProperty(pin);
        pinSetter = gsap$1.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin);
      }

      if (markers) {
        markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];

        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);

        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap$1.quickSetter([markerStart, markerEnd], direction.a, _px));

        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body$1 : scroller);

          gsap$1.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap$1.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap$1.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }

      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate,
            oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function () {
          self.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }

      self.previous = function () {
        return _triggers[_triggers.indexOf(self) - 1];
      };

      self.next = function () {
        return _triggers[_triggers.indexOf(self) + 1];
      };

      self.revert = function (revert, temp) {
        if (!temp) {
          return self.kill(true);
        } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()


        var r = revert !== false || !self.enabled,
            prevRefreshing = _refreshing;

        if (r !== self.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }

          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.style.display = r ? "none" : "block";
          });

          if (r) {
            _refreshing = self;
            self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out
          }

          if (pin && (!pinReparent || !self.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }

          r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.

          _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.

          self.isReverted = r;
        }
      };

      self.refresh = function (soft, force, position, pinOffset) {
        // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }

        if (pin && soft && _lastScrollTime) {
          _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

          return;
        }

        !_refreshingAll && onRefreshInit && onRefreshInit(self);
        _refreshing = self;

        if (tweenTo.tween && !position) {
          // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }

        scrubTween && scrubTween.pause();

        if (invalidateOnRefresh && animation) {
          animation.revert({
            kill: false
          }).invalidate();
          animation.getChildren ? animation.getChildren(true, true, false).forEach(function (t) {
            return t.vars.immediateRender && t.render(0, true, true);
          }) : animation.vars.immediateRender && animation.render(0, true, true); // any from() or fromTo() tweens should render immediately (well, unless they have immediateRender: false)
        }

        self.isReverted || self.revert(true, true);
        self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any

        var size = getScrollerSize(),
            scrollerBounds = getScrollerOffsets(),
            max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
            isFirstRefresh = change <= 0.01 || !change,
            offset = 0,
            otherPinOffset = pinOffset || 0,
            parsedEnd = _isObject(position) ? position.end : vars.end,
            parsedEndTrigger = vars.endTrigger || trigger,
            parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
            pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self),
            triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
            i = triggerIndex,
            cs,
            bounds,
            scroll,
            isVertical,
            override,
            curTrigger,
            curPin,
            oppositeScroll,
            initted,
            revertedPins,
            forcedOverflow,
            markerStartOffset,
            markerEndOffset;

        if (markers && _isObject(position)) {
          // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.
          markerStartOffset = gsap$1.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap$1.getProperty(markerEndTrigger, direction.p);
        }

        while (i-- > 0) {
          // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

          curPin = curTrigger.pin;

          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

            curTrigger.revert(true, true);
          }

          if (curTrigger !== _triggers[i]) {
            // in case it got removed.
            triggerIndex--;
            i--;
          }
        }

        _isFunction$1(parsedStart) && (parsedStart = parsedStart(self));
        parsedStart = _parseClamp(parsedStart, "start", self);
        start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -0.001 : 0);
        _isFunction$1(parsedEnd) && (parsedEnd = parsedEnd(self));

        if (_isString$1(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString$1(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString$1(parsedStart) ? parsedStart : (containerAnimation ? gsap$1.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

            parsedEndTrigger = trigger;
          }
        }

        parsedEnd = _parseClamp(parsedEnd, "end", self);
        end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -0.001;
        offset = 0;
        i = triggerIndex;

        while (i--) {
          curTrigger = _triggers[i] || {};
          curPin = curTrigger.pin;

          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);

            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              // numeric start values shouldn't be offset at all - treat them as absolute
              offset += cs * (1 - curTrigger.progress);
            }

            curPin === pin && (otherPinOffset += cs);
          }
        }

        start += offset;
        end += offset;
        self._startClamp && (self._startClamp += offset);

        if (self._endClamp && !_refreshingAll) {
          self._endClamp = end || -0.001;
          end = Math.min(end, _maxScroll(scroller, direction));
        }

        change = end - start || (start -= 0.01) && 0.001;

        if (isFirstRefresh) {
          // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.
          prevProgress = gsap$1.utils.clamp(0, 1, gsap$1.utils.normalize(start, end, prevScroll));
        }

        self._pinPush = otherPinOffset;

        if (markerStart && offset) {
          // offset the markers if necessary
          cs = {};
          cs[direction.a] = "+=" + offset;
          pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
          gsap$1.set([markerStart, markerEnd], cs);
        }

        if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
          cs = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;

          if (!max && end > 1) {
            // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
            forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl$1 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };

            if (isViewport && _getComputedStyle(_body$1)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to "scroll"
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }

          _swapPinIn(pin, spacer, cs);

          pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;

            if (i) {
              spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
            }

            _setState(spacerState);

            if (pinnedContainer) {
              // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.
              _triggers.forEach(function (t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }

            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i = _getSize(pin, direction);
            i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
          }

          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs[_padding];
            override[_padding + _Top] = cs[_padding + _Top];
            override[_padding + _Right] = cs[_padding + _Right];
            override[_padding + _Bottom] = cs[_padding + _Bottom];
            override[_padding + _Left] = cs[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }

          if (animation) {
            // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
            initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

            _suppressOverwrites(1);

            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.

            _suppressOverwrites(0);
          } else {
            pinChange = change;
          }

          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
          bounds = trigger.parentNode;

          while (bounds && bounds !== _body$1) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }

            bounds = bounds.parentNode;
          }
        }

        revertedPins && revertedPins.forEach(function (t) {
          return t.revert(false, true);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity

        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self.scroll.rec = 0;
        }

        self.revert(false, true);
        lastRefresh = _getTime();

        if (snapDelayedCall) {
          lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value
          // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.

          snapDelayedCall.restart(true);
        }

        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

        if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {
          // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
          animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap$1.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

          self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }

        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        scrubTween && scrubTween.invalidate();

        if (!isNaN(markerStartOffset)) {
          // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like "top", "center", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.
          markerStartOffset -= gsap$1.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap$1.getProperty(markerEndTrigger, direction.p);

          _shiftMarker(markerStartTrigger, direction, markerStartOffset);

          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));

          _shiftMarker(markerEndTrigger, direction, markerEndOffset);

          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }

        isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a "scroll" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.

        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.
          executingOnRefresh = true;
          onRefresh(self);
          executingOnRefresh = false;
        }
      };

      self.getVelocity = function () {
        return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
      };

      self.endAnimation = function () {
        _endAnimation(self.callbackAnimation);

        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
        }
      };

      self.labelToScroll = function (label) {
        return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };

      self.getTrailing = function (name) {
        var i = _triggers.indexOf(self),
            a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

        return (_isString$1(name) ? a.filter(function (t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function (t) {
          return self.direction > 0 ? t.end <= start : t.start >= end;
        });
      };

      self.update = function (reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }

        var scroll = _refreshingAll === true ? prevScroll : self.scroll(),
            p = reset ? 0 : (scroll - start) / change,
            clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
            prevProgress = self.progress,
            isActive,
            wasActive,
            toggleState,
            action,
            stateChanged,
            toggled,
            isAtMax,
            isTakingAction;

        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;

          if (snap) {
            snap2 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


        if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {
          if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
            clipped = 0.0001;
          } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }

        if (clipped !== prevProgress && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress && prevProgress < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

          self.direction = clipped > prevProgress ? 1 : -1;
          self.progress = clipped;

          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }

          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction$1(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
            return t.endAnimation();
          }));

          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                // legacy support (courtesy), before 3.10.0
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }

          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

            if (!useFixedPosition) {
              pinSetter(_round(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true),
                      _offset = scroll - start;

                  _reparent(pin, _body$1, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }

              _setState(isActive || isAtMax ? pinActiveState : pinState);

              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }

          snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray$1(toggleClass.targets).forEach(function (el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          }); // classes could affect positioning, so do it even if reset or refreshing is true.

          onUpdate && !isToggle && !reset && onUpdate(self);

          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }

              onUpdate && onUpdate(self);
            }

            if (toggled || !_limitCallbacks) {
              // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
              onToggle && toggled && _callback(self, onToggle);
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

              if (!toggled) {
                // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              }
            }

            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self.callbackAnimation);

              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        } // update absolutely-positioned markers (only if the scroller isn't the viewport)


        if (markerEndSetter) {
          var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }

        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };

      self.enable = function (reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;

          _addListener(scroller, "resize", _onResize);

          isViewport || _addListener(scroller, "scroll", _onScroll);
          onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }

          refresh !== false && self.refresh();
        }
      };

      self.getTween = function (snap) {
        return snap && tweenTo ? tweenTo.tween : scrubTween;
      };

      self.setPositions = function (newStart, newEnd, keepClamp, pinOffset) {
        // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
        if (containerAnimation) {
          // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.
          var st = containerAnimation.scrollTrigger,
              duration = containerAnimation.duration(),
              _change = st.end - st.start;

          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }

        self.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
        }, pinOffset);
        self.update();
      };

      self.adjustPinSpacing = function (amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;

          _setState(spacerState);
        }
      };

      self.disable = function (reset, allowAnimation) {
        reset !== false && self.revert(true, true);

        if (self.enabled) {
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }

          if (!isViewport) {
            var i = _triggers.length;

            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                return; //don't remove the listeners if there are still other triggers referencing it.
              }
            }

            _removeListener(scroller, "resize", _onResize);

            isViewport || _removeListener(scroller, "scroll", _onScroll);
          }
        }
      };

      self.kill = function (revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];

        var i = _triggers.indexOf(self);

        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
        // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

        i = 0;

        _triggers.forEach(function (t) {
          return t.scroller === self.scroller && (i = 1);
        });

        i || _refreshingAll || (self.scroll.rec = 0);

        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self && (_primary = 0);

        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;

          _triggers.forEach(function (t) {
            return t.pin === pin && i++;
          });

          i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
        }

        vars.onKill && vars.onKill(self);
      };

      _triggers.push(self);

      self.enable(false, false);
      customRevertReturn && customRevertReturn(self);

      if (animation && animation.add && !change) {
        // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
        var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().

        self.update = function () {
          self.update = updateFunc;
          _scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/

          start || end || self.refresh();
        };

        gsap$1.delayedCall(0.01, self.update);
        change = 0.01;
        start = end = 0;
      } else {
        self.refresh();
      }

      pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()
    };

    ScrollTrigger.register = function register(core) {
      if (!_coreInitted$1) {
        gsap$1 = core || _getGSAP$1();
        _windowExists$1() && window.document && ScrollTrigger.enable();
        _coreInitted$1 = _enabled;
      }

      return _coreInitted$1;
    };

    ScrollTrigger.defaults = function defaults(config) {
      if (config) {
        for (var p in config) {
          _defaults[p] = config[p];
        }
      }

      return _defaults;
    };

    ScrollTrigger.disable = function disable(reset, kill) {
      _enabled = 0;

      _triggers.forEach(function (trigger) {
        return trigger[kill ? "kill" : "disable"](reset);
      });

      _removeListener(_win, "wheel", _onScroll);

      _removeListener(_doc, "scroll", _onScroll);

      clearInterval(_syncInterval);

      _removeListener(_doc, "touchcancel", _passThrough);

      _removeListener(_body$1, "touchstart", _passThrough);

      _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

      _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

      _resizeDelay.kill();

      _iterateAutoRefresh(_removeListener);

      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

        _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
      }
    };

    ScrollTrigger.enable = function enable() {
      _win = window;
      _doc = document;
      _docEl$1 = _doc.documentElement;
      _body$1 = _doc.body;

      if (gsap$1) {
        _toArray$1 = gsap$1.utils.toArray;
        _clamp = gsap$1.utils.clamp;
        _context = gsap$1.core.context || _passThrough;
        _suppressOverwrites = gsap$1.core.suppressOverwrites || _passThrough;
        _scrollRestoration = _win.history.scrollRestoration || "auto";
        _lastScroll = _win.pageYOffset || 0;
        gsap$1.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

        if (_body$1) {
          _enabled = 1;
          _div100vh = document.createElement("div"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.

          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";

          _refresh100vh();

          _rafBugFix();

          Observer$1.register(gsap$1); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

          ScrollTrigger.isTouch = Observer$1.isTouch;
          _fixIOSBug = Observer$1.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

          _ignoreMobileResize = Observer$1.isTouch === 1;

          _addListener(_win, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.


          _root = [_win, _doc, _docEl$1, _body$1];

          if (gsap$1.matchMedia) {
            ScrollTrigger.matchMedia = function (vars) {
              var mm = gsap$1.matchMedia(),
                  p;

              for (p in vars) {
                mm.add(p, vars[p]);
              }

              return mm;
            };

            gsap$1.addEventListener("matchMediaInit", function () {
              _recordScrollPositions();

              _revertAll();
            });
            gsap$1.addEventListener("matchMediaRevert", function () {
              return _revertRecorded();
            });
            gsap$1.addEventListener("matchMedia", function () {
              _refreshAll(0, 1);

              _dispatch("matchMedia");
            });
            gsap$1.matchMedia().add("(orientation: portrait)", function () {
              // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
              _setBaseDimensions();

              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }

          _setBaseDimensions();

          _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


          var bodyHasStyle = _body$1.hasAttribute("style"),
              bodyStyle = _body$1.style,
              border = bodyStyle.borderTopStyle,
              AnimationProto = gsap$1.core.Animation.prototype,
              bounds,
              i;

          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)

          bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

          bounds = _getBounds(_body$1);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");

          if (!bodyHasStyle) {
            // SSR frameworks like Next.js complain if this attribute gets added.
            _body$1.setAttribute("style", ""); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.


            _body$1.removeAttribute("style");
          } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.


          _syncInterval = setInterval(_sync, 250);
          gsap$1.delayedCall(0.5, function () {
            return _startup = 0;
          });

          _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


          _addListener(_body$1, "touchstart", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

          _transformProp = gsap$1.utils.checkPrefix("transform");

          _stateProps.push(_transformProp);

          _coreInitted$1 = _getTime();
          _resizeDelay = gsap$1.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc, "visibilitychange", function () {
            var w = _win.innerWidth,
                h = _win.innerHeight;

            if (_doc.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];

          _iterateAutoRefresh(_addListener);

          _triggers.forEach(function (trigger) {
            return trigger.enable(0, 1);
          });

          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

            _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };

    ScrollTrigger.config = function config(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };

    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target),
          i = _scrollers.indexOf(t),
          isViewport = _isViewport(t);

      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }

      if (vars) {
        isViewport ? _proxies.unshift(_win, vars, _body$1, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
      }
    };

    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function (t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };

    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString$1(element) ? _getTarget(element) : element).getBoundingClientRect(),
          offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
    };

    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString$1(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(),
          size = bounds[horizontal ? _width : _height],
          offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
    };

    ScrollTrigger.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function (t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });

      if (allowListeners !== true) {
        var listeners = _listeners.killAll || [];
        _listeners = {};
        listeners.forEach(function (f) {
          return f();
        });
      }
    };

    return ScrollTrigger;
  }();
  ScrollTrigger$1.version = "3.14.2";

  ScrollTrigger$1.saveStyles = function (targets) {
    return targets ? _toArray$1(targets).forEach(function (target) {
      // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);

        i >= 0 && _savedStyles.splice(i, 5);

        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap$1.core.getCache(target), _context());
      }
    }) : _savedStyles;
  };

  ScrollTrigger$1.revert = function (soft, media) {
    return _revertAll(!soft, media);
  };

  ScrollTrigger$1.create = function (vars, animation) {
    return new ScrollTrigger$1(vars, animation);
  };

  ScrollTrigger$1.refresh = function (safe) {
    return safe ? _onResize(true) : (_coreInitted$1 || ScrollTrigger$1.register()) && _refreshAll(true);
  };

  ScrollTrigger$1.update = function (force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };

  ScrollTrigger$1.clearScrollMemory = _clearScrollMemory;

  ScrollTrigger$1.maxScroll = function (element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };

  ScrollTrigger$1.getScrollFunc = function (element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };

  ScrollTrigger$1.getById = function (id) {
    return _ids[id];
  };

  ScrollTrigger$1.getAll = function () {
    return _triggers.filter(function (t) {
      return t.vars.id !== "ScrollSmoother";
    });
  }; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


  ScrollTrigger$1.isScrolling = function () {
    return !!_lastScrollTime;
  };

  ScrollTrigger$1.snapDirectional = _snapDirectional;

  ScrollTrigger$1.addEventListener = function (type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };

  ScrollTrigger$1.removeEventListener = function (type, callback) {
    var a = _listeners[type],
        i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };

  ScrollTrigger$1.batch = function (targets, vars) {
    var result = [],
        varsCopy = {},
        interval = vars.interval || 0.016,
        batchMax = vars.batchMax || 1e9,
        proxyCallback = function proxyCallback(type, callback) {
      var elements = [],
          triggers = [],
          delay = gsap$1.delayedCall(interval, function () {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function (self) {
        elements.length || delay.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay.progress(1);
      };
    },
        p;

    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction$1(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }

    if (_isFunction$1(batchMax)) {
      batchMax = batchMax();

      _addListener(ScrollTrigger$1, "refresh", function () {
        return batchMax = vars.batchMax();
      });
    }

    _toArray$1(targets).forEach(function (target) {
      var config = {};

      for (p in varsCopy) {
        config[p] = varsCopy[p];
      }

      config.trigger = target;
      result.push(ScrollTrigger$1.create(config));
    });

    return result;
  }; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  },
      _allowNativePanning = function _allowNativePanning(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer$1.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
    }

    target === _docEl$1 && _allowNativePanning(_body$1, direction);
  },
      _overflow = {
    auto: 1,
    scroll: 1
  },
      _nestedScroll = function _nestedScroll(_ref5) {
    var event = _ref5.event,
        target = _ref5.target,
        axis = _ref5.axis;

    var node = (event.changedTouches ? event.changedTouches[0] : event).target,
        cache = node._gsap || gsap$1.core.getCache(node),
        time = _getTime(),
        cs;

    if (!cache._isScrollT || time - cache._isScrollT > 2000) {
      // cache for 2 seconds to improve performance.
      while (node && node !== _body$1 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }

      cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time;
    }

    if (cache._isScroll || axis === "x") {
      event.stopPropagation();
      event._gsapAllow = true;
    }
  },
      // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
  _inputObserver = function _inputObserver(target, type, inputs, nested) {
    return Observer$1.create({
      target: target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type: type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener(_doc, Observer$1.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener(_doc, Observer$1.eventTypes[0], _captureInputs, true);
      }
    });
  },
      _inputExp = /(input|label|select|textarea)/i,
      _inputIsFocused,
      _captureInputs = function _captureInputs(e) {
    var isInput = _inputExp.test(e.target.tagName);

    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  },
      _getScrollNormalizer = function _getScrollNormalizer(vars) {
    _isObject(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";

    var _vars2 = vars,
        normalizeScrollX = _vars2.normalizeScrollX,
        momentum = _vars2.momentum,
        allowNestedScroll = _vars2.allowNestedScroll,
        onRelease = _vars2.onRelease,
        self,
        maxY,
        target = _getTarget(vars.target) || _docEl$1,
        smoother = gsap$1.core.globals().ScrollSmoother,
        smootherInstance = smoother && smoother.get(),
        content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scale = 1,
        initialScale = (Observer$1.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
        wheelRefresh = 0,
        resolveMomentumDuration = _isFunction$1(momentum) ? function () {
      return momentum(self);
    } : function () {
      return momentum || 2.8;
    },
        lastRefreshID,
        skipTouchMove,
        inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
        resumeTouchMove = function resumeTouchMove() {
      return skipTouchMove = false;
    },
        scrollClampX = _passThrough,
        scrollClampY = _passThrough,
        updateClamps = function updateClamps() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    },
        removeContentOffset = function removeContentOffset() {
      content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    },
        ignoreDrag = function ignoreDrag() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);

        var offset = _round(self.deltaY / 2),
            scroll = scrollClampY(scrollFuncY.v - offset);

        if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll - scrollFuncY.v;

          var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);

          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
          content._gsap.y = y + "px";
          scrollFuncY.cacheID = _scrollers.cache;

          _updateAll();
        }

        return true;
      }

      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    },
        tween,
        startScrollX,
        startScrollY,
        onStopDelayedCall,
        onResize = function onResize() {
      // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
      updateClamps();

      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };

    content && gsap$1.set(content, {
      y: "+=0"
    }); // to ensure there's a cache (element._gsap)

    vars.ignoreCheck = function (e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
    };

    vars.onPress = function () {
      skipTouchMove = false;
      var prevScale = scale;
      scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };

    vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
      scrollFuncY.offset && removeContentOffset();

      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++; // make sure we're pulling the non-cached value
        // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

        var dur = resolveMomentumDuration(),
            currentScroll,
            endScroll;

        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }

        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);

        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
          gsap$1.to({}, {
            onUpdate: onResize,
            duration: dur
          });
        }
      }

      onRelease && onRelease(self);
    };

    vars.onWheel = function () {
      tween._ts && tween.pause();

      if (_getTime() - wheelRefresh > 1000) {
        // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
        lastRefreshID = 0;
        wheelRefresh = _getTime();
      }
    };

    vars.onChange = function (self, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy,
            y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
            yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }

      (dy || dx) && _updateAll();
    };

    vars.onEnable = function () {
      _allowNativePanning(target, normalizeScrollX ? false : "x");

      ScrollTrigger$1.addEventListener("refresh", onResize);

      _addListener(_win, "resize", onResize);

      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }

      inputObserver.enable();
    };

    vars.onDisable = function () {
      _allowNativePanning(target, true);

      _removeListener(_win, "resize", onResize);

      ScrollTrigger$1.removeEventListener("refresh", onResize);
      inputObserver.kill();
    };

    vars.lockAxis = vars.lockAxis !== false;
    self = new Observer$1(vars);
    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

    _fixIOSBug && gsap$1.ticker.add(_passThrough); // prevent the ticker from sleeping

    onStopDelayedCall = self._dc;
    tween = gsap$1.to(self, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function () {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.

    return self;
  };

  ScrollTrigger$1.sort = function (func) {
    if (_isFunction$1(func)) {
      return _triggers.sort(func);
    }

    var scroll = _win.pageYOffset || 0;
    ScrollTrigger$1.getAll().forEach(function (t) {
      return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win.innerHeight;
    });
    return _triggers.sort(func || function (a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);
    }); // anything with a containerAnimation should refresh last.
  };

  ScrollTrigger$1.observe = function (vars) {
    return new Observer$1(vars);
  };

  ScrollTrigger$1.normalizeScroll = function (vars) {
    if (typeof vars === "undefined") {
      return _normalizer;
    }

    if (vars === true && _normalizer) {
      return _normalizer.enable();
    }

    if (vars === false) {
      _normalizer && _normalizer.kill();
      _normalizer = vars;
      return;
    }

    var normalizer = vars instanceof Observer$1 ? vars : _getScrollNormalizer(vars);
    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
    _isViewport(normalizer.target) && (_normalizer = normalizer);
    return normalizer;
  };

  ScrollTrigger$1.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp: _getVelocityProp,
    _inputObserver: _inputObserver,
    _scrollers: _scrollers,
    _proxies: _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP$1() && gsap$1.registerPlugin(ScrollTrigger$1);

  document.head.appendChild(document.createElement("style")).textContent="/*! \n * OverlayScrollbars\n * Version: 2.13.0\n * \n * Copyright (c) Rene Haas | KingSora.\n * https://github.com/KingSora\n * \n * Released under the MIT license.\n */\n.os-size-observer,\n.os-size-observer-listener {\n  scroll-behavior: auto !important;\n  direction: inherit;\n  pointer-events: none;\n  overflow: hidden;\n  visibility: hidden;\n  box-sizing: border-box;\n}\n\n.os-size-observer,\n.os-size-observer-listener,\n.os-size-observer-listener-item,\n.os-size-observer-listener-item-final {\n  writing-mode: horizontal-tb;\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.os-size-observer {\n  z-index: -1;\n  contain: strict;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  padding: inherit;\n  border: inherit;\n  box-sizing: inherit;\n  margin: -133px;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  transform: scale(0.1);\n}\n.os-size-observer::before {\n  content: \"\";\n  flex: none;\n  box-sizing: inherit;\n  padding: 10px;\n  width: 10px;\n  height: 10px;\n}\n\n.os-size-observer-appear {\n  animation: os-size-observer-appear-animation 1ms forwards;\n}\n\n.os-size-observer-listener {\n  box-sizing: border-box;\n  position: relative;\n  flex: auto;\n  padding: inherit;\n  border: inherit;\n  margin: -133px;\n  transform: scale(calc(1 / 0.1));\n}\n.os-size-observer-listener.ltr {\n  margin-right: -266px;\n  margin-left: 0;\n}\n.os-size-observer-listener.rtl {\n  margin-left: -266px;\n  margin-right: 0;\n}\n.os-size-observer-listener:empty::before {\n  content: \"\";\n  width: 100%;\n  height: 100%;\n}\n.os-size-observer-listener:empty::before, .os-size-observer-listener > .os-size-observer-listener-item {\n  display: block;\n  position: relative;\n  padding: inherit;\n  border: inherit;\n  box-sizing: content-box;\n  flex: auto;\n}\n\n.os-size-observer-listener-scroll {\n  box-sizing: border-box;\n  display: flex;\n}\n\n.os-size-observer-listener-item {\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  direction: ltr;\n  flex: none;\n}\n\n.os-size-observer-listener-item-final {\n  transition: none;\n}\n\n@keyframes os-size-observer-appear-animation {\n  from {\n    cursor: auto;\n  }\n  to {\n    cursor: none;\n  }\n}\n.os-trinsic-observer {\n  flex: none;\n  box-sizing: border-box;\n  position: relative;\n  max-width: 0px;\n  max-height: 1px;\n  padding: 0;\n  margin: 0;\n  border: none;\n  overflow: hidden;\n  z-index: -1;\n  height: 0;\n  top: calc(100% + 1px);\n  contain: strict;\n}\n.os-trinsic-observer:not(:empty) {\n  height: calc(100% + 1px);\n  top: -1px;\n}\n.os-trinsic-observer:not(:empty) > .os-size-observer {\n  width: 1000%;\n  height: 1000%;\n  min-height: 1px;\n  min-width: 1px;\n}\n\n/**\n * hide native scrollbars\n * changes to this styles need to be reflected in the environment styles to correctly detect scrollbar hiding\n */\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport]),\n[data-overlayscrollbars-viewport~=scrollbarHidden],\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body {\n  scrollbar-width: none !important;\n}\n\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport])::-webkit-scrollbar,\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport])::-webkit-scrollbar-corner,\n[data-overlayscrollbars-viewport~=scrollbarHidden]::-webkit-scrollbar,\n[data-overlayscrollbars-viewport~=scrollbarHidden]::-webkit-scrollbar-corner,\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body::-webkit-scrollbar,\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body::-webkit-scrollbar-corner {\n  -webkit-appearance: none !important;\n          appearance: none !important;\n  display: none !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars]):not(html):not(body) {\n  overflow: auto;\n}\n\n/**\n * body element\n */\nhtml[data-overlayscrollbars-body] {\n  overflow: hidden;\n}\n\nhtml[data-overlayscrollbars-body],\nhtml[data-overlayscrollbars-body] > body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n}\n\nhtml[data-overlayscrollbars-body] > body {\n  overflow: visible;\n  margin: 0;\n}\n\n/**\n * structure setup \n */\n[data-overlayscrollbars] {\n  position: relative;\n}\n\n[data-overlayscrollbars~=host],\n[data-overlayscrollbars-padding] {\n  display: flex;\n  align-items: stretch !important;\n  flex-direction: row !important;\n  flex-wrap: nowrap !important;\n  scroll-behavior: auto !important;\n}\n\n[data-overlayscrollbars-padding],\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]) {\n  box-sizing: inherit;\n  position: relative;\n  flex: auto;\n  height: auto;\n  width: 100%;\n  min-width: 0;\n  padding: 0;\n  margin: 0;\n  border: none;\n  z-index: 0;\n}\n\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]) {\n  --os-vaw: 0;\n  --os-vah: 0;\n  outline: none;\n}\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]):focus {\n  outline: none;\n}\n[data-overlayscrollbars-viewport][data-overlayscrollbars-viewport~=arrange]::before {\n  content: \"\";\n  position: absolute;\n  pointer-events: none;\n  z-index: -1;\n  min-width: 1px;\n  min-height: 1px;\n  width: var(--os-vaw);\n  height: var(--os-vah);\n}\n\n/**\n * wrapper elements overflow:\n */\n[data-overlayscrollbars~=host],\n[data-overlayscrollbars-padding] {\n  overflow: hidden !important;\n}\n\n[data-overlayscrollbars~=host][data-overlayscrollbars~=noClipping],\n[data-overlayscrollbars-padding~=noClipping] {\n  overflow: visible !important;\n}\n\n/**\n * viewport overflow:\n */\n[data-overlayscrollbars-viewport] {\n  --os-viewport-overflow-x: hidden;\n  --os-viewport-overflow-y: hidden;\n  overflow-x: var(--os-viewport-overflow-x);\n  overflow-y: var(--os-viewport-overflow-y);\n}\n\n[data-overlayscrollbars-viewport~=overflowXVisible] {\n  --os-viewport-overflow-x: visible;\n}\n\n[data-overlayscrollbars-viewport~=overflowXHidden] {\n  --os-viewport-overflow-x: hidden;\n}\n\n[data-overlayscrollbars-viewport~=overflowXScroll] {\n  --os-viewport-overflow-x: scroll;\n}\n\n[data-overlayscrollbars-viewport~=overflowYVisible] {\n  --os-viewport-overflow-y: visible;\n}\n\n[data-overlayscrollbars-viewport~=overflowYHidden] {\n  --os-viewport-overflow-y: hidden;\n}\n\n[data-overlayscrollbars-viewport~=overflowYScroll] {\n  --os-viewport-overflow-y: scroll;\n}\n\n[data-overlayscrollbars-viewport~=overflowImportant] {\n  overflow-x: var(--os-viewport-overflow-x) !important;\n  overflow-y: var(--os-viewport-overflow-y) !important;\n}\n\n/**\n * viewport state modifiers:\n */\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId) {\n  font-size: 0 !important;\n  line-height: 0 !important;\n}\n\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId)::before,\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId)::after,\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId) > * {\n  display: none !important;\n  position: absolute !important;\n  width: 1px !important;\n  height: 1px !important;\n  padding: 0 !important;\n  margin: -1px !important;\n  overflow: hidden !important;\n  clip: rect(0, 0, 0, 0) !important;\n  white-space: nowrap !important;\n  border-width: 0 !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring],\n[data-overlayscrollbars-viewport~=scrolling] {\n  scroll-behavior: auto !important;\n  scroll-snap-type: none !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring][data-overlayscrollbars-viewport~=overflowXVisible] {\n  overflow-x: hidden !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring][data-overlayscrollbars-viewport~=overflowYVisible] {\n  overflow-y: hidden !important;\n}\n\n/**\n * content element:\n */\n[data-overlayscrollbars-content] {\n  box-sizing: inherit;\n}\n\n/**\n * Display contents to bridge any flickering during deferred initialization.\n */\n[data-overlayscrollbars-contents]:not(#osFakeId):not([data-overlayscrollbars-padding]):not([data-overlayscrollbars-viewport]):not([data-overlayscrollbars-content]) {\n  display: contents;\n}\n\n/**\n * optional & experimental grid mode\n */\n[data-overlayscrollbars-grid],\n[data-overlayscrollbars-grid] [data-overlayscrollbars-padding] {\n  display: grid;\n  grid-template: 1fr/1fr;\n}\n\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-padding],\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-viewport],\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-padding] > [data-overlayscrollbars-viewport] {\n  height: auto !important;\n  width: auto !important;\n}\n\n@property --os-scroll-percent {\n  syntax: \"<number>\";\n  inherits: true;\n  initial-value: 0;\n}\n@property --os-viewport-percent {\n  syntax: \"<number>\";\n  inherits: true;\n  initial-value: 0;\n}\n.os-scrollbar {\n  --os-viewport-percent: 0;\n  --os-scroll-percent: 0;\n  --os-scroll-direction: 0;\n  --os-scroll-percent-directional: calc(\n    var(--os-scroll-percent) - (var(--os-scroll-percent) + (1 - var(--os-scroll-percent)) * -1) *\n      var(--os-scroll-direction)\n  );\n}\n\n.os-scrollbar {\n  contain: size layout;\n  contain: size layout style;\n  transition: opacity 0.15s, visibility 0.15s, top 0.15s, right 0.15s, bottom 0.15s, left 0.15s;\n  pointer-events: none;\n  position: absolute;\n  opacity: 0;\n  visibility: hidden;\n}\n\nbody > .os-scrollbar {\n  position: fixed;\n  z-index: 99999;\n}\n\n.os-scrollbar-transitionless {\n  transition: none !important;\n}\n\n.os-scrollbar-track {\n  position: relative;\n  padding: 0 !important;\n  border: none !important;\n}\n\n.os-scrollbar-handle {\n  position: absolute;\n}\n\n.os-scrollbar-track,\n.os-scrollbar-handle {\n  pointer-events: none;\n  width: 100%;\n  height: 100%;\n}\n\n.os-scrollbar.os-scrollbar-track-interactive .os-scrollbar-track,\n.os-scrollbar.os-scrollbar-handle-interactive .os-scrollbar-handle {\n  pointer-events: auto;\n  touch-action: none;\n}\n\n.os-scrollbar-horizontal {\n  bottom: 0;\n  left: 0;\n}\n\n.os-scrollbar-vertical {\n  top: 0;\n  right: 0;\n}\n\n.os-scrollbar-rtl.os-scrollbar-horizontal {\n  right: 0;\n}\n\n.os-scrollbar-rtl.os-scrollbar-vertical {\n  right: auto;\n  left: 0;\n}\n\n.os-scrollbar-visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.os-scrollbar-auto-hide.os-scrollbar-auto-hide-hidden {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.os-scrollbar-interaction.os-scrollbar-visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.os-scrollbar-unusable,\n.os-scrollbar-unusable *,\n.os-scrollbar-wheel,\n.os-scrollbar-wheel * {\n  pointer-events: none !important;\n}\n\n.os-scrollbar-unusable .os-scrollbar-handle {\n  opacity: 0 !important;\n  transition: none !important;\n}\n\n.os-scrollbar-horizontal .os-scrollbar-handle {\n  bottom: 0;\n  left: calc(var(--os-scroll-percent-directional) * 100%);\n  transform: translateX(calc(var(--os-scroll-percent-directional) * -100%));\n  width: calc(var(--os-viewport-percent) * 100%);\n}\n\n.os-scrollbar-vertical .os-scrollbar-handle {\n  right: 0;\n  top: calc(var(--os-scroll-percent-directional) * 100%);\n  transform: translateY(calc(var(--os-scroll-percent-directional) * -100%));\n  height: calc(var(--os-viewport-percent) * 100%);\n}\n\n@supports (container-type: size) {\n  .os-scrollbar-track {\n    container-type: size;\n  }\n  .os-scrollbar-horizontal .os-scrollbar-handle {\n    left: auto;\n    transform: translateX(calc(var(--os-scroll-percent-directional) * 100cqw + var(--os-scroll-percent-directional) * -100%));\n  }\n  .os-scrollbar-vertical .os-scrollbar-handle {\n    top: auto;\n    transform: translateY(calc(var(--os-scroll-percent-directional) * 100cqh + var(--os-scroll-percent-directional) * -100%));\n  }\n  .os-scrollbar-rtl.os-scrollbar-horizontal .os-scrollbar-handle {\n    right: auto;\n    left: 0;\n  }\n}\n.os-scrollbar-rtl.os-scrollbar-vertical .os-scrollbar-handle {\n  right: auto;\n  left: 0;\n}\n\n.os-scrollbar.os-scrollbar-horizontal.os-scrollbar-cornerless,\n.os-scrollbar.os-scrollbar-horizontal.os-scrollbar-cornerless.os-scrollbar-rtl {\n  left: 0;\n  right: 0;\n}\n\n.os-scrollbar.os-scrollbar-vertical.os-scrollbar-cornerless,\n.os-scrollbar.os-scrollbar-vertical.os-scrollbar-cornerless.os-scrollbar-rtl {\n  top: 0;\n  bottom: 0;\n}\n\n@media print {\n  .os-scrollbar {\n    display: none;\n  }\n}\n.os-scrollbar {\n  --os-size: 0;\n  --os-padding-perpendicular: 0;\n  --os-padding-axis: 0;\n  --os-track-border-radius: 0;\n  --os-track-bg: none;\n  --os-track-bg-hover: none;\n  --os-track-bg-active: none;\n  --os-track-border: none;\n  --os-track-border-hover: none;\n  --os-track-border-active: none;\n  --os-handle-border-radius: 0;\n  --os-handle-bg: none;\n  --os-handle-bg-hover: none;\n  --os-handle-bg-active: none;\n  --os-handle-border: none;\n  --os-handle-border-hover: none;\n  --os-handle-border-active: none;\n  --os-handle-min-size: 33px;\n  --os-handle-max-size: none;\n  --os-handle-perpendicular-size: 100%;\n  --os-handle-perpendicular-size-hover: 100%;\n  --os-handle-perpendicular-size-active: 100%;\n  --os-handle-interactive-area-offset: 0;\n}\n\n.os-scrollbar-track {\n  border: var(--os-track-border);\n  border-radius: var(--os-track-border-radius);\n  background: var(--os-track-bg);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s;\n}\n.os-scrollbar-track:hover {\n  border: var(--os-track-border-hover);\n  background: var(--os-track-bg-hover);\n}\n.os-scrollbar-track:active {\n  border: var(--os-track-border-active);\n  background: var(--os-track-bg-active);\n}\n\n.os-scrollbar-handle {\n  border: var(--os-handle-border);\n  border-radius: var(--os-handle-border-radius);\n  background: var(--os-handle-bg);\n}\n.os-scrollbar-handle:hover {\n  border: var(--os-handle-border-hover);\n  background: var(--os-handle-bg-hover);\n}\n.os-scrollbar-handle:active {\n  border: var(--os-handle-border-active);\n  background: var(--os-handle-bg-active);\n}\n\n.os-scrollbar-track:before,\n.os-scrollbar-handle:before {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: block;\n}\n\n.os-scrollbar-horizontal {\n  padding: var(--os-padding-perpendicular) var(--os-padding-axis);\n  right: var(--os-size);\n  height: var(--os-size);\n}\n.os-scrollbar-horizontal.os-scrollbar-rtl {\n  left: var(--os-size);\n  right: 0;\n}\n.os-scrollbar-horizontal .os-scrollbar-track:before {\n  top: calc(var(--os-padding-perpendicular) * -1);\n  bottom: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-horizontal .os-scrollbar-handle {\n  min-width: var(--os-handle-min-size);\n  max-width: var(--os-handle-max-size);\n  height: var(--os-handle-perpendicular-size);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s, height 0.15s;\n}\n.os-scrollbar-horizontal .os-scrollbar-handle:before {\n  top: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  bottom: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-horizontal:hover .os-scrollbar-handle {\n  height: var(--os-handle-perpendicular-size-hover);\n}\n.os-scrollbar-horizontal:active .os-scrollbar-handle {\n  height: var(--os-handle-perpendicular-size-active);\n}\n\n.os-scrollbar-vertical {\n  padding: var(--os-padding-axis) var(--os-padding-perpendicular);\n  bottom: var(--os-size);\n  width: var(--os-size);\n}\n.os-scrollbar-vertical .os-scrollbar-track:before {\n  left: calc(var(--os-padding-perpendicular) * -1);\n  right: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical .os-scrollbar-handle {\n  min-height: var(--os-handle-min-size);\n  max-height: var(--os-handle-max-size);\n  width: var(--os-handle-perpendicular-size);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s, width 0.15s;\n}\n.os-scrollbar-vertical .os-scrollbar-handle:before {\n  left: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  right: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical.os-scrollbar-rtl .os-scrollbar-handle:before {\n  right: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  left: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical:hover .os-scrollbar-handle {\n  width: var(--os-handle-perpendicular-size-hover);\n}\n.os-scrollbar-vertical:active .os-scrollbar-handle {\n  width: var(--os-handle-perpendicular-size-active);\n}\n\n/* NONE THEME: */\n[data-overlayscrollbars-viewport~=measuring] > .os-scrollbar,\n.os-theme-none.os-scrollbar {\n  display: none !important;\n}\n\n/* DARK & LIGHT THEME: */\n.os-theme-dark,\n.os-theme-light {\n  box-sizing: border-box;\n  --os-size: 10px;\n  --os-padding-perpendicular: 2px;\n  --os-padding-axis: 2px;\n  --os-track-border-radius: 10px;\n  --os-handle-interactive-area-offset: 4px;\n  --os-handle-border-radius: 10px;\n}\n\n.os-theme-dark {\n  --os-handle-bg: rgba(0, 0, 0, 0.44);\n  --os-handle-bg-hover: rgba(0, 0, 0, 0.55);\n  --os-handle-bg-active: rgba(0, 0, 0, 0.66);\n}\n\n.os-theme-light {\n  --os-handle-bg: rgba(255, 255, 255, 0.44);\n  --os-handle-bg-hover: rgba(255, 255, 255, 0.55);\n  --os-handle-bg-active: rgba(255, 255, 255, 0.66);\n}";

  /**
   * SSR Window 4.0.2
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2021, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: December 13, 2021
   */
  /* eslint-disable no-param-reassign */
  function isObject$1(obj) {
      return (obj !== null &&
          typeof obj === 'object' &&
          'constructor' in obj &&
          obj.constructor === Object);
  }
  function extend$1(target = {}, src = {}) {
      Object.keys(src).forEach((key) => {
          if (typeof target[key] === 'undefined')
              target[key] = src[key];
          else if (isObject$1(src[key]) &&
              isObject$1(target[key]) &&
              Object.keys(src[key]).length > 0) {
              extend$1(target[key], src[key]);
          }
      });
  }

  const ssrDocument = {
      body: {},
      addEventListener() { },
      removeEventListener() { },
      activeElement: {
          blur() { },
          nodeName: '',
      },
      querySelector() {
          return null;
      },
      querySelectorAll() {
          return [];
      },
      getElementById() {
          return null;
      },
      createEvent() {
          return {
              initEvent() { },
          };
      },
      createElement() {
          return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute() { },
              getElementsByTagName() {
                  return [];
              },
          };
      },
      createElementNS() {
          return {};
      },
      importNode() {
          return null;
      },
      location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
      },
  };
  function getDocument() {
      const doc = typeof document !== 'undefined' ? document : {};
      extend$1(doc, ssrDocument);
      return doc;
  }

  const ssrWindow = {
      document: ssrDocument,
      navigator: {
          userAgent: '',
      },
      location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
      },
      history: {
          replaceState() { },
          pushState() { },
          go() { },
          back() { },
      },
      CustomEvent: function CustomEvent() {
          return this;
      },
      addEventListener() { },
      removeEventListener() { },
      getComputedStyle() {
          return {
              getPropertyValue() {
                  return '';
              },
          };
      },
      Image() { },
      Date() { },
      screen: {},
      setTimeout() { },
      clearTimeout() { },
      matchMedia() {
          return {};
      },
      requestAnimationFrame(callback) {
          if (typeof setTimeout === 'undefined') {
              callback();
              return null;
          }
          return setTimeout(callback, 0);
      },
      cancelAnimationFrame(id) {
          if (typeof setTimeout === 'undefined') {
              return;
          }
          clearTimeout(id);
      },
  };
  function getWindow() {
      const win = typeof window !== 'undefined' ? window : {};
      extend$1(win, ssrWindow);
      return win;
  }

  /**
   * Dom7 4.0.6
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * https://framework7.io/docs/dom7.html
   *
   * Copyright 2023, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: February 2, 2023
   */

  /* eslint-disable no-proto */
  function makeReactive(obj) {
    const proto = obj.__proto__;
    Object.defineProperty(obj, '__proto__', {
      get() {
        return proto;
      },

      set(value) {
        proto.__proto__ = value;
      }

    });
  }

  class Dom7 extends Array {
    constructor(items) {
      if (typeof items === 'number') {
        super(items);
      } else {
        super(...(items || []));
        makeReactive(this);
      }
    }

  }

  function arrayFlat(arr = []) {
    const res = [];
    arr.forEach(el => {
      if (Array.isArray(el)) {
        res.push(...arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }
  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }
  function arrayUnique(arr) {
    const uniqueArray = [];

    for (let i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
    }

    return uniqueArray;
  }

  // eslint-disable-next-line

  function qsa(selector, context) {
    if (typeof selector !== 'string') {
      return [selector];
    }

    const a = [];
    const res = context.querySelectorAll(selector);

    for (let i = 0; i < res.length; i += 1) {
      a.push(res[i]);
    }

    return a;
  }

  function $(selector, context) {
    const window = getWindow();
    const document = getDocument();
    let arr = [];

    if (!context && selector instanceof Dom7) {
      return selector;
    }

    if (!selector) {
      return new Dom7(arr);
    }

    if (typeof selector === 'string') {
      const html = selector.trim();

      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        const tempParent = document.createElement(toCreate);
        tempParent.innerHTML = html;

        for (let i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        arr = qsa(selector.trim(), context || document);
      } // arr = qsa(selector, document);

    } else if (selector.nodeType || selector === window || selector === document) {
      arr.push(selector);
    } else if (Array.isArray(selector)) {
      if (selector instanceof Dom7) return selector;
      arr = selector;
    }

    return new Dom7(arrayUnique(arr));
  }

  $.fn = Dom7.prototype;

  // eslint-disable-next-line

  function addClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      el.classList.add(...classNames);
    });
    return this;
  }

  function removeClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      el.classList.remove(...classNames);
    });
    return this;
  }

  function toggleClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      classNames.forEach(className => {
        el.classList.toggle(className);
      });
    });
  }

  function hasClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    return arrayFilter(this, el => {
      return classNames.filter(className => el.classList.contains(className)).length > 0;
    }).length > 0;
  }

  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) return this[0].getAttribute(attrs);
      return undefined;
    } // Set attrs


    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        for (const attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    return this;
  }

  function removeAttr(attr) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }

    return this;
  }

  function transform(transform) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transform = transform;
    }

    return this;
  }

  function transition$1(duration) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
    }

    return this;
  }

  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;

    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }

    if (!capture) capture = false;

    function handleLiveEvent(e) {
      const target = e.target;
      if (!target) return;
      const eventData = e.target.dom7EventData || [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
        const parents = $(target).parents(); // eslint-disable-line

        for (let k = 0; k < parents.length; k += 1) {
          if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
        }
      }
    }

    function handleEvent(e) {
      const eventData = e && e.target ? e.target.dom7EventData || [] : [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      listener.apply(this, eventData);
    }

    const events = eventType.split(' ');
    let j;

    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];

      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
          el.dom7Listeners[event].push({
            listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
          el.dom7LiveListeners[event].push({
            listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event, handleLiveEvent, capture);
        }
      }
    }

    return this;
  }

  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;

    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }

    if (!capture) capture = false;
    const events = eventType.split(' ');

    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];

      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let handlers;

        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }

        if (handlers && handlers.length) {
          for (let k = handlers.length - 1; k >= 0; k -= 1) {
            const handler = handlers[k];

            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }

    return this;
  }

  function trigger(...args) {
    const window = getWindow();
    const events = args[0].split(' ');
    const eventData = args[1];

    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];

      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];

        if (window.CustomEvent) {
          const evt = new window.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }

    return this;
  }

  function transitionEnd$1(callback) {
    const dom = this;

    function fireCallBack(e) {
      if (e.target !== this) return;
      callback.call(this, e);
      dom.off('transitionend', fireCallBack);
    }

    if (callback) {
      dom.on('transitionend', fireCallBack);
    }

    return this;
  }

  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles = this.styles();
        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
      }

      return this[0].offsetWidth;
    }

    return null;
  }

  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles = this.styles();
        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
      }

      return this[0].offsetHeight;
    }

    return null;
  }

  function offset() {
    if (this.length > 0) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body = document.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === window ? window.scrollY : el.scrollTop;
      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }

    return null;
  }

  function styles() {
    const window = getWindow();
    if (this[0]) return window.getComputedStyle(this[0], null);
    return {};
  }

  function css(props, value) {
    const window = getWindow();
    let i;

    if (arguments.length === 1) {
      if (typeof props === 'string') {
        // .css('width')
        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        // .css({ width: '100px' })
        for (i = 0; i < this.length; i += 1) {
          for (const prop in props) {
            this[i].style[prop] = props[prop];
          }
        }

        return this;
      }
    }

    if (arguments.length === 2 && typeof props === 'string') {
      // .css('width', '100px')
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }

      return this;
    }

    return this;
  }

  function each(callback) {
    if (!callback) return this;
    this.forEach((el, index) => {
      callback.apply(el, [el, index]);
    });
    return this;
  }

  function filter$1(callback) {
    const result = arrayFilter(this, callback);
    return $(result);
  }

  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : null;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }

    return this;
  }

  function text(text) {
    if (typeof text === 'undefined') {
      return this[0] ? this[0].textContent.trim() : null;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }

    return this;
  }

  function is$2(selector) {
    const window = getWindow();
    const document = getDocument();
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === 'undefined') return false;

    if (typeof selector === 'string') {
      if (el.matches) return el.matches(selector);
      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      if (el.msMatchesSelector) return el.msMatchesSelector(selector);
      compareWith = $(selector);

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    if (selector === document) {
      return el === document;
    }

    if (selector === window) {
      return el === window;
    }

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    return false;
  }

  function index$1() {
    let child = this[0];
    let i;

    if (child) {
      i = 0; // eslint-disable-next-line

      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }

      return i;
    }

    return undefined;
  }

  function eq(index) {
    if (typeof index === 'undefined') return this;
    const length = this.length;

    if (index > length - 1) {
      return $([]);
    }

    if (index < 0) {
      const returnIndex = length + index;
      if (returnIndex < 0) return $([]);
      return $([this[returnIndex]]);
    }

    return $([this[index]]);
  }

  function append$2(...els) {
    let newChild;
    const document = getDocument();

    for (let k = 0; k < els.length; k += 1) {
      newChild = els[k];

      for (let i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }

  function prepend$1(newChild) {
    const document = getDocument();
    let i;
    let j;

    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }

    return this;
  }

  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return $([this[0].nextElementSibling]);
        }

        return $([]);
      }

      if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function nextAll(selector) {
    const nextEls = [];
    let el = this[0];
    if (!el) return $([]);

    while (el.nextElementSibling) {
      const next = el.nextElementSibling; // eslint-disable-line

      if (selector) {
        if ($(next).is(selector)) nextEls.push(next);
      } else nextEls.push(next);

      el = next;
    }

    return $(nextEls);
  }

  function prev(selector) {
    if (this.length > 0) {
      const el = this[0];

      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return $([el.previousElementSibling]);
        }

        return $([]);
      }

      if (el.previousElementSibling) return $([el.previousElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function prevAll(selector) {
    const prevEls = [];
    let el = this[0];
    if (!el) return $([]);

    while (el.previousElementSibling) {
      const prev = el.previousElementSibling; // eslint-disable-line

      if (selector) {
        if ($(prev).is(selector)) prevEls.push(prev);
      } else prevEls.push(prev);

      el = prev;
    }

    return $(prevEls);
  }

  function parent(selector) {
    const parents = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }

    return $(parents);
  }

  function parents(selector) {
    const parents = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      let parent = this[i].parentNode; // eslint-disable-line

      while (parent) {
        if (selector) {
          if ($(parent).is(selector)) parents.push(parent);
        } else {
          parents.push(parent);
        }

        parent = parent.parentNode;
      }
    }

    return $(parents);
  }

  function closest(selector) {
    let closest = this; // eslint-disable-line

    if (typeof selector === 'undefined') {
      return $([]);
    }

    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }

    return closest;
  }

  function find$1(selector) {
    const foundElements = [];

    for (let i = 0; i < this.length; i += 1) {
      const found = this[i].querySelectorAll(selector);

      for (let j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }

    return $(foundElements);
  }

  function children(selector) {
    const children = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      const childNodes = this[i].children;

      for (let j = 0; j < childNodes.length; j += 1) {
        if (!selector || $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }

    return $(children);
  }

  function remove$1() {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
    }

    return this;
  }

  const Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition: transition$1,
    on,
    off,
    trigger,
    transitionEnd: transitionEnd$1,
    outerWidth,
    outerHeight,
    styles,
    offset,
    css,
    each,
    html,
    text,
    is: is$2,
    index: index$1,
    eq,
    append: append$2,
    prepend: prepend$1,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find: find$1,
    children,
    filter: filter$1,
    remove: remove$1
  };
  Object.keys(Methods).forEach(methodName => {
    Object.defineProperty($.fn, methodName, {
      value: Methods[methodName],
      writable: true
    });
  });

  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach(key => {
      try {
        object[key] = null;
      } catch (e) {// no getter for object
      }

      try {
        delete object[key];
      } catch (e) {// something got wrong
      }
    });
  }

  function nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  }

  function now() {
    return Date.now();
  }

  function getComputedStyle$1(el) {
    const window = getWindow();
    let style;

    if (window.getComputedStyle) {
      style = window.getComputedStyle(el, null);
    }

    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }

    if (!style) {
      style = el.style;
    }

    return style;
  }

  function getTranslate(el, axis = 'x') {
    const window = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle$1(el);

    if (window.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;

      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      } // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case


      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }

    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }

    return curTransform || 0;
  }

  function isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
  }

  function isNode$1(node) {
    // eslint-disable-next-line
    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
      return node instanceof HTMLElement;
    }

    return node && (node.nodeType === 1 || node.nodeType === 11);
  }

  function extend(...args) {
    const to = Object(args[0]);
    const noExtend = ['__proto__', 'constructor', 'prototype'];

    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];

      if (nextSource !== undefined && nextSource !== null && !isNode$1(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

          if (desc !== undefined && desc.enumerable) {
            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              to[nextKey] = {};

              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }

    return to;
  }

  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }

  function animateCSSModeScroll({
    swiper,
    targetPosition,
    side
  }) {
    const window = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = 'none';
    window.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? 'next' : 'prev';

    const isOutOfBound = (current, target) => {
      return dir === 'next' && current >= target || dir === 'prev' && current <= target;
    };

    const animate = () => {
      time = new Date().getTime();

      if (startTime === null) {
        startTime = time;
      }

      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }

      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });

      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = 'hidden';
        swiper.wrapperEl.style.scrollSnapType = '';
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }

      swiper.cssModeFrameID = window.requestAnimationFrame(animate);
    };

    animate();
  }

  let support;

  function calcSupport() {
    const window = getWindow();
    const document = getDocument();
    return {
      smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
      passiveListener: function checkPassiveListener() {
        let supportsPassive = false;

        try {
          const opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get() {
              supportsPassive = true;
            }

          });
          window.addEventListener('testPassiveListener', null, opts);
        } catch (e) {// No support
        }

        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return 'ongesturestart' in window;
      }()
    };
  }

  function getSupport() {
    if (!support) {
      support = calcSupport();
    }

    return support;
  }

  let deviceCached;

  function calcDevice({
    userAgent
  } = {}) {
    const support = getSupport();
    const window = getWindow();
    const platform = window.navigator.platform;
    const ua = userAgent || window.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === 'Win32';
    let macos = platform === 'MacIntel'; // iPadOs 13 fix

    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, '13_0_0'];
      macos = false;
    } // Android


    if (android && !windows) {
      device.os = 'android';
      device.android = true;
    }

    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    } // Export object


    return device;
  }

  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }

    return deviceCached;
  }

  let browser;

  function calcBrowser() {
    const window = getWindow();

    function isSafari() {
      const ua = window.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }

    return {
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
    };
  }

  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }

    return browser;
  }

  function Resize({
    swiper,
    on,
    emit
  }) {
    const window = getWindow();
    let observer = null;
    let animationFrame = null;

    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('beforeResize');
      emit('resize');
    };

    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      observer = new ResizeObserver(entries => {
        animationFrame = window.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });

          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };

    const removeObserver = () => {
      if (animationFrame) {
        window.cancelAnimationFrame(animationFrame);
      }

      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };

    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('orientationchange');
    };

    on('init', () => {
      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
        createObserver();
        return;
      }

      window.addEventListener('resize', resizeHandler);
      window.addEventListener('orientationchange', orientationChangeHandler);
    });
    on('destroy', () => {
      removeObserver();
      window.removeEventListener('resize', resizeHandler);
      window.removeEventListener('orientationchange', orientationChangeHandler);
    });
  }

  function Observer({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const observers = [];
    const window = getWindow();

    const attach = (target, options = {}) => {
      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
      const observer = new ObserverFunc(mutations => {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          emit('observerUpdate', mutations[0]);
          return;
        }

        const observerUpdate = function observerUpdate() {
          emit('observerUpdate', mutations[0]);
        };

        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(observerUpdate);
        } else {
          window.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      observers.push(observer);
    };

    const init = () => {
      if (!swiper.params.observer) return;

      if (swiper.params.observeParents) {
        const containerParents = swiper.$el.parents();

        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      } // Observe container


      attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      }); // Observe wrapper

      attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    };

    const destroy = () => {
      observers.forEach(observer => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };

    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on('init', init);
    on('destroy', destroy);
  }

  /* eslint-disable no-underscore-dangle */
  var eventsEmitter = {
    on(events, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';
      events.split(' ').forEach(event => {
        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
        self.eventsListeners[event][method](handler);
      });
      return self;
    },

    once(events, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;

      function onceHandler(...args) {
        self.off(events, onceHandler);

        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }

        handler.apply(self, args);
      }

      onceHandler.__emitterProxy = handler;
      return self.on(events, onceHandler, priority);
    },

    onAny(handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';

      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method](handler);
      }

      return self;
    },

    offAny(handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsAnyListeners) return self;
      const index = self.eventsAnyListeners.indexOf(handler);

      if (index >= 0) {
        self.eventsAnyListeners.splice(index, 1);
      }

      return self;
    },

    off(events, handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      events.split(' ').forEach(event => {
        if (typeof handler === 'undefined') {
          self.eventsListeners[event] = [];
        } else if (self.eventsListeners[event]) {
          self.eventsListeners[event].forEach((eventHandler, index) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event].splice(index, 1);
            }
          });
        }
      });
      return self;
    },

    emit(...args) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      let events;
      let data;
      let context;

      if (typeof args[0] === 'string' || Array.isArray(args[0])) {
        events = args[0];
        data = args.slice(1, args.length);
        context = self;
      } else {
        events = args[0].events;
        data = args[0].data;
        context = args[0].context || self;
      }

      data.unshift(context);
      const eventsArray = Array.isArray(events) ? events : events.split(' ');
      eventsArray.forEach(event => {
        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
          self.eventsAnyListeners.forEach(eventHandler => {
            eventHandler.apply(context, [event, ...data]);
          });
        }

        if (self.eventsListeners && self.eventsListeners[event]) {
          self.eventsListeners[event].forEach(eventHandler => {
            eventHandler.apply(context, data);
          });
        }
      });
      return self;
    }

  };

  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const $el = swiper.$el;

    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }

    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }

    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    } // Subtract paddings


    width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
    height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    const swiper = this;

    function getDirectionLabel(property) {
      if (swiper.isHorizontal()) {
        return property;
      } // prettier-ignore


      return {
        'width': 'height',
        'margin-top': 'margin-left',
        'margin-bottom ': 'margin-right',
        'margin-left': 'margin-top',
        'margin-right': 'margin-bottom',
        'padding-left': 'padding-top',
        'padding-right': 'padding-bottom',
        'marginRight': 'marginBottom'
      }[property];
    }

    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }

    const params = swiper.params;
    const {
      $wrapperEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;

    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    let offsetAfter = params.slidesOffsetAfter;

    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;

    if (typeof swiperSize === 'undefined') {
      return;
    }

    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    }

    swiper.virtualSize = -spaceBetween; // reset margins

    if (rtl) slides.css({
      marginLeft: '',
      marginBottom: '',
      marginTop: ''
    });else slides.css({
      marginRight: '',
      marginBottom: '',
      marginTop: ''
    }); // reset cssMode offsets

    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
    }

    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

    if (gridEnabled) {
      swiper.grid.initSlides(slidesLength);
    } // Calc slides


    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
      return typeof params.breakpoints[key].slidesPerView !== 'undefined';
    }).length > 0;

    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      const slide = slides.eq(i);

      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
      }

      if (slide.css('display') === 'none') continue; // eslint-disable-line

      if (params.slidesPerView === 'auto') {
        if (shouldResetSlideSize) {
          slides[i].style[getDirectionLabel('width')] = ``;
        }

        const slideStyles = getComputedStyle(slide[0]);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;

        if (currentTransform) {
          slide[0].style.transform = 'none';
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }

        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          const width = getDirectionPropertyValue(slideStyles, 'width');
          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
          const boxSizing = slideStyles.getPropertyValue('box-sizing');

          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide[0];
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }

        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }

        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);

        if (slides[i]) {
          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
        }
      }

      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }

      slidesSizesGrid.push(slideSize);

      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }

    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({
        width: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }

    if (params.setWrapperSize) {
      $wrapperEl.css({
        [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }

    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    } // Remove last grid elements depending on width


    if (!params.centeredSlides) {
      const newSlidesGrid = [];

      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }

      snapGrid = newSlidesGrid;

      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }

    if (snapGrid.length === 0) snapGrid = [0];

    if (params.spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
      slides.filter((_, slideIndex) => {
        if (!params.cssMode) return true;

        if (slideIndex === slides.length - 1) {
          return false;
        }

        return true;
      }).css({
        [key]: `${spaceBetween}px`
      });
    }

    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map(snap => {
        if (snap < 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }

    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;

      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });

    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
    }

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }

    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit('snapGridLengthChange');
    }

    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }

    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);

      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.$el.removeClass(backFaceHiddenClass);
      }
    }
  }

  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;

    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }

    const getSlideByIndex = index => {
      if (isVirtual) {
        return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
      }

      return swiper.slides.eq(index)[0];
    }; // Find slides currently in view


    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || $([])).each(slide => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    } // Find new height from highest slide in view


    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    } // Update Height


    if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
  }

  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;

    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate; // Visible Slides

    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      let slideOffset = slide.swiperSlideOffset;

      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }

      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }

      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }

    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress(translate) {
    const swiper = this;

    if (typeof translate === 'undefined') {
      const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }

    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;

    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }

    Object.assign(swiper, {
      progress,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }

    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }

    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      $wrapperEl,
      activeIndex,
      realIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
    let activeSlide;

    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    } // Active classes


    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      }
    } // Next Slide


    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    } // Prev Slide


    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }

    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
      }

      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
      }
    }

    swiper.emitSlidesClasses();
  }

  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      slidesGrid,
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;

    if (typeof activeIndex === 'undefined') {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      } // Normalize slideIndex


      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
      }
    }

    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }

    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }

      return;
    } // Get real index


    const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    Object.assign(swiper, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');

    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }

    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide(e) {
    const swiper = this;
    const params = swiper.params;
    const slide = $(e).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    let slideIndex;

    if (slide) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;

      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }

    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update$1 = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      $wrapperEl
    } = swiper;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }

    if (params.cssMode) {
      return translate;
    }

    let currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      $wrapperEl,
      wrapperEl,
      progress
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    }

    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    const minTranslate = swiper.minTranslate();
    const maxTranslate = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

    swiper.updateProgress(newTranslate);

    if (params.cssMode) {
      const isH = swiper.isHorizontal();

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? 'left' : 'top'
          });
          return true;
        }

        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth'
        });
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;

            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
      }
    }

    return true;
  }

  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  function setTransition(duration, byController) {
    const swiper = this;

    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }

    swiper.emit('setTransition', duration, byController);
  }

  function transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
    }

    swiper.emit(`transition${step}`);

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }

      swiper.emit(`slideChangeTransition${step}`);

      if (dir === 'next') {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }

  function transitionStart(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode) return;

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'Start'
    });
  }

  function transitionEnd(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'End'
    });
  }

  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };

  function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index !== 'number' && typeof index !== 'string') {
      throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
    }

    if (typeof index === 'string') {
      /**
       * The `index` argument converted from `string` to `number`.
       * @type {number}
       */
      const indexAsNumber = parseInt(index, 10);
      /**
       * Determines whether the `index` argument is a valid `number`
       * after being converted from the `string` type.
       * @type {boolean}
       */

      const isValidNumber = isFinite(indexAsNumber);

      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
      } // Knowing that the converted `index` is a valid number,
      // we can update the original argument's value.


      index = indexAsNumber;
    }

    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }

    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex]; // Normalize slideIndex

    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    } // Directions locks


    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }

      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }

    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    } // Update progress


    swiper.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex); // Update Height

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      swiper.updateSlidesClasses();

      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }

      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }

      return false;
    }

    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t = rtl ? translate : -translate;

      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = 'none';
          swiper._immediateVirtual = true;
        }

        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = '';
            swiper._swiperImmediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t,
            side: isH ? 'left' : 'top'
          });
          return true;
        }

        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth'
        });
      }

      return true;
    }

    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }

    return true;
  }

  function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
    if (typeof index === 'string') {
      /**
       * The `index` argument converted from `string` to `number`.
       * @type {number}
       */
      const indexAsNumber = parseInt(index, 10);
      /**
       * Determines whether the `index` argument is a valid `number`
       * after being converted from the `string` type.
       * @type {boolean}
       */

      const isValidNumber = isFinite(indexAsNumber);

      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
      } // Knowing that the converted `index` is a valid number,
      // we can update the original argument's value.


      index = indexAsNumber;
    }

    const swiper = this;
    let newIndex = index;

    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      animating,
      enabled,
      params
    } = swiper;
    if (!enabled) return swiper;
    let perGroup = params.slidesPerGroup;

    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
    }

    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }

    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      params,
      animating,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return swiper;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    const translate = rtlTranslate ? swiper.translate : -swiper.translate;

    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }

    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map(val => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

    if (typeof prevSnap === 'undefined' && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          // prevSnap = snap;
          prevSnapIndex = snapIndex;
        }
      });

      if (typeof prevSnapIndex !== 'undefined') {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }

    let prevIndex = 0;

    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }

    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    }

    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper = this;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];

      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];

      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }

    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    const swiper = this;
    const {
      params,
      $wrapperEl
    } = swiper;
    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;

    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  function loopCreate() {
    const swiper = this;
    const document = getDocument();
    const {
      params,
      $wrapperEl
    } = swiper; // Remove duplicated slides

    const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
    $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    let slides = $selector.children(`.${params.slideClass}`);

    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i = 0; i < blankSlidesNum; i += 1) {
          const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $selector.append(blankNode);
        }

        slides = $selector.children(`.${params.slideClass}`);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;

    if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
      swiper.loopedSlides = slides.length;
    }

    const prependSlides = [];
    const appendSlides = [];
    slides.each((el, index) => {
      const slide = $(el);
      slide.attr('data-swiper-slide-index', index);
    });

    for (let i = 0; i < swiper.loopedSlides; i += 1) {
      const index = i - Math.floor(i / slides.length) * slides.length;
      appendSlides.push(slides.eq(index)[0]);
      prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
    }

    for (let i = 0; i < appendSlides.length; i += 1) {
      $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }

    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
      $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix() {
    const swiper = this;
    swiper.emit('beforeLoopFix');
    const {
      activeIndex,
      slides,
      loopedSlides,
      allowSlidePrev,
      allowSlideNext,
      snapGrid,
      rtlTranslate: rtl
    } = swiper;
    let newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }

    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
  }

  function loopDestroy() {
    const swiper = this;
    const {
      $wrapperEl,
      params,
      slides
    } = swiper;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  function setGrabCursor(moving) {
    const swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
    el.style.cursor = 'move';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor() {
    const swiper = this;

    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }

    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };

  function closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector);

      if (!found && !el.getRootNode) {
        return null;
      }

      return found || __closestFrom(el.getRootNode().host);
    }

    return __closestFrom(base);
  }

  function onTouchStart(event) {
    const swiper = this;
    const document = getDocument();
    const window = getWindow();
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled) return;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }

    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }

    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    let $targetEl = $(e.target);

    if (params.touchEventsTarget === 'wrapper') {
      if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }

    data.isTouchEvent = e.type === 'touchstart';
    if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
    if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return; // change target el for shadow root component

    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== ''; // eslint-disable-next-line

    const eventPath = event.composedPath ? event.composedPath() : event.path;

    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
      $targetEl = $(eventPath[0]);
    }

    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
      swiper.allowClick = true;
      return;
    }

    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === 'prevent') {
        event.preventDefault();
      } else {
        return;
      }
    }

    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;

    if (e.type !== 'touchstart') {
      let preventDefault = true;

      if ($targetEl.is(data.focusableElements)) {
        preventDefault = false;

        if ($targetEl[0].nodeName === 'SELECT') {
          data.isTouched = false;
        }
      }

      if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
        document.activeElement.blur();
      }

      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
        e.preventDefault();
      }
    }

    if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }

    swiper.emit('touchStart', e);
  }

  function onTouchMove(event) {
    const document = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled) return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      return;
    }

    if (data.isTouchEvent && e.type !== 'touchmove') return;
    const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }

    if (!swiper.allowTouchMove) {
      if (!$(e.target).is(data.focusableElements)) {
        swiper.allowClick = false;
      }

      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }

      return;
    }

    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }

    if (data.isTouchEvent && document.activeElement) {
      if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }

    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

    if (typeof data.isScrolling === 'undefined') {
      let touchAngle;

      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }

    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }

    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }

    if (!data.startMoving) {
      return;
    }

    swiper.allowClick = false;

    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }

    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop && !params.cssMode) {
        swiper.loopFix();
      }

      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);

      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }

      data.allowMomentumBounce = false; // Grab Cursor

      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }

      swiper.emit('sliderFirstMove', e);
    }

    swiper.emit('sliderMove', e);
    data.isMoved = true;
    let diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;

    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }

    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    } // Directions locks


    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    } // Threshold


    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger || params.cssMode) return; // Update active index in free mode

    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    } // Update progress


    swiper.updateProgress(data.currentTranslate); // Update translate

    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled) return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }

    data.allowTouchCallbacks = false;

    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }

      data.isMoved = false;
      data.startMoving = false;
      return;
    } // Return Grab Cursor


    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    } // Time diff


    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

    if (swiper.allowClick) {
      const pathTree = e.path || e.composedPath && e.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
      swiper.emit('tap click', e);

      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }

    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }

    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;

    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.cssMode) {
      return;
    }

    if (swiper.params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    } // Find current slide


    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];

    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (typeof slidesGrid[i + increment] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }

    let rewindFirstIndex = null;
    let rewindLastIndex = null;

    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    } // Find current slide size


    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
      }

      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }

        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0) return; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    } // Save locks


    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper; // Disable locks on resize

    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();

    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }

    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    } // Return locks after resize


    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    const swiper = this;
    if (!swiper.enabled) return;

    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e.preventDefault();

      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;

    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    } // eslint-disable-next-line


    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }

    swiper.emit('setTranslate', swiper.translate, false);
  }

  let dummyEventAttached = false;

  function dummyEventListener() {}

  const events = (swiper, method) => {
    const document = getDocument();
    const {
      params,
      touchEvents,
      el,
      wrapperEl,
      device,
      support
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    const swiperMethod = method; // Touch Events

    if (!support.touch) {
      el[domMethod](touchEvents.start, swiper.onTouchStart, false);
      document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
      document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
    } else {
      const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
      el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl[domMethod]('scroll', swiper.onScroll);
    } // Resize handler


    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
      swiper[swiperMethod]('observerUpdate', onResize, true);
    }
  };

  function attachEvents() {
    const swiper = this;
    const document = getDocument();
    const {
      params,
      support
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);

    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }

    swiper.onClick = onClick.bind(swiper);

    if (support.touch && !dummyEventAttached) {
      document.addEventListener('touchstart', dummyEventListener);
      dummyEventAttached = true;
    }

    events(swiper, 'on');
  }

  function detachEvents() {
    const swiper = this;
    events(swiper, 'off');
  }

  var events$1 = {
    attachEvents,
    detachEvents
  };

  const isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };

  function setBreakpoint() {
    const swiper = this;
    const {
      activeIndex,
      initialized,
      loopedSlides = 0,
      params,
      $el
    } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasEnabled = params.enabled;

    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}grid`);

      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
        $el.addClass(`${params.containerModifierClass}grid-column`);
      }

      swiper.emitContainerClasses();
    } // Toggle navigation, pagination, scrollbar


    ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;

      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }

      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    extend(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });

    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }

    swiper.currentBreakpoint = breakpoint;
    swiper.emit('_beforeBreakpoint', breakpointParams);

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }

  function getBreakpoint(breakpoints, base = 'window', containerEl) {
    if (!breakpoints || base === 'container' && !containerEl) return undefined;
    let breakpoint = false;
    const window = getWindow();
    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map(point => {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }

      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];

      if (base === 'window') {
        if (window.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }

    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };

  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach(item => {
      if (typeof item === 'object') {
        Object.keys(item).forEach(classNames => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === 'string') {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }

  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      $el,
      device,
      support
    } = swiper; // prettier-ignore

    const suffixes = prepareClasses(['initialized', params.direction, {
      'pointer-events': !support.touch
    }, {
      'free-mode': swiper.params.freeMode && params.freeMode.enabled
    }, {
      'autoheight': params.autoHeight
    }, {
      'rtl': rtl
    }, {
      'grid': params.grid && params.grid.rows > 1
    }, {
      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
    }, {
      'android': device.android
    }, {
      'ios': device.ios
    }, {
      'css-mode': params.cssMode
    }, {
      'centered': params.cssMode && params.centeredSlides
    }, {
      'watch-progress': params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    $el.addClass([...classNames].join(' '));
    swiper.emitContainerClasses();
  }

  function removeClasses() {
    const swiper = this;
    const {
      $el,
      classNames
    } = swiper;
    $el.removeClass(classNames.join(' '));
    swiper.emitContainerClasses();
  }

  var classes = {
    addClasses,
    removeClasses
  };

  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    const window = getWindow();
    let image;

    function onReady() {
      if (callback) callback();
    }

    const isPicture = $(imageEl).parent('picture')[0];

    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image = new window.Image();
        image.onload = onReady;
        image.onerror = onReady;

        if (sizes) {
          image.sizes = sizes;
        }

        if (srcset) {
          image.srcset = srcset;
        }

        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages() {
    const swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');

    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
      if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) swiper.update();
        swiper.emit('imagesReady');
      }
    }

    for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
      const imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
    }
  }

  var images = {
    loadImage,
    preloadImages
  };

  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;

    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }

    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }

    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }

    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }
  }

  var checkOverflow$1 = {
    checkOverflow
  };

  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'wrapper',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: 'input, select, option, textarea, button, video, label',
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    breakpointsBase: 'window',
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: true,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: 'swiper-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };

  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];

      if (typeof moduleParams !== 'object' || moduleParams === null) {
        extend(allModulesParams, obj);
        return;
      }

      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }

      if (!(moduleParamName in params && 'enabled' in moduleParams)) {
        extend(allModulesParams, obj);
        return;
      }

      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }

      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }

      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend(allModulesParams, obj);
    };
  }

  /* eslint no-param-reassign: "off" */
  const prototypes = {
    eventsEmitter,
    update: update$1,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
    images
  };
  const extendedDefaults = {};

  class Swiper {
    constructor(...args) {
      let el;
      let params;

      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
        params = args[0];
      } else {
        [el, params] = args;
      }

      if (!params) params = {};
      params = extend({}, params);
      if (el && !params.el) params.el = el;

      if (params.el && $(params.el).length > 1) {
        const swipers = [];
        $(params.el).each(containerEl => {
          const newParams = extend({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        }); // eslint-disable-next-line no-constructor-return

        return swipers;
      } // Swiper Instance


      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];

      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }

      const allModulesParams = {};
      swiper.modules.forEach(mod => {
        mod({
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      }); // Extend defaults with modules params

      const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params

      swiper.params = extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend({}, swiper.params);
      swiper.passedParams = extend({}, params); // add event listeners

      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach(eventName => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }

      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      } // Save Dom lib


      swiper.$ = $; // Extend Swiper

      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],

        // isDirection
        isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },

        isVertical() {
          return swiper.params.direction === 'vertical';
        },

        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
          const desktop = ['pointerdown', 'pointermove', 'pointerup'];
          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit('_swiper'); // Init

      if (swiper.params.init) {
        swiper.init();
      } // Return app instance
      // eslint-disable-next-line no-constructor-return


      return swiper;
    }

    enable() {
      const swiper = this;
      if (swiper.enabled) return;
      swiper.enabled = true;

      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      swiper.emit('enable');
    }

    disable() {
      const swiper = this;
      if (!swiper.enabled) return;
      swiper.enabled = false;

      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }

      swiper.emit('disable');
    }

    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const cls = swiper.el.className.split(' ').filter(className => {
        return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit('_containerClasses', cls.join(' '));
    }

    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed) return '';
      return slideEl.className.split(' ').filter(className => {
        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(' ');
    }

    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const updates = [];
      swiper.slides.each(slideEl => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit('_slideClass', slideEl, classNames);
      });
      swiper.emit('_slideClasses', updates);
    }

    slidesPerViewDynamic(view = 'current', exact = false) {
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;

      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;

        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }

        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        // eslint-disable-next-line
        if (view === 'current') {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          // previous
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

            if (slideInView) {
              spv += 1;
            }
          }
        }
      }

      return spv;
    }

    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      let translated;

      if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    }

    changeDirection(newDirection, needUpdate = true) {
      const swiper = this;
      const currentDirection = swiper.params.direction;

      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }

      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }

      swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.each(slideEl => {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();
      return swiper;
    }

    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
      swiper.rtl = direction === 'rtl';
      swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;

      if (swiper.rtl) {
        swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = 'rtl';
      } else {
        swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = 'ltr';
      }

      swiper.update();
    }

    mount(el) {
      const swiper = this;
      if (swiper.mounted) return true; // Find el

      const $el = $(el || swiper.params.el);
      el = $el[0];

      if (!el) {
        return false;
      }

      el.swiper = swiper;

      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
      };

      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

          res.children = options => $el.children(options);

          return res;
        }

        if (!$el.children) {
          return $($el).children(getWrapperSelector());
        }

        return $el.children(getWrapperSelector());
      }; // Find Wrapper


      let $wrapperEl = getWrapper();

      if ($wrapperEl.length === 0 && swiper.params.createElements) {
        const document = getDocument();
        const wrapper = document.createElement('div');
        $wrapperEl = $(wrapper);
        wrapper.className = swiper.params.wrapperClass;
        $el.append(wrapper);
        $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
          $wrapperEl.append(slideEl);
        });
      }

      Object.assign(swiper, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box'
      });
      return true;
    }

    init(el) {
      const swiper = this;
      if (swiper.initialized) return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
      swiper.emit('afterInit');
      return swiper;
    }

    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper = this;
      const {
        params,
        $el,
        $wrapperEl,
        slides
      } = swiper;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(eventName => {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    }

    static extendDefaults(newDefaults) {
      extend(extendedDefaults, newDefaults);
    }

    static get extendedDefaults() {
      return extendedDefaults;
    }

    static get defaults() {
      return defaults;
    }

    static installModule(mod) {
      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
      const modules = Swiper.prototype.__modules__;

      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }

    static use(module) {
      if (Array.isArray(module)) {
        module.forEach(m => Swiper.installModule(m));
        return Swiper;
      }

      Swiper.installModule(module);
      return Swiper;
    }

  }

  Object.keys(prototypes).forEach(prototypeGroup => {
    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    const document = getDocument();

    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach(key => {
        if (!params[key] && params.auto === true) {
          let element = swiper.$el.children(`.${checkProps[key]}`)[0];

          if (!element) {
            element = document.createElement('div');
            element.className = checkProps[key];
            swiper.$el.append(element);
          }

          params[key] = element;
          originalParams[key] = element;
        }
      });
    }

    return params;
  }

  function Navigation({
    swiper,
    extendParams,
    on,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock',
        navigationDisabledClass: 'swiper-navigation-disabled'
      }
    });
    swiper.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    };

    function getEl(el) {
      let $el;

      if (el) {
        $el = $(el);

        if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
          $el = swiper.$el.find(el);
        }
      }

      return $el;
    }

    function toggleEl($el, disabled) {
      const params = swiper.params.navigation;

      if ($el && $el.length > 0) {
        $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
        if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }
    }

    function update() {
      // Update Navigation Buttons
      if (swiper.params.loop) return;
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
    }

    function onPrevClick(e) {
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slidePrev();
      emit('navigationPrev');
    }

    function onNextClick(e) {
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slideNext();
      emit('navigationNext');
    }

    function init() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: 'swiper-button-next',
        prevEl: 'swiper-button-prev'
      });
      if (!(params.nextEl || params.prevEl)) return;
      const $nextEl = getEl(params.nextEl);
      const $prevEl = getEl(params.prevEl);

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', onNextClick);
      }

      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', onPrevClick);
      }

      Object.assign(swiper.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });

      if (!swiper.enabled) {
        if ($nextEl) $nextEl.addClass(params.lockClass);
        if ($prevEl) $prevEl.addClass(params.lockClass);
      }
    }

    function destroy() {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;

      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }

      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }

    on('init', () => {
      if (swiper.params.navigation.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        update();
      }
    });
    on('toEdge fromEdge lock unlock', () => {
      update();
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;

      if ($nextEl) {
        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }

      if ($prevEl) {
        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }
    });
    on('click', (_s, e) => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      const targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        let isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          emit('navigationShow');
        } else {
          emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    });

    const enable = () => {
      swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
      init();
      update();
    };

    const disable = () => {
      swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
      destroy();
    };

    Object.assign(swiper.navigation, {
      enable,
      disable,
      update,
      init,
      destroy
    });
  }

  function classesToSelector(classes = '') {
    return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
  }

  function Pagination({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const pfx = 'swiper-pagination';
    extendParams({
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: number => number,
        formatFractionTotal: number => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;

    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
    }

    function setSideBullets($bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
    }

    function update() {
      // Render || Update Pagination bullets/items
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el; // Current/Total

      let current;
      const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }

        if (current > total - 1) current -= total;
        if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      } // Types


      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;

        if (params.dynamicBullets) {
          bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);

            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }

          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }

        bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

        if ($el.length > 1) {
          bullets.each(bullet => {
            const $bullet = $(bullet);
            const bulletIndex = $bullet.index();

            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }

            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }

              if (bulletIndex === firstIndex) {
                setSideBullets($bullet, 'prev');
              }

              if (bulletIndex === lastIndex) {
                setSideBullets($bullet, 'next');
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);

          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);

            for (let i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
            }

            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length) {
                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                }

                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            } else {
              setSideBullets($firstDisplayedBullet, 'prev');
              setSideBullets($lastDisplayedBullet, 'next');
            }
          }
        }

        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
        }
      }

      if (params.type === 'fraction') {
        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
      }

      if (params.type === 'progressbar') {
        let progressbarDirection;

        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }

        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;

        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }

        $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
      }

      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        emit('paginationRender', $el[0]);
      } else {
        emit('paginationUpdate', $el[0]);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }

    function render() {
      // Render Container
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el;
      let paginationHTML = '';

      if (params.type === 'bullets') {
        let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }

        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }

        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
      }

      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
        }

        $el.html(paginationHTML);
      }

      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }

        $el.html(paginationHTML);
      }

      if (params.type !== 'custom') {
        emit('paginationRender', swiper.pagination.$el[0]);
      }
    }

    function init() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: 'swiper-pagination'
      });
      const params = swiper.params.pagination;
      if (!params.el) return;
      let $el = $(params.el);
      if ($el.length === 0) return;

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
        $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

        if ($el.length > 1) {
          $el = $el.filter(el => {
            if ($(el).parents('.swiper')[0] !== swiper.el) return false;
            return true;
          });
        }
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);
      $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;

        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }

      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
          e.preventDefault();
          let index = $(this).index() * swiper.params.slidesPerGroup;
          if (swiper.params.loop) index += swiper.loopedSlides;
          swiper.slideTo(index);
        });
      }

      Object.assign(swiper.pagination, {
        $el,
        el: $el[0]
      });

      if (!swiper.enabled) {
        $el.addClass(params.lockClass);
      }
    }

    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

      if (params.clickable) {
        $el.off('click', classesToSelector(params.bulletClass));
      }
    }

    on('init', () => {
      if (swiper.params.pagination.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        render();
        update();
      }
    });
    on('activeIndexChange', () => {
      if (swiper.params.loop) {
        update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        update();
      }
    });
    on('snapIndexChange', () => {
      if (!swiper.params.loop) {
        update();
      }
    });
    on('slidesLengthChange', () => {
      if (swiper.params.loop) {
        render();
        update();
      }
    });
    on('snapGridLengthChange', () => {
      if (!swiper.params.loop) {
        render();
        update();
      }
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      const {
        $el
      } = swiper.pagination;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
      }
    });
    on('lock unlock', () => {
      update();
    });
    on('click', (_s, e) => {
      const targetEl = e.target;
      const {
        $el
      } = swiper.pagination;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          emit('paginationShow');
        } else {
          emit('paginationHide');
        }

        $el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    });

    const enable = () => {
      swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);

      if (swiper.pagination.$el) {
        swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
      }

      init();
      render();
      update();
    };

    const disable = () => {
      swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);

      if (swiper.pagination.$el) {
        swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
      }

      destroy();
    };

    Object.assign(swiper.pagination, {
      enable,
      disable,
      render,
      update,
      init,
      destroy
    });
  }

  function Scrollbar({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const document = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag',
        scrollbarDisabledClass: 'swiper-scrollbar-disabled',
        horizontalClass: `swiper-scrollbar-horizontal`,
        verticalClass: `swiper-scrollbar-vertical`
      }
    });
    swiper.scrollbar = {
      el: null,
      dragEl: null,
      $el: null,
      $dragEl: null
    };

    function setTranslate() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar,
        rtlTranslate: rtl,
        progress
      } = swiper;
      const {
        $dragEl,
        $el
      } = scrollbar;
      const params = swiper.params.scrollbar;
      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;

      if (rtl) {
        newPos = -newPos;

        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }

      if (swiper.isHorizontal()) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
        $dragEl[0].style.width = `${newSize}px`;
      } else {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
        $dragEl[0].style.height = `${newSize}px`;
      }

      if (params.hide) {
        clearTimeout(timeout);
        $el[0].style.opacity = 1;
        timeout = setTimeout(() => {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    }

    function setTransition(duration) {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      swiper.scrollbar.$dragEl.transition(duration);
    }

    function updateSize() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar
      } = swiper;
      const {
        $dragEl,
        $el
      } = scrollbar;
      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = `${dragSize}px`;
      } else {
        $dragEl[0].style.height = `${dragSize}px`;
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }

      if (swiper.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
      }
    }

    function getPointerPosition(e) {
      if (swiper.isHorizontal()) {
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
      }

      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
    }

    function setDragPosition(e) {
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        $el
      } = scrollbar;
      let positionRatio;
      positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);

      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    function onDragStart(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el,
        $dragEl
      } = scrollbar;
      isTouched = true;
      dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      setDragPosition(e);
      clearTimeout(dragTimeout);
      $el.transition(0);

      if (params.hide) {
        $el.css('opacity', 1);
      }

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', 'none');
      }

      emit('scrollbarDragStart', e);
    }

    function onDragMove(e) {
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el,
        $dragEl
      } = scrollbar;
      if (!isTouched) return;
      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      emit('scrollbarDragMove', e);
    }

    function onDragEnd(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el
      } = scrollbar;
      if (!isTouched) return;
      isTouched = false;

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', '');
        $wrapperEl.transition('');
      }

      if (params.hide) {
        clearTimeout(dragTimeout);
        dragTimeout = nextTick(() => {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }

      emit('scrollbarDragEnd', e);

      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    }

    function events(method) {
      const {
        scrollbar,
        touchEventsTouch,
        touchEventsDesktop,
        params,
        support
      } = swiper;
      const $el = scrollbar.$el;
      if (!$el) return;
      const target = $el[0];
      const activeListener = support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      const passiveListener = support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (!target) return;
      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

      if (!support.touch) {
        target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
        document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
        document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
      } else {
        target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
        target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
        target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
      }
    }

    function enableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      events('on');
    }

    function disableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      events('off');
    }

    function init() {
      const {
        scrollbar,
        $el: $swiperEl
      } = swiper;
      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
        el: 'swiper-scrollbar'
      });
      const params = swiper.params.scrollbar;
      if (!params.el) return;
      let $el = $(params.el);

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

      if ($dragEl.length === 0) {
        $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
        $el.append($dragEl);
      }

      Object.assign(scrollbar, {
        $el,
        el: $el[0],
        $dragEl,
        dragEl: $dragEl[0]
      });

      if (params.draggable) {
        enableDraggable();
      }

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
      }
    }

    function destroy() {
      const params = swiper.params.scrollbar;
      const $el = swiper.scrollbar.$el;

      if ($el) {
        $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      }

      disableDraggable();
    }

    on('init', () => {
      if (swiper.params.scrollbar.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        updateSize();
        setTranslate();
      }
    });
    on('update resize observerUpdate lock unlock', () => {
      updateSize();
    });
    on('setTranslate', () => {
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      setTransition(duration);
    });
    on('enable disable', () => {
      const {
        $el
      } = swiper.scrollbar;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
      }
    });
    on('destroy', () => {
      destroy();
    });

    const enable = () => {
      swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);

      if (swiper.scrollbar.$el) {
        swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
      }

      init();
      updateSize();
      setTranslate();
    };

    const disable = () => {
      swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);

      if (swiper.scrollbar.$el) {
        swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
      }

      destroy();
    };

    Object.assign(swiper.scrollbar, {
      enable,
      disable,
      updateSize,
      setTranslate,
      init,
      destroy
    });
  }

  /* eslint no-underscore-dangle: "off" */

  function Autoplay({
    swiper,
    extendParams,
    on,
    emit
  }) {
    let timeout;
    swiper.autoplay = {
      running: false,
      paused: false
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });

    function run() {
      if (!swiper.size) {
        swiper.autoplay.running = false;
        swiper.autoplay.paused = false;
        return;
      }

      const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      let delay = swiper.params.autoplay.delay;

      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }

      clearTimeout(timeout);
      timeout = nextTick(() => {
        let autoplayResult;

        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isBeginning) {
            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.isEnd) {
          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
          emit('autoplay');
        } else {
          stop();
        }

        if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
          run();
        }
      }, delay);
    }

    function start() {
      if (typeof timeout !== 'undefined') return false;
      if (swiper.autoplay.running) return false;
      swiper.autoplay.running = true;
      emit('autoplayStart');
      run();
      return true;
    }

    function stop() {
      if (!swiper.autoplay.running) return false;
      if (typeof timeout === 'undefined') return false;

      if (timeout) {
        clearTimeout(timeout);
        timeout = undefined;
      }

      swiper.autoplay.running = false;
      emit('autoplayStop');
      return true;
    }

    function pause(speed) {
      if (!swiper.autoplay.running) return;
      if (swiper.autoplay.paused) return;
      if (timeout) clearTimeout(timeout);
      swiper.autoplay.paused = true;

      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        run();
      } else {
        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
        });
      }
    }

    function onVisibilityChange() {
      const document = getDocument();

      if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
        pause();
      }

      if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
        run();
        swiper.autoplay.paused = false;
      }
    }

    function onTransitionEnd(e) {
      if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
      if (e.target !== swiper.$wrapperEl[0]) return;
      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
      });
      swiper.autoplay.paused = false;

      if (!swiper.autoplay.running) {
        stop();
      } else {
        run();
      }
    }

    function onMouseEnter() {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        emit('autoplayPause');
        pause();
      }

      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
      });
    }

    function onMouseLeave() {
      if (swiper.params.autoplay.disableOnInteraction) {
        return;
      }

      swiper.autoplay.paused = false;
      emit('autoplayResume');
      run();
    }

    function attachMouseEvents() {
      if (swiper.params.autoplay.pauseOnMouseEnter) {
        swiper.$el.on('mouseenter', onMouseEnter);
        swiper.$el.on('mouseleave', onMouseLeave);
      }
    }

    function detachMouseEvents() {
      swiper.$el.off('mouseenter', onMouseEnter);
      swiper.$el.off('mouseleave', onMouseLeave);
    }

    on('init', () => {
      if (swiper.params.autoplay.enabled) {
        start();
        const document = getDocument();
        document.addEventListener('visibilitychange', onVisibilityChange);
        attachMouseEvents();
      }
    });
    on('beforeTransitionStart', (_s, speed, internal) => {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          stop();
        }
      }
    });
    on('sliderFirstMove', () => {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }
      }
    });
    on('touchEnd', () => {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        run();
      }
    });
    on('destroy', () => {
      detachMouseEvents();

      if (swiper.autoplay.running) {
        stop();
      }

      const document = getDocument();
      document.removeEventListener('visibilitychange', onVisibilityChange);
    });
    Object.assign(swiper.autoplay, {
      pause,
      run,
      start,
      stop
    });
  }

  function effectInit(params) {
    const {
      effect,
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on('beforeInit', () => {
      if (swiper.params.effect !== effect) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

      if (perspective && perspective()) {
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      }

      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper.params, overwriteParamsResult);
      Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on('setTranslate', () => {
      if (swiper.params.effect !== effect) return;
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      if (swiper.params.effect !== effect) return;
      setTransition(duration);
    });
    on('transitionEnd', () => {
      if (swiper.params.effect !== effect) return;

      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows) return; // remove shadows

        swiper.slides.each(slideEl => {
          const $slideEl = swiper.$(slideEl);
          $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
        }); // create new one

        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on('virtualUpdate', () => {
      if (swiper.params.effect !== effect) return;

      if (!swiper.slides.length) {
        requireUpdateOnVirtual = true;
      }

      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
          setTranslate();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  function effectTarget(effectParams, $slideEl) {
    if (effectParams.transformEl) {
      return $slideEl.find(effectParams.transformEl).css({
        'backface-visibility': 'hidden',
        '-webkit-backface-visibility': 'hidden'
      });
    }

    return $slideEl;
  }

  function effectVirtualTransitionEnd({
    swiper,
    duration,
    transformEl,
    allSlides
  }) {
    const {
      slides,
      activeIndex,
      $wrapperEl
    } = swiper;

    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let $transitionEndTarget;

      if (allSlides) {
        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
      } else {
        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
      }

      $transitionEndTarget.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }

  function EffectFade({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      fadeEffect: {
        crossFade: false,
        transformEl: null
      }
    });

    const setTranslate = () => {
      const {
        slides
      } = swiper;
      const params = swiper.params.fadeEffect;

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = swiper.slides.eq(i);
        const offset = $slideEl[0].swiperSlideOffset;
        let tx = -offset;
        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
        let ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }

        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.css({
          opacity: slideOpacity
        }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.fadeEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration);
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformEl,
        allSlides: true
      });
    };

    effectInit({
      effect: 'fade',
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  document.head.appendChild(document.createElement("style")).textContent="/**\n * Swiper 8.4.7\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: January 30, 2023\n */\n\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-virtual .swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl .swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-next+.swiper-slide,.swiper-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-flip{overflow:visible}.swiper-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative .swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards .swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}";

  function e(e,t){for(var o=0;o<t.length;o++){var n=t[o];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function t(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return o(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return o(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var o=0,n=new Array(t);o<t;o++)n[o]=e[o];return n}var n,i,a,r,s,l=(n=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","[contenteditable]",'[tabindex]:not([tabindex^="-"])'],i=function(){function o(e){var n=e.targetModal,i=e.triggers,a=void 0===i?[]:i,r=e.onShow,s=void 0===r?function(){}:r,l=e.onClose,c=void 0===l?function(){}:l,d=e.openTrigger,u=void 0===d?"data-micromodal-trigger":d,f=e.closeTrigger,h=void 0===f?"data-micromodal-close":f,v=e.openClass,g=void 0===v?"is-open":v,m=e.disableScroll,b=void 0!==m&&m,y=e.disableFocus,p=void 0!==y&&y,w=e.awaitCloseAnimation,E=void 0!==w&&w,k=e.awaitOpenAnimation,M=void 0!==k&&k,A=e.debugMode,C=void 0!==A&&A;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.modal=document.getElementById(n),this.config={debugMode:C,disableScroll:b,openTrigger:u,closeTrigger:h,openClass:g,onShow:s,onClose:c,awaitCloseAnimation:E,awaitOpenAnimation:M,disableFocus:p},a.length>0&&this.registerTriggers.apply(this,t(a)),this.onClick=this.onClick.bind(this),this.onKeydown=this.onKeydown.bind(this);}var i,a;return i=o,(a=[{key:"registerTriggers",value:function(){for(var e=this,t=arguments.length,o=new Array(t),n=0;n<t;n++)o[n]=arguments[n];o.filter(Boolean).forEach((function(t){t.addEventListener("click",(function(t){return e.showModal(t)}));}));}},{key:"showModal",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this.activeElement=document.activeElement,this.modal.setAttribute("aria-hidden","false"),this.modal.classList.add(this.config.openClass),this.scrollBehaviour("disable"),this.addEventListeners(),this.config.awaitOpenAnimation){var o=function t(){e.modal.removeEventListener("animationend",t,!1),e.setFocusToFirstNode();};this.modal.addEventListener("animationend",o,!1);}else this.setFocusToFirstNode();this.config.onShow(this.modal,this.activeElement,t);}},{key:"closeModal",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=this.modal;if(this.modal.setAttribute("aria-hidden","true"),this.removeEventListeners(),this.scrollBehaviour("enable"),this.activeElement&&this.activeElement.focus&&this.activeElement.focus(),this.config.onClose(this.modal,this.activeElement,e),this.config.awaitCloseAnimation){var o=this.config.openClass;this.modal.addEventListener("animationend",(function e(){t.classList.remove(o),t.removeEventListener("animationend",e,!1);}),!1);}else t.classList.remove(this.config.openClass);}},{key:"closeModalById",value:function(e){this.modal=document.getElementById(e),this.modal&&this.closeModal();}},{key:"scrollBehaviour",value:function(e){if(this.config.disableScroll){var t=document.querySelector("body");switch(e){case"enable":Object.assign(t.style,{overflow:""});break;case"disable":Object.assign(t.style,{overflow:"hidden"});}}}},{key:"addEventListeners",value:function(){this.modal.addEventListener("touchstart",this.onClick),this.modal.addEventListener("click",this.onClick),document.addEventListener("keydown",this.onKeydown);}},{key:"removeEventListeners",value:function(){this.modal.removeEventListener("touchstart",this.onClick),this.modal.removeEventListener("click",this.onClick),document.removeEventListener("keydown",this.onKeydown);}},{key:"onClick",value:function(e){(e.target.hasAttribute(this.config.closeTrigger)||e.target.parentNode.hasAttribute(this.config.closeTrigger))&&(e.preventDefault(),e.stopPropagation(),this.closeModal(e));}},{key:"onKeydown",value:function(e){27===e.keyCode&&this.closeModal(e),9===e.keyCode&&this.retainFocus(e);}},{key:"getFocusableNodes",value:function(){var e=this.modal.querySelectorAll(n);return Array.apply(void 0,t(e))}},{key:"setFocusToFirstNode",value:function(){var e=this;if(!this.config.disableFocus){var t=this.getFocusableNodes();if(0!==t.length){var o=t.filter((function(t){return !t.hasAttribute(e.config.closeTrigger)}));o.length>0&&o[0].focus(),0===o.length&&t[0].focus();}}}},{key:"retainFocus",value:function(e){var t=this.getFocusableNodes();if(0!==t.length)if(t=t.filter((function(e){return null!==e.offsetParent})),this.modal.contains(document.activeElement)){var o=t.indexOf(document.activeElement);e.shiftKey&&0===o&&(t[t.length-1].focus(),e.preventDefault()),!e.shiftKey&&t.length>0&&o===t.length-1&&(t[0].focus(),e.preventDefault());}else t[0].focus();}}])&&e(i.prototype,a),o}(),a=null,r=function(e){if(!document.getElementById(e))return console.warn("MicroModal: Seems like you have missed %c'".concat(e,"'"),"background-color: #f8f9fa;color: #50596c;font-weight: bold;","ID somewhere in your code. Refer example below to resolve it."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<div class="modal" id="'.concat(e,'"></div>')),!1},s=function(e,t){if(function(e){e.length<=0&&(console.warn("MicroModal: Please specify at least one %c'micromodal-trigger'","background-color: #f8f9fa;color: #50596c;font-weight: bold;","data attribute."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<a href="#" data-micromodal-trigger="my-modal"></a>'));}(e),!t)return !0;for(var o in t)r(o);return !0},{init:function(e){var o=Object.assign({},{openTrigger:"data-micromodal-trigger"},e),n=t(document.querySelectorAll("[".concat(o.openTrigger,"]"))),r=function(e,t){var o=[];return e.forEach((function(e){var n=e.attributes[t].value;void 0===o[n]&&(o[n]=[]),o[n].push(e);})),o}(n,o.openTrigger);if(!0!==o.debugMode||!1!==s(n,r))for(var l in r){var c=r[l];o.targetModal=l,o.triggers=t(c),a=new i(o);}},show:function(e,t){var o=t||{};o.targetModal=e,!0===o.debugMode&&!1===r(e)||(a&&a.removeEventListeners(),(a=new i(o)).showModal());},close:function(e){e?a.closeModalById(e):a.closeModal();}});"undefined"!=typeof window&&(window.MicroModal=l);

  Swiper.use([Navigation, Pagination, Autoplay, Scrollbar, EffectFade]);

  /*
   * common
   * 
   */
  var common = /*#__PURE__*/function () {
    function common() {
      _classCallCheck(this, common);
      gsapWithCSS.registerPlugin(ScrollTrigger$1);
      // barba.hooks.beforeOnce((data) => {
      //     console.log('once')
      //     this.load();
      // })
      // barba.hooks.after((data) => {
      //     console.log('after')
      //     this.load();
      // });
    }
    return _createClass$1(common, [{
      key: "load",
      value: function load() {
        console.log('load');
        // const osInstance = OverlayScrollbars(document.querySelector('body'), {
        //     showNativeOverlaidScrollbars: true,
        // });

        this.loader();
        this.scrollEvent();
        this.setDeviceClassToBody();
        this.globalMenu();
        this.smoothScroll();
        // this.cMouseStalker();
        this.jsSplitText();
        this.jsClone();
        this.jsStickySection();
        this.jsAccordion();
        this.isSectionDark();
        this.jsTab();
        this.jsSwiper();
        this.jsParallax();
        // this.isSectionDark();
        this.isVisible();
        this.isVisibleType();
        l.init({
          // disableScroll: true,
          onClose: function onClose(modal) {
            // iframe
            var iframe = modal.querySelector('iframe');
            if (iframe) {
              iframe.remove();
            }
          }
        });
        this.jsModalVideo();
        this.jsPlayAudio();
      }
    }, {
      key: "reload",
      value: function reload() {}

      /*
       * loader()
       * 
       */
    }, {
      key: "loader",
      value: function loader() {
        var loadedClass = 'loadedLower';
        var classNameScroll = 'is-scrolled';
        var marginScrolled = 300;
        setTimeout(function () {
          document.body.classList.add(loadedClass);
        }, 500);
        var handleScroll = function handleScroll() {
          if (window.scrollY > marginScrolled) {
            document.body.classList.add(classNameScroll);
          } else {
            document.body.classList.remove(classNameScroll);
          }
        };
        window.addEventListener('scroll', handleScroll);
        window.addEventListener('resize', handleScroll);
        window.addEventListener('orientationchange', handleScroll);
      }

      /*
       * scrollEvent
       * 
       */
    }, {
      key: "scrollEvent",
      value: function scrollEvent() {
        var defPos = 0;
        var ticking = false;
        window.addEventListener('scroll', function () {
          if (!ticking) {
            ticking = true;
            requestAnimationFrame(function () {
              addBodyScrollClass();
              ticking = false;
            });
          }
        });
        function addBodyScrollClass() {
          var currentPos = window.scrollY;
          if (currentPos > defPos) {
            if (currentPos >= 200) {
              document.body.classList.add('scrollDown');
              document.body.classList.remove('scrollUp');
            }
          } else {
            document.body.classList.remove('scrollDown');
            document.body.classList.add('scrollUp');
          }
          defPos = currentPos;
        }

        // footerScrollTrigger
        var footer = document.querySelector('.l-footer');
        if (footer) {
          ScrollTrigger$1.create({
            trigger: footer,
            start: 'top bottom',
            onEnter: function onEnter() {
              return document.body.classList.add('is-footer-show');
            },
            onLeaveBack: function onLeaveBack() {
              return document.body.classList.remove('is-footer-show');
            }
          });
        }
      }

      /*
       * globalMenu
       * 
       */
    }, {
      key: "globalMenu",
      value: function globalMenu() {
        var classNameNavOpen = 'is-nav-open';
        var classNameNavClose = 'is-nav-closing';
        var header = document.querySelector('.l-header');
        var headerMenu = document.querySelector('.l-header-menu');
        if (!header || !headerMenu) return;
        headerMenu.addEventListener('click', function () {
          headerMenu.classList.toggle(classNameNavOpen);
          if (headerMenu.classList.contains(classNameNavOpen)) {
            document.body.classList.add(classNameNavOpen);
          } else {
            navClose();
          }
        });
        var headerLinks = header.querySelectorAll('a');
        headerLinks.forEach(function (link) {
          link.addEventListener('click', function () {
            headerMenu.classList.remove(classNameNavOpen);
            navClose();
          });
        });

        // 
        function navClose() {
          document.body.classList.remove(classNameNavOpen);
          document.body.classList.add(classNameNavClose);
          setTimeout(function () {
            document.body.classList.remove(classNameNavClose);
          }, 600);
        }

        // Esc
        window.addEventListener('keydown', function (event) {
          if (event.key === 'Escape' || event.keyCode === 27) {
            headerMenu.classList.remove(classNameNavOpen);
            navClose();
          }
        });
      }

      /*
       * smoothScroll
       * 
       */
    }, {
      key: "smoothScroll",
      value: function smoothScroll() {
        var anchors = document.querySelectorAll('a[data-scroll-anchor]:not(.noscroll)');
        anchors.forEach(function (anchor) {
          anchor.addEventListener('click', function (e) {
            e.preventDefault();
            var href = anchor.getAttribute('href');
            var index = href.indexOf('#');
            if (index === -1) return;
            var targetSelector = href.slice(index);
            var target = document.querySelector(targetSelector);
            if (!target) return;
            var targetPos = target.getBoundingClientRect().top + window.pageYOffset;
            var currentScroll = window.pageYOffset;
            var scroll = Math.abs(currentScroll - targetPos);
            var duration = 0.7 * scroll;
            if (duration > 300) {
              duration = 300;
            }

            // 
            window.scrollTo({
              top: targetPos,
              behavior: 'smooth'
            });

            // URL
            setTimeout(function () {
              history.pushState(null, '', href);
            }, duration);
          });
        });
      }
    }, {
      key: "cMouseStalker",
      value: function cMouseStalker() {
        var btn = document.querySelector('.c-btn-stalker');
        var circle = document.querySelector('.c-btn-stalker__circle');
        var ico = document.querySelector('.c-btn-stalker__ico');
        var stalkerTriggers = document.querySelectorAll('.js-stalker-show');
        if (btn && ScrollTrigger$1.isTouch !== 1) {
          document.addEventListener('mousemove', function (e) {
            var shift = btn.offsetWidth / 2;
            gsapWithCSS.to(circle, {
              x: e.clientX - shift,
              y: e.clientY - shift,
              ease: 'power1.out'
            });
            gsapWithCSS.to(ico, {
              x: e.clientX - shift,
              y: e.clientY - shift,
              ease: 'power1.out',
              delay: 0.005
            });
          });
          stalkerTriggers.forEach(function (trigger) {
            trigger.addEventListener('mouseover', function () {
              btn.classList.add('on-stalker-show');
            });
            trigger.addEventListener('mouseout', function () {
              btn.classList.remove('on-stalker-show');
            });
          });
        }
      }
    }, {
      key: "jsClone",
      value: function jsClone() {
        var elements = document.querySelectorAll('.js-clone');
        elements.forEach(function (el) {
          // data-clone-num 
          var cloneNum = parseInt(el.dataset.cloneNum, 10) || 1;
          for (var i = 0; i < cloneNum; i++) {
            var clone = el.cloneNode(true);
            clone.setAttribute('aria-hidden', 'true');
            el.parentNode.insertBefore(clone, el.nextSibling);
          }
        });
      }
    }, {
      key: "jsSplitText",
      value: function jsSplitText() {
        var domList = document.querySelectorAll('.js-split-text');
        if (domList.length) {
          domList.forEach(function (el) {
            Utility.convertSpiltSpan(el);
          });
        }
      }
    }, {
      key: "jsStickySection",
      value: function jsStickySection() {
        var container = document.querySelector('.js-sticky-section__content');
        var aside = document.querySelector('.js-sticky-section__aside');
        var asideLis = document.querySelectorAll('.js-sticky-section__aside li');
        var sections = document.querySelectorAll('.js-sticky-section__content section');
        if (container && Utility.isPC()) {
          window.addEventListener('load', function () {
            sections.forEach(function (section, index) {
              ScrollTrigger$1.create({
                trigger: section,
                start: 'top top+=160px',
                end: 'bottom top+=160px',
                markers: false,
                onEnter: function onEnter() {
                  updateAside(index);
                },
                onEnterBack: function onEnterBack() {
                  updateAside(index);
                }
              });
            });
            function updateAside(index) {
              // li current 
              asideLis.forEach(function (li) {
                return li.classList.remove('is-current');
              });
              if (asideLis[index]) {
                asideLis[index].classList.add('is-current');
              }

              // aside  index 
              aside.classList.forEach(function (cls) {
                if (cls.startsWith('index')) {
                  aside.classList.remove(cls);
                }
              });
              aside.classList.add("index".concat(index));
            }
          });
        }
      }
    }, {
      key: "jsAccordion",
      value: function jsAccordion() {
        // vars
        var btn = '.js-accordion';

        // functions
        if ($$1(btn).length) {
          $$1(btn).on('click', function (e) {
            e.preventDefault();
            var isFlex = $$1(this).attr('data-accordion-flex') ? true : false;
            $$1(this).toggleClass('is-open');
            if ($$1(this).hasClass('is-open')) {
              if (isFlex) {
                $$1(this).next().stop(0, 0).slideDown({
                  start: function start() {
                    $$1(this).css({
                      display: "flex"
                    });
                  }
                }, 300);
              } else {
                $$1(this).next().stop(0, 0).slideDown(300);
              }
            } else {
              $$1(this).next().stop(0, 0).slideUp(300);
            }
          });
        }
      }
    }, {
      key: "jsTab",
      value: function jsTab() {
        document.querySelectorAll('.js-tab').forEach(function (container) {
          var tabs = container.querySelectorAll('.js-tabBtn');
          var contents = container.querySelectorAll('.js-tabContent');
          tabs.forEach(function (tab, index) {
            tab.addEventListener('click', function () {
              tabs.forEach(function (t) {
                return t.classList.remove('is-active');
              });
              contents.forEach(function (c) {
                return c.classList.remove('is-active');
              });
              tab.classList.add('is-active');
              contents[index].classList.add('is-active');
            });
          });
          if (tabs.length > 0 && contents.length > 0) {
            tabs[0].classList.add('is-active');
            contents[0].classList.add('is-active');
          }
        });
      }
    }, {
      key: "jsSwiper",
      value: function jsSwiper() {
        var swiperAll = document.querySelectorAll('.js-swiper');
        swiperAll.forEach(function (wrapper) {
          var elm = wrapper.querySelector('.swiper');
          if (!elm) return;
          var paginationEl = wrapper.querySelector('.swiper-pagination');
          var prevEl = wrapper.querySelector('.swiper-prev');
          var nextEl = wrapper.querySelector('.swiper-next');

          // functions
          new Swiper(elm, {
            loop: true,
            loopAdditionalSlides: wrapper.querySelectorAll('.swiper-slide').length,
            slidesPerView: 1,
            spaceBetween: 0,
            speed: 800,
            // effect: 'fade',
            // fadeEffect: {
            //     crossFade: true,
            // },
            autoplay: wrapper.dataset.autoplay ? {
              delay: 4000,
              disableOnInteraction: false
            } : false,
            pagination: paginationEl ? {
              el: paginationEl,
              clickable: true
            } : false,
            navigation: prevEl && nextEl ? {
              prevEl: prevEl,
              nextEl: nextEl
            } : false
          });
        });
      }
    }, {
      key: "jsParallax",
      value: function jsParallax() {
        gsapWithCSS.utils.toArray('.js-parallax').forEach(function (el) {
          var parent = el.parentElement;
          var baseY = Number(el.dataset.y) || -10;
          var rate = Utility.isPC() ? 1 : 0.75;
          var moveY = baseY * rate;
          var half = moveY / 2;
          gsapWithCSS.fromTo(el, {
            y: "".concat(-half, "vh")
          }, {
            y: "".concat(half, "vh"),
            ease: 'none',
            scrollTrigger: {
              trigger: parent,
              start: 'top bottom',
              // end: () => `top+=${Math.max(window.innerHeight, el.offsetHeight)} top`,
              end: function end() {
                return "bottom top";
              },
              scrub: 1.5,
              invalidateOnRefresh: true,
              markers: false
            }
          });
        });
      }
    }, {
      key: "isSectionDark",
      value: function isSectionDark() {
        var shift = Utility.isPC() ? 114 / 1440 * window.innerWidth / 2 : 70 / 375 * window.innerWidth / 2;
        document.querySelectorAll('.is-section-dark, .cm-section-header--hasBG').forEach(function (section) {
          ScrollTrigger$1.create({
            trigger: section,
            start: "top-=".concat(shift, " top"),
            end: "bottom-=".concat(shift, " top"),
            markers: false,
            onEnter: function onEnter() {
              return document.body.classList.add('is-header-dark');
            },
            onLeave: function onLeave() {
              return document.body.classList.remove('is-header-dark');
            },
            onEnterBack: function onEnterBack() {
              return document.body.classList.add('is-header-dark');
            },
            onLeaveBack: function onLeaveBack() {
              return document.body.classList.remove('is-header-dark');
            }
          });
        });
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        var elements = document.querySelectorAll('.js-visible');
        elements.forEach(function (el) {
          ScrollTrigger$1.create({
            trigger: el,
            toggleClass: 'is-visible',
            start: 'top bottom-=20%',
            once: true
          });
        });
      }
    }, {
      key: "isVisibleType",
      value: function isVisibleType() {
        var domList = document.querySelectorAll('.js-visible-type');
        if (domList.length) {
          domList.forEach(function (el) {
            Utility.convertSpiltSpan(el);
          });
          domList.forEach(function (el) {
            var spans = el.querySelectorAll('span');
            gsapWithCSS.set(spans, {
              opacity: 0,
              y: '20%'
            });
            gsapWithCSS.to(spans, {
              scrollTrigger: {
                trigger: el,
                start: 'top bottom-=20%'
              },
              delay: 0.5,
              opacity: 1,
              y: '0%',
              stagger: 0.03,
              ease: 'power3.out' // typo 'poser3.out'  'power3.out'
            });
          });
        }
      }
    }, {
      key: "jsModalVideo",
      value: function jsModalVideo() {
        document.addEventListener('DOMContentLoaded', function () {
          var modal = document.getElementById('modal-movie');
          var iframeContainer = modal.querySelector('#modal-movie-iframe');
          var triggers = document.querySelectorAll('.jsModalVideo');
          triggers.forEach(function (trigger) {
            trigger.addEventListener('click', function () {
              var youtubeId = this.getAttribute('data-video-id');
              var src = "https://www.youtube.com/embed/".concat(youtubeId, "?autoplay=1&rel=0");
              iframeContainer.innerHTML = "\n    <iframe width=\"560\" height=\"315\"\n      src=\"".concat(src, "\"\n      title=\"YouTube video player\"\n      frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n      allowfullscreen\n    ></iframe>\n  ");
            });
          });
        });
      }
    }, {
      key: "jsPlayAudio",
      value: function jsPlayAudio() {
        document.addEventListener('DOMContentLoaded', function () {
          var audio = document.getElementById('media-audio');
          var btns = document.querySelectorAll('.jsPlayAudio');
          btns.forEach(function (btn) {
            var currentSrc = null;
            btn.addEventListener('click', function () {
              var src = btn.dataset.audio;
              if (currentSrc !== src) {
                audio.src = src;
                currentSrc = src;
              }
              if (audio.paused) {
                audio.play();
                btn.classList.add('is-playing');
                btn.setAttribute('aria-label', '');
              } else {
                audio.pause();
                btn.classList.remove('is-playing');
                btn.setAttribute('aria-label', '');
              }
            });
          });
          audio.addEventListener('ended', function () {
            btns.forEach(function (btn) {
              return btn.classList.remove('is-playing');
            });
          });
        });
      }

      /*globalMenu
       * setDeviceClassToBody
       * 
       */
    }, {
      key: "setDeviceClassToBody",
      value: function setDeviceClassToBody() {
        var updateBodyClass = function updateBodyClass() {
          var body = document.body;
          body.classList.toggle('isSP', Utility.isSP());
          body.classList.toggle('isTAB', Utility.isTAB());
          body.classList.toggle('isPC', Utility.isPC());
        };

        // 
        window.addEventListener('load', updateBodyClass);
        window.addEventListener('resize', updateBodyClass);
        window.addEventListener('orientationchange', updateBodyClass);
      }
    }]);
  }();

  /*!
   * ScrollToPlugin 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var gsap,
      _coreInitted,
      _window,
      _docEl,
      _body,
      _toArray,
      _config,
      ScrollTrigger,
      _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
      _getGSAP = function _getGSAP() {
    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
      _isString = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
      _max = function _max(element, axis) {
    var dim = axis === "x" ? "Width" : "Height",
        scroll = "scroll" + dim,
        client = "client" + dim;
    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
  },
      _buildGetter = function _buildGetter(e, axis) {
    //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
    var p = "scroll" + (axis === "x" ? "Left" : "Top");

    if (e === _window) {
      if (e.pageXOffset != null) {
        p = "page" + axis.toUpperCase() + "Offset";
      } else {
        e = _docEl[p] != null ? _docEl : _body;
      }
    }

    return function () {
      return e[p];
    };
  },
      _clean = function _clean(value, index, target, targets) {
    _isFunction(value) && (value = value(index, target, targets));

    if (typeof value !== "object") {
      return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
        x: value,
        y: value
      } : {
        y: value
      }; //if we don't receive an object as the parameter, assume the user intends "y".
    } else if (value.nodeType) {
      return {
        y: value,
        x: value
      };
    } else {
      var result = {},
          p;

      for (p in value) {
        result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
      }

      return result;
    }
  },
      _getOffset = function _getOffset(element, container) {
    element = _toArray(element)[0];

    if (!element || !element.getBoundingClientRect) {
      return console.warn("scrollTo target doesn't exist. Using 0") || {
        x: 0,
        y: 0
      };
    }

    var rect = element.getBoundingClientRect(),
        isRoot = !container || container === _window || container === _body,
        cRect = isRoot ? {
      top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
      left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
    } : container.getBoundingClientRect(),
        offsets = {
      x: rect.left - cRect.left,
      y: rect.top - cRect.top
    };

    if (!isRoot && container) {
      //only add the current scroll position if it's not the window/body.
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }

    return offsets;
  },
      _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
    return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
  },
      _initCore = function _initCore() {
    gsap = _getGSAP();

    if (_windowExists() && gsap && typeof document !== "undefined" && document.body) {
      _window = window;
      _body = document.body;
      _docEl = document.documentElement;
      _toArray = gsap.utils.toArray;
      gsap.config({
        autoKillThreshold: 7
      });
      _config = gsap.config();
      _coreInitted = 1;
    }
  };

  var ScrollToPlugin = {
    version: "3.14.2",
    name: "scrollTo",
    rawVars: 1,
    register: function register(core) {
      gsap = core;

      _initCore();
    },
    init: function init(target, value, tween, index, targets) {
      _coreInitted || _initCore();
      var data = this,
          snapType = gsap.getProperty(target, "scrollSnapType");
      data.isWin = target === _window;
      data.target = target;
      data.tween = tween;
      value = _clean(value, index, target, targets);
      data.vars = value;
      data.autoKill = !!("autoKill" in value ? value : _config).autoKill;
      data.getX = _buildGetter(target, "x");
      data.getY = _buildGetter(target, "y");
      data.x = data.xPrev = data.getX();
      data.y = data.yPrev = data.getY();
      ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);
      gsap.getProperty(target, "scrollBehavior") === "smooth" && gsap.set(target, {
        scrollBehavior: "auto"
      });

      if (snapType && snapType !== "none") {
        // disable scroll snapping to avoid strange behavior
        data.snap = 1;
        data.snapInline = target.style.scrollSnapType;
        target.style.scrollSnapType = "none";
      }

      if (value.x != null) {
        data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

        data._props.push("scrollTo_x");
      } else {
        data.skipX = 1;
      }

      if (value.y != null) {
        data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

        data._props.push("scrollTo_y");
      } else {
        data.skipY = 1;
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt,
          target = data.target,
          tween = data.tween,
          autoKill = data.autoKill,
          xPrev = data.xPrev,
          yPrev = data.yPrev,
          isWin = data.isWin,
          snap = data.snap,
          snapInline = data.snapInline,
          x,
          y,
          yDif,
          xDif,
          threshold;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      x = isWin || !data.skipX ? data.getX() : xPrev;
      y = isWin || !data.skipY ? data.getY() : yPrev;
      yDif = y - yPrev;
      xDif = x - xPrev;
      threshold = _config.autoKillThreshold;

      if (data.x < 0) {
        //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
        data.x = 0;
      }

      if (data.y < 0) {
        data.y = 0;
      }

      if (autoKill) {
        //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
        if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
          data.skipX = 1; //if the user scrolls separately, we should stop tweening!
        }

        if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
          data.skipY = 1; //if the user scrolls separately, we should stop tweening!
        }

        if (data.skipX && data.skipY) {
          tween.kill();
          data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
        }
      }

      if (isWin) {
        _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
      } else {
        data.skipY || (target.scrollTop = data.y);
        data.skipX || (target.scrollLeft = data.x);
      }

      if (snap && (ratio === 1 || ratio === 0)) {
        y = target.scrollTop;
        x = target.scrollLeft;
        snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
        target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.

        target.scrollLeft = x + 1;
        target.scrollTop = y;
        target.scrollLeft = x;
      }

      data.xPrev = data.x;
      data.yPrev = data.y;
      ScrollTrigger && ScrollTrigger.update();
    },
    kill: function kill(property) {
      var both = property === "scrollTo",
          i = this._props.indexOf(property);

      if (both || property === "scrollTo_x") {
        this.skipX = 1;
      }

      if (both || property === "scrollTo_y") {
        this.skipY = 1;
      }

      i > -1 && this._props.splice(i, 1);
      return !this._props.length;
    }
  };
  ScrollToPlugin.max = _max;
  ScrollToPlugin.getOffset = _getOffset;
  ScrollToPlugin.buildGetter = _buildGetter;

  ScrollToPlugin.config = function (vars) {
    _config || _initCore() || (_config = gsap.config()); // in case the window hasn't been defined yet.

    for (var p in vars) {
      _config[p] = vars[p];
    }
  };

  _getGSAP() && gsap.registerPlugin(ScrollToPlugin);

  Swiper.use([Navigation, Pagination, Autoplay, Scrollbar, EffectFade]);
  var Page = /*#__PURE__*/function () {
    function Page() {
      _classCallCheck(this, Page);
      gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrollToPlugin);
      if (document.querySelector('.cm-xxx')) ;
      this.pCompanyPhilosophy();
      this.pCompanyHistory();
      this.pMedia();
      this.pMediaChintiger();
    }
    return _createClass$1(Page, [{
      key: "pCompanyPhilosophy",
      value: function pCompanyPhilosophy() {
        if (document.querySelector('.p-company-philosophy')) {
          var section = document.querySelector('.p-company-philosophy');
          var wrap = document.querySelector('.p-company-philosophy__wrap');
          gsapWithCSS.utils.toArray('.p-company-philosophy-figure__pic svg');
          gsapWithCSS.utils.toArray('.p-company-philosophy-item');

          // svgs.forEach((svg, i) => {
          //     gsap.set(svg, { opacity: i === 0 ? 1 : 0 });
          // });
          // items.forEach((item, i) => {
          //     gsap.set(item, { display: i === 0 ? 'block' : 'none' });
          // });

          /* ========== PIN ========= */
          ScrollTrigger$1.create({
            trigger: section,
            start: function start() {
              var wrapRect = wrap.getBoundingClientRect();
              return "top+=".concat(wrapRect.height / 2, " center");
            },
            end: function end() {
              var wrapRect = wrap.getBoundingClientRect();
              return "bottom-=".concat(wrapRect.height / 2, " center");
            },
            pin: wrap,
            scrub: true,
            markers: false
          });

          /* ==========  ========= */
          var setStepClass = function setStepClass(step) {
            section.classList.remove('is-step-1', 'is-step-2', 'is-step-3');
            section.classList.add("is-step-".concat(step));
          };
          setStepClass(1);
          ScrollTrigger$1.create({
            trigger: section,
            start: function start() {
              return 'top center';
            },
            end: function end() {
              wrap.getBoundingClientRect();
              return "bottom center";
            },
            scrub: true,
            markers: false,
            onUpdate: function onUpdate(self) {
              var p = self.progress;
              if (p < 1 / 3) {
                setStepClass(1);
              } else if (p < 2 / 3) {
                setStepClass(2);
              } else {
                setStepClass(3);
              }
            }
          });
        }
      }
    }, {
      key: "pCompanyHistory",
      value: function pCompanyHistory() {
        if (document.querySelector('.p-company-history-timeline')) {
          var timeline = document.querySelector('.p-company-history-timeline');
          var line = timeline.querySelector('.p-company-history-timeline__line');
          var indicator = line.querySelector('.indicator');
          var nikukyu = line.querySelector('.nikukyu');
          gsapWithCSS.set(indicator, {
            height: '0%'
          });
          gsapWithCSS.set(nikukyu, {
            top: 0
          });
          gsapWithCSS.timeline({
            scrollTrigger: {
              trigger: timeline,
              start: 'top 60%',
              end: 'bottom 60%',
              scrub: true
              // markers: true,
            }
          }).to(indicator, {
            height: '100%',
            ease: 'none'
          }, 0).to(nikukyu, {
            top: '100%',
            ease: 'none'
          }, 0);
        }
      }
    }, {
      key: "pMedia",
      value: function pMedia() {
        var tabs = document.querySelectorAll('.js-btn-mediaTab');
        var contentsLead = document.querySelectorAll('.js-content-mediaLead');
        var contents = document.querySelectorAll('.js-content-media');
        tabs.forEach(function (tab, index) {
          tab.addEventListener('click', function () {
            tabs.forEach(function (t) {
              return t.classList.remove('is-active');
            });
            contentsLead.forEach(function (c) {
              return c.classList.remove('is-active');
            });
            contents.forEach(function (c) {
              return c.classList.remove('is-active');
            });
            tab.classList.add('is-active');
            contentsLead[index].classList.add('is-active');
            contents[index].classList.add('is-active');
          });
        });
        if (tabs.length > 0 && contents.length > 0) {
          tabs[0].classList.add('is-active');
          contentsLead[0].classList.add('is-active');
          contents[0].classList.add('is-active');
        }
      }
    }, {
      key: "pMediaChintiger",
      value: function pMediaChintiger() {
        if (document.querySelector('.p-media-chintiger-profile__block2Text .swiper')) {
          new Swiper('.p-media-chintiger-profile__block2Text .swiper', {
            loop: true,
            slidesPerView: 1,
            spaceBetween: 0,
            speed: 0,
            // effect: 'fade',
            autoplay: {
              delay: 5000,
              disableOnInteraction: false
            },
            on: {
              slideChangeTransitionStart: function slideChangeTransitionStart(swiper) {
                // 
                var captions = document.querySelectorAll('.p-media-chintiger-profile__block2Pic figcaption p');
                captions.forEach(function (p) {
                  p.style.display = 'none';
                });
                var index = swiper.realIndex;
                if (captions[index]) {
                  captions[index].style.display = 'block';
                }

                // 
                document.querySelectorAll('.p-media-chintiger-profile__block2Text .swiper-slide span span').forEach(function (s) {
                  s.style.display = 'none';
                });
                var activeSlide = swiper.slides[swiper.activeIndex];
                var chars = activeSlide.querySelectorAll('span span');
                chars.forEach(function (_char, i) {
                  setTimeout(function () {
                    _char.style.display = 'inline-block';
                  }, i * 50);
                });
              }
            }
          });
        }
      }
    }]);
  }();

  var lottie$1 = {exports: {}};

  (function (module, exports) {
  	(typeof document !== "undefined") && (typeof navigator !== "undefined") && (function (global, factory) {
  	  module.exports = factory() ;
  	})(commonjsGlobal, (function () {
  	  var svgNS = 'http://www.w3.org/2000/svg';
  	  var locationHref = '';
  	  var _useWebWorker = false;
  	  var initialDefaultFrame = -999999;
  	  var setWebWorker = function setWebWorker(flag) {
  	    _useWebWorker = !!flag;
  	  };
  	  var getWebWorker = function getWebWorker() {
  	    return _useWebWorker;
  	  };
  	  var setLocationHref = function setLocationHref(value) {
  	    locationHref = value;
  	  };
  	  var getLocationHref = function getLocationHref() {
  	    return locationHref;
  	  };

  	  function createTag(type) {
  	    // return {appendChild:function(){},setAttribute:function(){},style:{}}
  	    return document.createElement(type);
  	  }

  	  function extendPrototype(sources, destination) {
  	    var i;
  	    var len = sources.length;
  	    var sourcePrototype;
  	    for (i = 0; i < len; i += 1) {
  	      sourcePrototype = sources[i].prototype;
  	      for (var attr in sourcePrototype) {
  	        if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
  	      }
  	    }
  	  }
  	  function getDescriptor(object, prop) {
  	    return Object.getOwnPropertyDescriptor(object, prop);
  	  }
  	  function createProxyFunction(prototype) {
  	    function ProxyFunction() {}
  	    ProxyFunction.prototype = prototype;
  	    return ProxyFunction;
  	  }

  	  // import Howl from '../../3rd_party/howler';

  	  var audioControllerFactory = function () {
  	    function AudioController(audioFactory) {
  	      this.audios = [];
  	      this.audioFactory = audioFactory;
  	      this._volume = 1;
  	      this._isMuted = false;
  	    }
  	    AudioController.prototype = {
  	      addAudio: function addAudio(audio) {
  	        this.audios.push(audio);
  	      },
  	      pause: function pause() {
  	        var i;
  	        var len = this.audios.length;
  	        for (i = 0; i < len; i += 1) {
  	          this.audios[i].pause();
  	        }
  	      },
  	      resume: function resume() {
  	        var i;
  	        var len = this.audios.length;
  	        for (i = 0; i < len; i += 1) {
  	          this.audios[i].resume();
  	        }
  	      },
  	      setRate: function setRate(rateValue) {
  	        var i;
  	        var len = this.audios.length;
  	        for (i = 0; i < len; i += 1) {
  	          this.audios[i].setRate(rateValue);
  	        }
  	      },
  	      createAudio: function createAudio(assetPath) {
  	        if (this.audioFactory) {
  	          return this.audioFactory(assetPath);
  	        }
  	        if (window.Howl) {
  	          return new window.Howl({
  	            src: [assetPath]
  	          });
  	        }
  	        return {
  	          isPlaying: false,
  	          play: function play() {
  	            this.isPlaying = true;
  	          },
  	          seek: function seek() {
  	            this.isPlaying = false;
  	          },
  	          playing: function playing() {},
  	          rate: function rate() {},
  	          setVolume: function setVolume() {}
  	        };
  	      },
  	      setAudioFactory: function setAudioFactory(audioFactory) {
  	        this.audioFactory = audioFactory;
  	      },
  	      setVolume: function setVolume(value) {
  	        this._volume = value;
  	        this._updateVolume();
  	      },
  	      mute: function mute() {
  	        this._isMuted = true;
  	        this._updateVolume();
  	      },
  	      unmute: function unmute() {
  	        this._isMuted = false;
  	        this._updateVolume();
  	      },
  	      getVolume: function getVolume() {
  	        return this._volume;
  	      },
  	      _updateVolume: function _updateVolume() {
  	        var i;
  	        var len = this.audios.length;
  	        for (i = 0; i < len; i += 1) {
  	          this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
  	        }
  	      }
  	    };
  	    return function () {
  	      return new AudioController();
  	    };
  	  }();

  	  var createTypedArray = function () {
  	    function createRegularArray(type, len) {
  	      var i = 0;
  	      var arr = [];
  	      var value;
  	      switch (type) {
  	        case 'int16':
  	        case 'uint8c':
  	          value = 1;
  	          break;
  	        default:
  	          value = 1.1;
  	          break;
  	      }
  	      for (i = 0; i < len; i += 1) {
  	        arr.push(value);
  	      }
  	      return arr;
  	    }
  	    function createTypedArrayFactory(type, len) {
  	      if (type === 'float32') {
  	        return new Float32Array(len);
  	      }
  	      if (type === 'int16') {
  	        return new Int16Array(len);
  	      }
  	      if (type === 'uint8c') {
  	        return new Uint8ClampedArray(len);
  	      }
  	      return createRegularArray(type, len);
  	    }
  	    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
  	      return createTypedArrayFactory;
  	    }
  	    return createRegularArray;
  	  }();
  	  function createSizedArray(len) {
  	    return Array.apply(null, {
  	      length: len
  	    });
  	  }

  	  function _typeof$6(o) { "@babel/helpers - typeof"; return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$6(o); }
  	  var subframeEnabled = true;
  	  var expressionsPlugin = null;
  	  var expressionsInterfaces = null;
  	  var idPrefix$1 = '';
  	  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  	  var bmPow = Math.pow;
  	  var bmSqrt = Math.sqrt;
  	  var bmFloor = Math.floor;
  	  var bmMax = Math.max;
  	  var bmMin = Math.min;
  	  var BMMath = {};
  	  (function () {
  	    var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
  	    var i;
  	    var len = propertyNames.length;
  	    for (i = 0; i < len; i += 1) {
  	      BMMath[propertyNames[i]] = Math[propertyNames[i]];
  	    }
  	  })();
  	  BMMath.random = Math.random;
  	  BMMath.abs = function (val) {
  	    var tOfVal = _typeof$6(val);
  	    if (tOfVal === 'object' && val.length) {
  	      var absArr = createSizedArray(val.length);
  	      var i;
  	      var len = val.length;
  	      for (i = 0; i < len; i += 1) {
  	        absArr[i] = Math.abs(val[i]);
  	      }
  	      return absArr;
  	    }
  	    return Math.abs(val);
  	  };
  	  var defaultCurveSegments = 150;
  	  var degToRads = Math.PI / 180;
  	  var roundCorner = 0.5519;
  	  function styleDiv(element) {
  	    element.style.position = 'absolute';
  	    element.style.top = 0;
  	    element.style.left = 0;
  	    element.style.display = 'block';
  	    element.style.transformOrigin = '0 0';
  	    element.style.webkitTransformOrigin = '0 0';
  	    element.style.backfaceVisibility = 'visible';
  	    element.style.webkitBackfaceVisibility = 'visible';
  	    element.style.transformStyle = 'preserve-3d';
  	    element.style.webkitTransformStyle = 'preserve-3d';
  	    element.style.mozTransformStyle = 'preserve-3d';
  	  }
  	  function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
  	    this.type = type;
  	    this.currentTime = currentTime;
  	    this.totalTime = totalTime;
  	    this.direction = frameMultiplier < 0 ? -1 : 1;
  	  }
  	  function BMCompleteEvent(type, frameMultiplier) {
  	    this.type = type;
  	    this.direction = frameMultiplier < 0 ? -1 : 1;
  	  }
  	  function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
  	    this.type = type;
  	    this.currentLoop = currentLoop;
  	    this.totalLoops = totalLoops;
  	    this.direction = frameMultiplier < 0 ? -1 : 1;
  	  }
  	  function BMSegmentStartEvent(type, firstFrame, totalFrames) {
  	    this.type = type;
  	    this.firstFrame = firstFrame;
  	    this.totalFrames = totalFrames;
  	  }
  	  function BMDestroyEvent(type, target) {
  	    this.type = type;
  	    this.target = target;
  	  }
  	  function BMRenderFrameErrorEvent(nativeError, currentTime) {
  	    this.type = 'renderFrameError';
  	    this.nativeError = nativeError;
  	    this.currentTime = currentTime;
  	  }
  	  function BMConfigErrorEvent(nativeError) {
  	    this.type = 'configError';
  	    this.nativeError = nativeError;
  	  }
  	  var createElementID = function () {
  	    var _count = 0;
  	    return function createID() {
  	      _count += 1;
  	      return idPrefix$1 + '__lottie_element_' + _count;
  	    };
  	  }();
  	  function HSVtoRGB(h, s, v) {
  	    var r;
  	    var g;
  	    var b;
  	    var i;
  	    var f;
  	    var p;
  	    var q;
  	    var t;
  	    i = Math.floor(h * 6);
  	    f = h * 6 - i;
  	    p = v * (1 - s);
  	    q = v * (1 - f * s);
  	    t = v * (1 - (1 - f) * s);
  	    switch (i % 6) {
  	      case 0:
  	        r = v;
  	        g = t;
  	        b = p;
  	        break;
  	      case 1:
  	        r = q;
  	        g = v;
  	        b = p;
  	        break;
  	      case 2:
  	        r = p;
  	        g = v;
  	        b = t;
  	        break;
  	      case 3:
  	        r = p;
  	        g = q;
  	        b = v;
  	        break;
  	      case 4:
  	        r = t;
  	        g = p;
  	        b = v;
  	        break;
  	      case 5:
  	        r = v;
  	        g = p;
  	        b = q;
  	        break;
  	    }
  	    return [r, g, b];
  	  }
  	  function RGBtoHSV(r, g, b) {
  	    var max = Math.max(r, g, b);
  	    var min = Math.min(r, g, b);
  	    var d = max - min;
  	    var h;
  	    var s = max === 0 ? 0 : d / max;
  	    var v = max / 255;
  	    switch (max) {
  	      case min:
  	        h = 0;
  	        break;
  	      case r:
  	        h = g - b + d * (g < b ? 6 : 0);
  	        h /= 6 * d;
  	        break;
  	      case g:
  	        h = b - r + d * 2;
  	        h /= 6 * d;
  	        break;
  	      case b:
  	        h = r - g + d * 4;
  	        h /= 6 * d;
  	        break;
  	    }
  	    return [h, s, v];
  	  }
  	  function addSaturationToRGB(color, offset) {
  	    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  	    hsv[1] += offset;
  	    if (hsv[1] > 1) {
  	      hsv[1] = 1;
  	    } else if (hsv[1] <= 0) {
  	      hsv[1] = 0;
  	    }
  	    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  	  }
  	  function addBrightnessToRGB(color, offset) {
  	    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  	    hsv[2] += offset;
  	    if (hsv[2] > 1) {
  	      hsv[2] = 1;
  	    } else if (hsv[2] < 0) {
  	      hsv[2] = 0;
  	    }
  	    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  	  }
  	  function addHueToRGB(color, offset) {
  	    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  	    hsv[0] += offset / 360;
  	    if (hsv[0] > 1) {
  	      hsv[0] -= 1;
  	    } else if (hsv[0] < 0) {
  	      hsv[0] += 1;
  	    }
  	    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  	  }
  	  var rgbToHex = function () {
  	    var colorMap = [];
  	    var i;
  	    var hex;
  	    for (i = 0; i < 256; i += 1) {
  	      hex = i.toString(16);
  	      colorMap[i] = hex.length === 1 ? '0' + hex : hex;
  	    }
  	    return function (r, g, b) {
  	      if (r < 0) {
  	        r = 0;
  	      }
  	      if (g < 0) {
  	        g = 0;
  	      }
  	      if (b < 0) {
  	        b = 0;
  	      }
  	      return '#' + colorMap[r] + colorMap[g] + colorMap[b];
  	    };
  	  }();
  	  var setSubframeEnabled = function setSubframeEnabled(flag) {
  	    subframeEnabled = !!flag;
  	  };
  	  var getSubframeEnabled = function getSubframeEnabled() {
  	    return subframeEnabled;
  	  };
  	  var setExpressionsPlugin = function setExpressionsPlugin(value) {
  	    expressionsPlugin = value;
  	  };
  	  var getExpressionsPlugin = function getExpressionsPlugin() {
  	    return expressionsPlugin;
  	  };
  	  var setExpressionInterfaces = function setExpressionInterfaces(value) {
  	    expressionsInterfaces = value;
  	  };
  	  var getExpressionInterfaces = function getExpressionInterfaces() {
  	    return expressionsInterfaces;
  	  };
  	  var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
  	    defaultCurveSegments = value;
  	  };
  	  var getDefaultCurveSegments = function getDefaultCurveSegments() {
  	    return defaultCurveSegments;
  	  };
  	  var setIdPrefix = function setIdPrefix(value) {
  	    idPrefix$1 = value;
  	  };

  	  function createNS(type) {
  	    // return {appendChild:function(){},setAttribute:function(){},style:{}}
  	    return document.createElementNS(svgNS, type);
  	  }

  	  function _typeof$5(o) { "@babel/helpers - typeof"; return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$5(o); }
  	  var dataManager = function () {
  	    var _counterId = 1;
  	    var processes = [];
  	    var workerFn;
  	    var workerInstance;
  	    var workerProxy = {
  	      onmessage: function onmessage() {},
  	      postMessage: function postMessage(path) {
  	        workerFn({
  	          data: path
  	        });
  	      }
  	    };
  	    var _workerSelf = {
  	      postMessage: function postMessage(data) {
  	        workerProxy.onmessage({
  	          data: data
  	        });
  	      }
  	    };
  	    function createWorker(fn) {
  	      if (window.Worker && window.Blob && getWebWorker()) {
  	        var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {
  	          type: 'text/javascript'
  	        });
  	        // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });
  	        var url = URL.createObjectURL(blob);
  	        return new Worker(url);
  	      }
  	      workerFn = fn;
  	      return workerProxy;
  	    }
  	    function setupWorker() {
  	      if (!workerInstance) {
  	        workerInstance = createWorker(function workerStart(e) {
  	          function dataFunctionManager() {
  	            function completeLayers(layers, comps) {
  	              var layerData;
  	              var i;
  	              var len = layers.length;
  	              var j;
  	              var jLen;
  	              var k;
  	              var kLen;
  	              for (i = 0; i < len; i += 1) {
  	                layerData = layers[i];
  	                if ('ks' in layerData && !layerData.completed) {
  	                  layerData.completed = true;
  	                  if (layerData.hasMask) {
  	                    var maskProps = layerData.masksProperties;
  	                    jLen = maskProps.length;
  	                    for (j = 0; j < jLen; j += 1) {
  	                      if (maskProps[j].pt.k.i) {
  	                        convertPathsToAbsoluteValues(maskProps[j].pt.k);
  	                      } else {
  	                        kLen = maskProps[j].pt.k.length;
  	                        for (k = 0; k < kLen; k += 1) {
  	                          if (maskProps[j].pt.k[k].s) {
  	                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
  	                          }
  	                          if (maskProps[j].pt.k[k].e) {
  	                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
  	                          }
  	                        }
  	                      }
  	                    }
  	                  }
  	                  if (layerData.ty === 0) {
  	                    layerData.layers = findCompLayers(layerData.refId, comps);
  	                    completeLayers(layerData.layers, comps);
  	                  } else if (layerData.ty === 4) {
  	                    completeShapes(layerData.shapes);
  	                  } else if (layerData.ty === 5) {
  	                    completeText(layerData);
  	                  }
  	                }
  	              }
  	            }
  	            function completeChars(chars, assets) {
  	              if (chars) {
  	                var i = 0;
  	                var len = chars.length;
  	                for (i = 0; i < len; i += 1) {
  	                  if (chars[i].t === 1) {
  	                    // var compData = findComp(chars[i].data.refId, assets);
  	                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);
  	                    // chars[i].data.ip = 0;
  	                    // chars[i].data.op = 99999;
  	                    // chars[i].data.st = 0;
  	                    // chars[i].data.sr = 1;
  	                    // chars[i].w = compData.w;
  	                    // chars[i].data.ks = {
  	                    //   a: { k: [0, 0, 0], a: 0 },
  	                    //   p: { k: [0, -compData.h, 0], a: 0 },
  	                    //   r: { k: 0, a: 0 },
  	                    //   s: { k: [100, 100], a: 0 },
  	                    //   o: { k: 100, a: 0 },
  	                    // };
  	                    completeLayers(chars[i].data.layers, assets);
  	                  }
  	                }
  	              }
  	            }
  	            function findComp(id, comps) {
  	              var i = 0;
  	              var len = comps.length;
  	              while (i < len) {
  	                if (comps[i].id === id) {
  	                  return comps[i];
  	                }
  	                i += 1;
  	              }
  	              return null;
  	            }
  	            function findCompLayers(id, comps) {
  	              var comp = findComp(id, comps);
  	              if (comp) {
  	                if (!comp.layers.__used) {
  	                  comp.layers.__used = true;
  	                  return comp.layers;
  	                }
  	                return JSON.parse(JSON.stringify(comp.layers));
  	              }
  	              return null;
  	            }
  	            function completeShapes(arr) {
  	              var i;
  	              var len = arr.length;
  	              var j;
  	              var jLen;
  	              for (i = len - 1; i >= 0; i -= 1) {
  	                if (arr[i].ty === 'sh') {
  	                  if (arr[i].ks.k.i) {
  	                    convertPathsToAbsoluteValues(arr[i].ks.k);
  	                  } else {
  	                    jLen = arr[i].ks.k.length;
  	                    for (j = 0; j < jLen; j += 1) {
  	                      if (arr[i].ks.k[j].s) {
  	                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
  	                      }
  	                      if (arr[i].ks.k[j].e) {
  	                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
  	                      }
  	                    }
  	                  }
  	                } else if (arr[i].ty === 'gr') {
  	                  completeShapes(arr[i].it);
  	                }
  	              }
  	            }
  	            function convertPathsToAbsoluteValues(path) {
  	              var i;
  	              var len = path.i.length;
  	              for (i = 0; i < len; i += 1) {
  	                path.i[i][0] += path.v[i][0];
  	                path.i[i][1] += path.v[i][1];
  	                path.o[i][0] += path.v[i][0];
  	                path.o[i][1] += path.v[i][1];
  	              }
  	            }
  	            function checkVersion(minimum, animVersionString) {
  	              var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
  	              if (minimum[0] > animVersion[0]) {
  	                return true;
  	              }
  	              if (animVersion[0] > minimum[0]) {
  	                return false;
  	              }
  	              if (minimum[1] > animVersion[1]) {
  	                return true;
  	              }
  	              if (animVersion[1] > minimum[1]) {
  	                return false;
  	              }
  	              if (minimum[2] > animVersion[2]) {
  	                return true;
  	              }
  	              if (animVersion[2] > minimum[2]) {
  	                return false;
  	              }
  	              return null;
  	            }
  	            var checkText = function () {
  	              var minimumVersion = [4, 4, 14];
  	              function updateTextLayer(textLayer) {
  	                var documentData = textLayer.t.d;
  	                textLayer.t.d = {
  	                  k: [{
  	                    s: documentData,
  	                    t: 0
  	                  }]
  	                };
  	              }
  	              function iterateLayers(layers) {
  	                var i;
  	                var len = layers.length;
  	                for (i = 0; i < len; i += 1) {
  	                  if (layers[i].ty === 5) {
  	                    updateTextLayer(layers[i]);
  	                  }
  	                }
  	              }
  	              return function (animationData) {
  	                if (checkVersion(minimumVersion, animationData.v)) {
  	                  iterateLayers(animationData.layers);
  	                  if (animationData.assets) {
  	                    var i;
  	                    var len = animationData.assets.length;
  	                    for (i = 0; i < len; i += 1) {
  	                      if (animationData.assets[i].layers) {
  	                        iterateLayers(animationData.assets[i].layers);
  	                      }
  	                    }
  	                  }
  	                }
  	              };
  	            }();
  	            var checkChars = function () {
  	              var minimumVersion = [4, 7, 99];
  	              return function (animationData) {
  	                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
  	                  var i;
  	                  var len = animationData.chars.length;
  	                  for (i = 0; i < len; i += 1) {
  	                    var charData = animationData.chars[i];
  	                    if (charData.data && charData.data.shapes) {
  	                      completeShapes(charData.data.shapes);
  	                      charData.data.ip = 0;
  	                      charData.data.op = 99999;
  	                      charData.data.st = 0;
  	                      charData.data.sr = 1;
  	                      charData.data.ks = {
  	                        p: {
  	                          k: [0, 0],
  	                          a: 0
  	                        },
  	                        s: {
  	                          k: [100, 100],
  	                          a: 0
  	                        },
  	                        a: {
  	                          k: [0, 0],
  	                          a: 0
  	                        },
  	                        r: {
  	                          k: 0,
  	                          a: 0
  	                        },
  	                        o: {
  	                          k: 100,
  	                          a: 0
  	                        }
  	                      };
  	                      if (!animationData.chars[i].t) {
  	                        charData.data.shapes.push({
  	                          ty: 'no'
  	                        });
  	                        charData.data.shapes[0].it.push({
  	                          p: {
  	                            k: [0, 0],
  	                            a: 0
  	                          },
  	                          s: {
  	                            k: [100, 100],
  	                            a: 0
  	                          },
  	                          a: {
  	                            k: [0, 0],
  	                            a: 0
  	                          },
  	                          r: {
  	                            k: 0,
  	                            a: 0
  	                          },
  	                          o: {
  	                            k: 100,
  	                            a: 0
  	                          },
  	                          sk: {
  	                            k: 0,
  	                            a: 0
  	                          },
  	                          sa: {
  	                            k: 0,
  	                            a: 0
  	                          },
  	                          ty: 'tr'
  	                        });
  	                      }
  	                    }
  	                  }
  	                }
  	              };
  	            }();
  	            var checkPathProperties = function () {
  	              var minimumVersion = [5, 7, 15];
  	              function updateTextLayer(textLayer) {
  	                var pathData = textLayer.t.p;
  	                if (typeof pathData.a === 'number') {
  	                  pathData.a = {
  	                    a: 0,
  	                    k: pathData.a
  	                  };
  	                }
  	                if (typeof pathData.p === 'number') {
  	                  pathData.p = {
  	                    a: 0,
  	                    k: pathData.p
  	                  };
  	                }
  	                if (typeof pathData.r === 'number') {
  	                  pathData.r = {
  	                    a: 0,
  	                    k: pathData.r
  	                  };
  	                }
  	              }
  	              function iterateLayers(layers) {
  	                var i;
  	                var len = layers.length;
  	                for (i = 0; i < len; i += 1) {
  	                  if (layers[i].ty === 5) {
  	                    updateTextLayer(layers[i]);
  	                  }
  	                }
  	              }
  	              return function (animationData) {
  	                if (checkVersion(minimumVersion, animationData.v)) {
  	                  iterateLayers(animationData.layers);
  	                  if (animationData.assets) {
  	                    var i;
  	                    var len = animationData.assets.length;
  	                    for (i = 0; i < len; i += 1) {
  	                      if (animationData.assets[i].layers) {
  	                        iterateLayers(animationData.assets[i].layers);
  	                      }
  	                    }
  	                  }
  	                }
  	              };
  	            }();
  	            var checkColors = function () {
  	              var minimumVersion = [4, 1, 9];
  	              function iterateShapes(shapes) {
  	                var i;
  	                var len = shapes.length;
  	                var j;
  	                var jLen;
  	                for (i = 0; i < len; i += 1) {
  	                  if (shapes[i].ty === 'gr') {
  	                    iterateShapes(shapes[i].it);
  	                  } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
  	                    if (shapes[i].c.k && shapes[i].c.k[0].i) {
  	                      jLen = shapes[i].c.k.length;
  	                      for (j = 0; j < jLen; j += 1) {
  	                        if (shapes[i].c.k[j].s) {
  	                          shapes[i].c.k[j].s[0] /= 255;
  	                          shapes[i].c.k[j].s[1] /= 255;
  	                          shapes[i].c.k[j].s[2] /= 255;
  	                          shapes[i].c.k[j].s[3] /= 255;
  	                        }
  	                        if (shapes[i].c.k[j].e) {
  	                          shapes[i].c.k[j].e[0] /= 255;
  	                          shapes[i].c.k[j].e[1] /= 255;
  	                          shapes[i].c.k[j].e[2] /= 255;
  	                          shapes[i].c.k[j].e[3] /= 255;
  	                        }
  	                      }
  	                    } else {
  	                      shapes[i].c.k[0] /= 255;
  	                      shapes[i].c.k[1] /= 255;
  	                      shapes[i].c.k[2] /= 255;
  	                      shapes[i].c.k[3] /= 255;
  	                    }
  	                  }
  	                }
  	              }
  	              function iterateLayers(layers) {
  	                var i;
  	                var len = layers.length;
  	                for (i = 0; i < len; i += 1) {
  	                  if (layers[i].ty === 4) {
  	                    iterateShapes(layers[i].shapes);
  	                  }
  	                }
  	              }
  	              return function (animationData) {
  	                if (checkVersion(minimumVersion, animationData.v)) {
  	                  iterateLayers(animationData.layers);
  	                  if (animationData.assets) {
  	                    var i;
  	                    var len = animationData.assets.length;
  	                    for (i = 0; i < len; i += 1) {
  	                      if (animationData.assets[i].layers) {
  	                        iterateLayers(animationData.assets[i].layers);
  	                      }
  	                    }
  	                  }
  	                }
  	              };
  	            }();
  	            var checkShapes = function () {
  	              var minimumVersion = [4, 4, 18];
  	              function completeClosingShapes(arr) {
  	                var i;
  	                var len = arr.length;
  	                var j;
  	                var jLen;
  	                for (i = len - 1; i >= 0; i -= 1) {
  	                  if (arr[i].ty === 'sh') {
  	                    if (arr[i].ks.k.i) {
  	                      arr[i].ks.k.c = arr[i].closed;
  	                    } else {
  	                      jLen = arr[i].ks.k.length;
  	                      for (j = 0; j < jLen; j += 1) {
  	                        if (arr[i].ks.k[j].s) {
  	                          arr[i].ks.k[j].s[0].c = arr[i].closed;
  	                        }
  	                        if (arr[i].ks.k[j].e) {
  	                          arr[i].ks.k[j].e[0].c = arr[i].closed;
  	                        }
  	                      }
  	                    }
  	                  } else if (arr[i].ty === 'gr') {
  	                    completeClosingShapes(arr[i].it);
  	                  }
  	                }
  	              }
  	              function iterateLayers(layers) {
  	                var layerData;
  	                var i;
  	                var len = layers.length;
  	                var j;
  	                var jLen;
  	                var k;
  	                var kLen;
  	                for (i = 0; i < len; i += 1) {
  	                  layerData = layers[i];
  	                  if (layerData.hasMask) {
  	                    var maskProps = layerData.masksProperties;
  	                    jLen = maskProps.length;
  	                    for (j = 0; j < jLen; j += 1) {
  	                      if (maskProps[j].pt.k.i) {
  	                        maskProps[j].pt.k.c = maskProps[j].cl;
  	                      } else {
  	                        kLen = maskProps[j].pt.k.length;
  	                        for (k = 0; k < kLen; k += 1) {
  	                          if (maskProps[j].pt.k[k].s) {
  	                            maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
  	                          }
  	                          if (maskProps[j].pt.k[k].e) {
  	                            maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
  	                          }
  	                        }
  	                      }
  	                    }
  	                  }
  	                  if (layerData.ty === 4) {
  	                    completeClosingShapes(layerData.shapes);
  	                  }
  	                }
  	              }
  	              return function (animationData) {
  	                if (checkVersion(minimumVersion, animationData.v)) {
  	                  iterateLayers(animationData.layers);
  	                  if (animationData.assets) {
  	                    var i;
  	                    var len = animationData.assets.length;
  	                    for (i = 0; i < len; i += 1) {
  	                      if (animationData.assets[i].layers) {
  	                        iterateLayers(animationData.assets[i].layers);
  	                      }
  	                    }
  	                  }
  	                }
  	              };
  	            }();
  	            function completeData(animationData) {
  	              if (animationData.__complete) {
  	                return;
  	              }
  	              checkColors(animationData);
  	              checkText(animationData);
  	              checkChars(animationData);
  	              checkPathProperties(animationData);
  	              checkShapes(animationData);
  	              completeLayers(animationData.layers, animationData.assets);
  	              completeChars(animationData.chars, animationData.assets);
  	              animationData.__complete = true;
  	            }
  	            function completeText(data) {
  	              if (data.t.a.length === 0 && !('m' in data.t.p)) ;
  	            }
  	            var moduleOb = {};
  	            moduleOb.completeData = completeData;
  	            moduleOb.checkColors = checkColors;
  	            moduleOb.checkChars = checkChars;
  	            moduleOb.checkPathProperties = checkPathProperties;
  	            moduleOb.checkShapes = checkShapes;
  	            moduleOb.completeLayers = completeLayers;
  	            return moduleOb;
  	          }
  	          if (!_workerSelf.dataManager) {
  	            _workerSelf.dataManager = dataFunctionManager();
  	          }
  	          if (!_workerSelf.assetLoader) {
  	            _workerSelf.assetLoader = function () {
  	              function formatResponse(xhr) {
  	                // using typeof doubles the time of execution of this method,
  	                // so if available, it's better to use the header to validate the type
  	                var contentTypeHeader = xhr.getResponseHeader('content-type');
  	                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
  	                  return xhr.response;
  	                }
  	                if (xhr.response && _typeof$5(xhr.response) === 'object') {
  	                  return xhr.response;
  	                }
  	                if (xhr.response && typeof xhr.response === 'string') {
  	                  return JSON.parse(xhr.response);
  	                }
  	                if (xhr.responseText) {
  	                  return JSON.parse(xhr.responseText);
  	                }
  	                return null;
  	              }
  	              function loadAsset(path, fullPath, callback, errorCallback) {
  	                var response;
  	                var xhr = new XMLHttpRequest();
  	                // set responseType after calling open or IE will break.
  	                try {
  	                  // This crashes on Android WebView prior to KitKat
  	                  xhr.responseType = 'json';
  	                } catch (err) {} // eslint-disable-line no-empty
  	                xhr.onreadystatechange = function () {
  	                  if (xhr.readyState === 4) {
  	                    if (xhr.status === 200) {
  	                      response = formatResponse(xhr);
  	                      callback(response);
  	                    } else {
  	                      try {
  	                        response = formatResponse(xhr);
  	                        callback(response);
  	                      } catch (err) {
  	                        if (errorCallback) {
  	                          errorCallback(err);
  	                        }
  	                      }
  	                    }
  	                  }
  	                };
  	                try {
  	                  // Hack to workaround banner validation
  	                  xhr.open(['G', 'E', 'T'].join(''), path, true);
  	                } catch (error) {
  	                  // Hack to workaround banner validation
  	                  xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);
  	                }
  	                xhr.send();
  	              }
  	              return {
  	                load: loadAsset
  	              };
  	            }();
  	          }
  	          if (e.data.type === 'loadAnimation') {
  	            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
  	              _workerSelf.dataManager.completeData(data);
  	              _workerSelf.postMessage({
  	                id: e.data.id,
  	                payload: data,
  	                status: 'success'
  	              });
  	            }, function () {
  	              _workerSelf.postMessage({
  	                id: e.data.id,
  	                status: 'error'
  	              });
  	            });
  	          } else if (e.data.type === 'complete') {
  	            var animation = e.data.animation;
  	            _workerSelf.dataManager.completeData(animation);
  	            _workerSelf.postMessage({
  	              id: e.data.id,
  	              payload: animation,
  	              status: 'success'
  	            });
  	          } else if (e.data.type === 'loadData') {
  	            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
  	              _workerSelf.postMessage({
  	                id: e.data.id,
  	                payload: data,
  	                status: 'success'
  	              });
  	            }, function () {
  	              _workerSelf.postMessage({
  	                id: e.data.id,
  	                status: 'error'
  	              });
  	            });
  	          }
  	        });
  	        workerInstance.onmessage = function (event) {
  	          var data = event.data;
  	          var id = data.id;
  	          var process = processes[id];
  	          processes[id] = null;
  	          if (data.status === 'success') {
  	            process.onComplete(data.payload);
  	          } else if (process.onError) {
  	            process.onError();
  	          }
  	        };
  	      }
  	    }
  	    function createProcess(onComplete, onError) {
  	      _counterId += 1;
  	      var id = 'processId_' + _counterId;
  	      processes[id] = {
  	        onComplete: onComplete,
  	        onError: onError
  	      };
  	      return id;
  	    }
  	    function loadAnimation(path, onComplete, onError) {
  	      setupWorker();
  	      var processId = createProcess(onComplete, onError);
  	      workerInstance.postMessage({
  	        type: 'loadAnimation',
  	        path: path,
  	        fullPath: window.location.origin + window.location.pathname,
  	        id: processId
  	      });
  	    }
  	    function loadData(path, onComplete, onError) {
  	      setupWorker();
  	      var processId = createProcess(onComplete, onError);
  	      workerInstance.postMessage({
  	        type: 'loadData',
  	        path: path,
  	        fullPath: window.location.origin + window.location.pathname,
  	        id: processId
  	      });
  	    }
  	    function completeAnimation(anim, onComplete, onError) {
  	      setupWorker();
  	      var processId = createProcess(onComplete, onError);
  	      workerInstance.postMessage({
  	        type: 'complete',
  	        animation: anim,
  	        id: processId
  	      });
  	    }
  	    return {
  	      loadAnimation: loadAnimation,
  	      loadData: loadData,
  	      completeAnimation: completeAnimation
  	    };
  	  }();

  	  var ImagePreloader = function () {
  	    var proxyImage = function () {
  	      var canvas = createTag('canvas');
  	      canvas.width = 1;
  	      canvas.height = 1;
  	      var ctx = canvas.getContext('2d');
  	      ctx.fillStyle = 'rgba(0,0,0,0)';
  	      ctx.fillRect(0, 0, 1, 1);
  	      return canvas;
  	    }();
  	    function imageLoaded() {
  	      this.loadedAssets += 1;
  	      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
  	        if (this.imagesLoadedCb) {
  	          this.imagesLoadedCb(null);
  	        }
  	      }
  	    }
  	    function footageLoaded() {
  	      this.loadedFootagesCount += 1;
  	      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
  	        if (this.imagesLoadedCb) {
  	          this.imagesLoadedCb(null);
  	        }
  	      }
  	    }
  	    function getAssetsPath(assetData, assetsPath, originalPath) {
  	      var path = '';
  	      if (assetData.e) {
  	        path = assetData.p;
  	      } else if (assetsPath) {
  	        var imagePath = assetData.p;
  	        if (imagePath.indexOf('images/') !== -1) {
  	          imagePath = imagePath.split('/')[1];
  	        }
  	        path = assetsPath + imagePath;
  	      } else {
  	        path = originalPath;
  	        path += assetData.u ? assetData.u : '';
  	        path += assetData.p;
  	      }
  	      return path;
  	    }
  	    function testImageLoaded(img) {
  	      var _count = 0;
  	      var intervalId = setInterval(function () {
  	        var box = img.getBBox();
  	        if (box.width || _count > 500) {
  	          this._imageLoaded();
  	          clearInterval(intervalId);
  	        }
  	        _count += 1;
  	      }.bind(this), 50);
  	    }
  	    function createImageData(assetData) {
  	      var path = getAssetsPath(assetData, this.assetsPath, this.path);
  	      var img = createNS('image');
  	      if (isSafari) {
  	        this.testImageLoaded(img);
  	      } else {
  	        img.addEventListener('load', this._imageLoaded, false);
  	      }
  	      img.addEventListener('error', function () {
  	        ob.img = proxyImage;
  	        this._imageLoaded();
  	      }.bind(this), false);
  	      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
  	      if (this._elementHelper.append) {
  	        this._elementHelper.append(img);
  	      } else {
  	        this._elementHelper.appendChild(img);
  	      }
  	      var ob = {
  	        img: img,
  	        assetData: assetData
  	      };
  	      return ob;
  	    }
  	    function createImgData(assetData) {
  	      var path = getAssetsPath(assetData, this.assetsPath, this.path);
  	      var img = createTag('img');
  	      img.crossOrigin = 'anonymous';
  	      img.addEventListener('load', this._imageLoaded, false);
  	      img.addEventListener('error', function () {
  	        ob.img = proxyImage;
  	        this._imageLoaded();
  	      }.bind(this), false);
  	      img.src = path;
  	      var ob = {
  	        img: img,
  	        assetData: assetData
  	      };
  	      return ob;
  	    }
  	    function createFootageData(data) {
  	      var ob = {
  	        assetData: data
  	      };
  	      var path = getAssetsPath(data, this.assetsPath, this.path);
  	      dataManager.loadData(path, function (footageData) {
  	        ob.img = footageData;
  	        this._footageLoaded();
  	      }.bind(this), function () {
  	        ob.img = {};
  	        this._footageLoaded();
  	      }.bind(this));
  	      return ob;
  	    }
  	    function loadAssets(assets, cb) {
  	      this.imagesLoadedCb = cb;
  	      var i;
  	      var len = assets.length;
  	      for (i = 0; i < len; i += 1) {
  	        if (!assets[i].layers) {
  	          if (!assets[i].t || assets[i].t === 'seq') {
  	            this.totalImages += 1;
  	            this.images.push(this._createImageData(assets[i]));
  	          } else if (assets[i].t === 3) {
  	            this.totalFootages += 1;
  	            this.images.push(this.createFootageData(assets[i]));
  	          }
  	        }
  	      }
  	    }
  	    function setPath(path) {
  	      this.path = path || '';
  	    }
  	    function setAssetsPath(path) {
  	      this.assetsPath = path || '';
  	    }
  	    function getAsset(assetData) {
  	      var i = 0;
  	      var len = this.images.length;
  	      while (i < len) {
  	        if (this.images[i].assetData === assetData) {
  	          return this.images[i].img;
  	        }
  	        i += 1;
  	      }
  	      return null;
  	    }
  	    function destroy() {
  	      this.imagesLoadedCb = null;
  	      this.images.length = 0;
  	    }
  	    function loadedImages() {
  	      return this.totalImages === this.loadedAssets;
  	    }
  	    function loadedFootages() {
  	      return this.totalFootages === this.loadedFootagesCount;
  	    }
  	    function setCacheType(type, elementHelper) {
  	      if (type === 'svg') {
  	        this._elementHelper = elementHelper;
  	        this._createImageData = this.createImageData.bind(this);
  	      } else {
  	        this._createImageData = this.createImgData.bind(this);
  	      }
  	    }
  	    function ImagePreloaderFactory() {
  	      this._imageLoaded = imageLoaded.bind(this);
  	      this._footageLoaded = footageLoaded.bind(this);
  	      this.testImageLoaded = testImageLoaded.bind(this);
  	      this.createFootageData = createFootageData.bind(this);
  	      this.assetsPath = '';
  	      this.path = '';
  	      this.totalImages = 0;
  	      this.totalFootages = 0;
  	      this.loadedAssets = 0;
  	      this.loadedFootagesCount = 0;
  	      this.imagesLoadedCb = null;
  	      this.images = [];
  	    }
  	    ImagePreloaderFactory.prototype = {
  	      loadAssets: loadAssets,
  	      setAssetsPath: setAssetsPath,
  	      setPath: setPath,
  	      loadedImages: loadedImages,
  	      loadedFootages: loadedFootages,
  	      destroy: destroy,
  	      getAsset: getAsset,
  	      createImgData: createImgData,
  	      createImageData: createImageData,
  	      imageLoaded: imageLoaded,
  	      footageLoaded: footageLoaded,
  	      setCacheType: setCacheType
  	    };
  	    return ImagePreloaderFactory;
  	  }();

  	  function BaseEvent() {}
  	  BaseEvent.prototype = {
  	    triggerEvent: function triggerEvent(eventName, args) {
  	      if (this._cbs[eventName]) {
  	        var callbacks = this._cbs[eventName];
  	        for (var i = 0; i < callbacks.length; i += 1) {
  	          callbacks[i](args);
  	        }
  	      }
  	    },
  	    addEventListener: function addEventListener(eventName, callback) {
  	      if (!this._cbs[eventName]) {
  	        this._cbs[eventName] = [];
  	      }
  	      this._cbs[eventName].push(callback);
  	      return function () {
  	        this.removeEventListener(eventName, callback);
  	      }.bind(this);
  	    },
  	    removeEventListener: function removeEventListener(eventName, callback) {
  	      if (!callback) {
  	        this._cbs[eventName] = null;
  	      } else if (this._cbs[eventName]) {
  	        var i = 0;
  	        var len = this._cbs[eventName].length;
  	        while (i < len) {
  	          if (this._cbs[eventName][i] === callback) {
  	            this._cbs[eventName].splice(i, 1);
  	            i -= 1;
  	            len -= 1;
  	          }
  	          i += 1;
  	        }
  	        if (!this._cbs[eventName].length) {
  	          this._cbs[eventName] = null;
  	        }
  	      }
  	    }
  	  };

  	  var markerParser = function () {
  	    function parsePayloadLines(payload) {
  	      var lines = payload.split('\r\n');
  	      var keys = {};
  	      var line;
  	      var keysCount = 0;
  	      for (var i = 0; i < lines.length; i += 1) {
  	        line = lines[i].split(':');
  	        if (line.length === 2) {
  	          keys[line[0]] = line[1].trim();
  	          keysCount += 1;
  	        }
  	      }
  	      if (keysCount === 0) {
  	        throw new Error();
  	      }
  	      return keys;
  	    }
  	    return function (_markers) {
  	      var markers = [];
  	      for (var i = 0; i < _markers.length; i += 1) {
  	        var _marker = _markers[i];
  	        var markerData = {
  	          time: _marker.tm,
  	          duration: _marker.dr
  	        };
  	        try {
  	          markerData.payload = JSON.parse(_markers[i].cm);
  	        } catch (_) {
  	          try {
  	            markerData.payload = parsePayloadLines(_markers[i].cm);
  	          } catch (__) {
  	            markerData.payload = {
  	              name: _markers[i].cm
  	            };
  	          }
  	        }
  	        markers.push(markerData);
  	      }
  	      return markers;
  	    };
  	  }();

  	  var ProjectInterface = function () {
  	    function registerComposition(comp) {
  	      this.compositions.push(comp);
  	    }
  	    return function () {
  	      function _thisProjectFunction(name) {
  	        var i = 0;
  	        var len = this.compositions.length;
  	        while (i < len) {
  	          if (this.compositions[i].data && this.compositions[i].data.nm === name) {
  	            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
  	              this.compositions[i].prepareFrame(this.currentFrame);
  	            }
  	            return this.compositions[i].compInterface;
  	          }
  	          i += 1;
  	        }
  	        return null;
  	      }
  	      _thisProjectFunction.compositions = [];
  	      _thisProjectFunction.currentFrame = 0;
  	      _thisProjectFunction.registerComposition = registerComposition;
  	      return _thisProjectFunction;
  	    };
  	  }();

  	  var renderers = {};
  	  var registerRenderer = function registerRenderer(key, value) {
  	    renderers[key] = value;
  	  };
  	  function getRenderer(key) {
  	    return renderers[key];
  	  }
  	  function getRegisteredRenderer() {
  	    // Returns canvas by default for compatibility
  	    if (renderers.canvas) {
  	      return 'canvas';
  	    }
  	    // Returns any renderer that is registered
  	    for (var key in renderers) {
  	      if (renderers[key]) {
  	        return key;
  	      }
  	    }
  	    return '';
  	  }

  	  function _typeof$4(o) { "@babel/helpers - typeof"; return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$4(o); }
  	  var AnimationItem = function AnimationItem() {
  	    this._cbs = [];
  	    this.name = '';
  	    this.path = '';
  	    this.isLoaded = false;
  	    this.currentFrame = 0;
  	    this.currentRawFrame = 0;
  	    this.firstFrame = 0;
  	    this.totalFrames = 0;
  	    this.frameRate = 0;
  	    this.frameMult = 0;
  	    this.playSpeed = 1;
  	    this.playDirection = 1;
  	    this.playCount = 0;
  	    this.animationData = {};
  	    this.assets = [];
  	    this.isPaused = true;
  	    this.autoplay = false;
  	    this.loop = true;
  	    this.renderer = null;
  	    this.animationID = createElementID();
  	    this.assetsPath = '';
  	    this.timeCompleted = 0;
  	    this.segmentPos = 0;
  	    this.isSubframeEnabled = getSubframeEnabled();
  	    this.segments = [];
  	    this._idle = true;
  	    this._completedLoop = false;
  	    this.projectInterface = ProjectInterface();
  	    this.imagePreloader = new ImagePreloader();
  	    this.audioController = audioControllerFactory();
  	    this.markers = [];
  	    this.configAnimation = this.configAnimation.bind(this);
  	    this.onSetupError = this.onSetupError.bind(this);
  	    this.onSegmentComplete = this.onSegmentComplete.bind(this);
  	    this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);
  	    this.expressionsPlugin = getExpressionsPlugin();
  	  };
  	  extendPrototype([BaseEvent], AnimationItem);
  	  AnimationItem.prototype.setParams = function (params) {
  	    if (params.wrapper || params.container) {
  	      this.wrapper = params.wrapper || params.container;
  	    }
  	    var animType = 'svg';
  	    if (params.animType) {
  	      animType = params.animType;
  	    } else if (params.renderer) {
  	      animType = params.renderer;
  	    }
  	    var RendererClass = getRenderer(animType);
  	    this.renderer = new RendererClass(this, params.rendererSettings);
  	    this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
  	    this.renderer.setProjectInterface(this.projectInterface);
  	    this.animType = animType;
  	    if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {
  	      this.loop = true;
  	    } else if (params.loop === false) {
  	      this.loop = false;
  	    } else {
  	      this.loop = parseInt(params.loop, 10);
  	    }
  	    this.autoplay = 'autoplay' in params ? params.autoplay : true;
  	    this.name = params.name ? params.name : '';
  	    this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
  	    this.assetsPath = params.assetsPath;
  	    this.initialSegment = params.initialSegment;
  	    if (params.audioFactory) {
  	      this.audioController.setAudioFactory(params.audioFactory);
  	    }
  	    if (params.animationData) {
  	      this.setupAnimation(params.animationData);
  	    } else if (params.path) {
  	      if (params.path.lastIndexOf('\\') !== -1) {
  	        this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
  	      } else {
  	        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
  	      }
  	      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
  	      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
  	      dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
  	    }
  	  };
  	  AnimationItem.prototype.onSetupError = function () {
  	    this.trigger('data_failed');
  	  };
  	  AnimationItem.prototype.setupAnimation = function (data) {
  	    dataManager.completeAnimation(data, this.configAnimation);
  	  };
  	  AnimationItem.prototype.setData = function (wrapper, animationData) {
  	    if (animationData) {
  	      if (_typeof$4(animationData) !== 'object') {
  	        animationData = JSON.parse(animationData);
  	      }
  	    }
  	    var params = {
  	      wrapper: wrapper,
  	      animationData: animationData
  	    };
  	    var wrapperAttributes = wrapper.attributes;
  	    params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
  	    params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';
  	    var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
  	    if (loop === 'false') {
  	      params.loop = false;
  	    } else if (loop === 'true') {
  	      params.loop = true;
  	    } else if (loop !== '') {
  	      params.loop = parseInt(loop, 10);
  	    }
  	    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
  	    params.autoplay = autoplay !== 'false';
  	    params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
  	    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
  	    ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';
  	    if (prerender === 'false') {
  	      params.prerender = false;
  	    }
  	    if (!params.path) {
  	      this.trigger('destroy');
  	    } else {
  	      this.setParams(params);
  	    }
  	  };
  	  AnimationItem.prototype.includeLayers = function (data) {
  	    if (data.op > this.animationData.op) {
  	      this.animationData.op = data.op;
  	      this.totalFrames = Math.floor(data.op - this.animationData.ip);
  	    }
  	    var layers = this.animationData.layers;
  	    var i;
  	    var len = layers.length;
  	    var newLayers = data.layers;
  	    var j;
  	    var jLen = newLayers.length;
  	    for (j = 0; j < jLen; j += 1) {
  	      i = 0;
  	      while (i < len) {
  	        if (layers[i].id === newLayers[j].id) {
  	          layers[i] = newLayers[j];
  	          break;
  	        }
  	        i += 1;
  	      }
  	    }
  	    if (data.chars || data.fonts) {
  	      this.renderer.globalData.fontManager.addChars(data.chars);
  	      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
  	    }
  	    if (data.assets) {
  	      len = data.assets.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.animationData.assets.push(data.assets[i]);
  	      }
  	    }
  	    this.animationData.__complete = false;
  	    dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
  	  };
  	  AnimationItem.prototype.onSegmentComplete = function (data) {
  	    this.animationData = data;
  	    var expressionsPlugin = getExpressionsPlugin();
  	    if (expressionsPlugin) {
  	      expressionsPlugin.initExpressions(this);
  	    }
  	    this.loadNextSegment();
  	  };
  	  AnimationItem.prototype.loadNextSegment = function () {
  	    var segments = this.animationData.segments;
  	    if (!segments || segments.length === 0 || !this.autoloadSegments) {
  	      this.trigger('data_ready');
  	      this.timeCompleted = this.totalFrames;
  	      return;
  	    }
  	    var segment = segments.shift();
  	    this.timeCompleted = segment.time * this.frameRate;
  	    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
  	    this.segmentPos += 1;
  	    dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
  	      this.trigger('data_failed');
  	    }.bind(this));
  	  };
  	  AnimationItem.prototype.loadSegments = function () {
  	    var segments = this.animationData.segments;
  	    if (!segments) {
  	      this.timeCompleted = this.totalFrames;
  	    }
  	    this.loadNextSegment();
  	  };
  	  AnimationItem.prototype.imagesLoaded = function () {
  	    this.trigger('loaded_images');
  	    this.checkLoaded();
  	  };
  	  AnimationItem.prototype.preloadImages = function () {
  	    this.imagePreloader.setAssetsPath(this.assetsPath);
  	    this.imagePreloader.setPath(this.path);
  	    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
  	  };
  	  AnimationItem.prototype.configAnimation = function (animData) {
  	    if (!this.renderer) {
  	      return;
  	    }
  	    try {
  	      this.animationData = animData;
  	      if (this.initialSegment) {
  	        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
  	        this.firstFrame = Math.round(this.initialSegment[0]);
  	      } else {
  	        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
  	        this.firstFrame = Math.round(this.animationData.ip);
  	      }
  	      this.renderer.configAnimation(animData);
  	      if (!animData.assets) {
  	        animData.assets = [];
  	      }
  	      this.assets = this.animationData.assets;
  	      this.frameRate = this.animationData.fr;
  	      this.frameMult = this.animationData.fr / 1000;
  	      this.renderer.searchExtraCompositions(animData.assets);
  	      this.markers = markerParser(animData.markers || []);
  	      this.trigger('config_ready');
  	      this.preloadImages();
  	      this.loadSegments();
  	      this.updaFrameModifier();
  	      this.waitForFontsLoaded();
  	      if (this.isPaused) {
  	        this.audioController.pause();
  	      }
  	    } catch (error) {
  	      this.triggerConfigError(error);
  	    }
  	  };
  	  AnimationItem.prototype.waitForFontsLoaded = function () {
  	    if (!this.renderer) {
  	      return;
  	    }
  	    if (this.renderer.globalData.fontManager.isLoaded) {
  	      this.checkLoaded();
  	    } else {
  	      setTimeout(this.waitForFontsLoaded.bind(this), 20);
  	    }
  	  };
  	  AnimationItem.prototype.checkLoaded = function () {
  	    if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {
  	      this.isLoaded = true;
  	      var expressionsPlugin = getExpressionsPlugin();
  	      if (expressionsPlugin) {
  	        expressionsPlugin.initExpressions(this);
  	      }
  	      this.renderer.initItems();
  	      setTimeout(function () {
  	        this.trigger('DOMLoaded');
  	      }.bind(this), 0);
  	      this.gotoFrame();
  	      if (this.autoplay) {
  	        this.play();
  	      }
  	    }
  	  };
  	  AnimationItem.prototype.resize = function (width, height) {
  	    // Adding this validation for backwards compatibility in case an event object was being passed down
  	    var _width = typeof width === 'number' ? width : undefined;
  	    var _height = typeof height === 'number' ? height : undefined;
  	    this.renderer.updateContainerSize(_width, _height);
  	  };
  	  AnimationItem.prototype.setSubframe = function (flag) {
  	    this.isSubframeEnabled = !!flag;
  	  };
  	  AnimationItem.prototype.gotoFrame = function () {
  	    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

  	    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
  	      this.currentFrame = this.timeCompleted;
  	    }
  	    this.trigger('enterFrame');
  	    this.renderFrame();
  	    this.trigger('drawnFrame');
  	  };
  	  AnimationItem.prototype.renderFrame = function () {
  	    if (this.isLoaded === false || !this.renderer) {
  	      return;
  	    }
  	    try {
  	      if (this.expressionsPlugin) {
  	        this.expressionsPlugin.resetFrame();
  	      }
  	      this.renderer.renderFrame(this.currentFrame + this.firstFrame);
  	    } catch (error) {
  	      this.triggerRenderFrameError(error);
  	    }
  	  };
  	  AnimationItem.prototype.play = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    if (this.isPaused === true) {
  	      this.isPaused = false;
  	      this.trigger('_play');
  	      this.audioController.resume();
  	      if (this._idle) {
  	        this._idle = false;
  	        this.trigger('_active');
  	      }
  	    }
  	  };
  	  AnimationItem.prototype.pause = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    if (this.isPaused === false) {
  	      this.isPaused = true;
  	      this.trigger('_pause');
  	      this._idle = true;
  	      this.trigger('_idle');
  	      this.audioController.pause();
  	    }
  	  };
  	  AnimationItem.prototype.togglePause = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    if (this.isPaused === true) {
  	      this.play();
  	    } else {
  	      this.pause();
  	    }
  	  };
  	  AnimationItem.prototype.stop = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    this.pause();
  	    this.playCount = 0;
  	    this._completedLoop = false;
  	    this.setCurrentRawFrameValue(0);
  	  };
  	  AnimationItem.prototype.getMarkerData = function (markerName) {
  	    var marker;
  	    for (var i = 0; i < this.markers.length; i += 1) {
  	      marker = this.markers[i];
  	      if (marker.payload && marker.payload.name === markerName) {
  	        return marker;
  	      }
  	    }
  	    return null;
  	  };
  	  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    var numValue = Number(value);
  	    if (isNaN(numValue)) {
  	      var marker = this.getMarkerData(value);
  	      if (marker) {
  	        this.goToAndStop(marker.time, true);
  	      }
  	    } else if (isFrame) {
  	      this.setCurrentRawFrameValue(value);
  	    } else {
  	      this.setCurrentRawFrameValue(value * this.frameModifier);
  	    }
  	    this.pause();
  	  };
  	  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    var numValue = Number(value);
  	    if (isNaN(numValue)) {
  	      var marker = this.getMarkerData(value);
  	      if (marker) {
  	        if (!marker.duration) {
  	          this.goToAndStop(marker.time, true);
  	        } else {
  	          this.playSegments([marker.time, marker.time + marker.duration], true);
  	        }
  	      }
  	    } else {
  	      this.goToAndStop(numValue, isFrame, name);
  	    }
  	    this.play();
  	  };
  	  AnimationItem.prototype.advanceTime = function (value) {
  	    if (this.isPaused === true || this.isLoaded === false) {
  	      return;
  	    }
  	    var nextValue = this.currentRawFrame + value * this.frameModifier;
  	    var _isComplete = false;
  	    // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
  	    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
  	    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
  	      if (!this.loop || this.playCount === this.loop) {
  	        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
  	          _isComplete = true;
  	          nextValue = this.totalFrames - 1;
  	        }
  	      } else if (nextValue >= this.totalFrames) {
  	        this.playCount += 1;
  	        if (!this.checkSegments(nextValue % this.totalFrames)) {
  	          this.setCurrentRawFrameValue(nextValue % this.totalFrames);
  	          this._completedLoop = true;
  	          this.trigger('loopComplete');
  	        }
  	      } else {
  	        this.setCurrentRawFrameValue(nextValue);
  	      }
  	    } else if (nextValue < 0) {
  	      if (!this.checkSegments(nextValue % this.totalFrames)) {
  	        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
  	          // eslint-disable-line no-plusplus
  	          this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
  	          if (!this._completedLoop) {
  	            this._completedLoop = true;
  	          } else {
  	            this.trigger('loopComplete');
  	          }
  	        } else {
  	          _isComplete = true;
  	          nextValue = 0;
  	        }
  	      }
  	    } else {
  	      this.setCurrentRawFrameValue(nextValue);
  	    }
  	    if (_isComplete) {
  	      this.setCurrentRawFrameValue(nextValue);
  	      this.pause();
  	      this.trigger('complete');
  	    }
  	  };
  	  AnimationItem.prototype.adjustSegment = function (arr, offset) {
  	    this.playCount = 0;
  	    if (arr[1] < arr[0]) {
  	      if (this.frameModifier > 0) {
  	        if (this.playSpeed < 0) {
  	          this.setSpeed(-this.playSpeed);
  	        } else {
  	          this.setDirection(-1);
  	        }
  	      }
  	      this.totalFrames = arr[0] - arr[1];
  	      this.timeCompleted = this.totalFrames;
  	      this.firstFrame = arr[1];
  	      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
  	    } else if (arr[1] > arr[0]) {
  	      if (this.frameModifier < 0) {
  	        if (this.playSpeed < 0) {
  	          this.setSpeed(-this.playSpeed);
  	        } else {
  	          this.setDirection(1);
  	        }
  	      }
  	      this.totalFrames = arr[1] - arr[0];
  	      this.timeCompleted = this.totalFrames;
  	      this.firstFrame = arr[0];
  	      this.setCurrentRawFrameValue(0.001 + offset);
  	    }
  	    this.trigger('segmentStart');
  	  };
  	  AnimationItem.prototype.setSegment = function (init, end) {
  	    var pendingFrame = -1;
  	    if (this.isPaused) {
  	      if (this.currentRawFrame + this.firstFrame < init) {
  	        pendingFrame = init;
  	      } else if (this.currentRawFrame + this.firstFrame > end) {
  	        pendingFrame = end - init;
  	      }
  	    }
  	    this.firstFrame = init;
  	    this.totalFrames = end - init;
  	    this.timeCompleted = this.totalFrames;
  	    if (pendingFrame !== -1) {
  	      this.goToAndStop(pendingFrame, true);
  	    }
  	  };
  	  AnimationItem.prototype.playSegments = function (arr, forceFlag) {
  	    if (forceFlag) {
  	      this.segments.length = 0;
  	    }
  	    if (_typeof$4(arr[0]) === 'object') {
  	      var i;
  	      var len = arr.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.segments.push(arr[i]);
  	      }
  	    } else {
  	      this.segments.push(arr);
  	    }
  	    if (this.segments.length && forceFlag) {
  	      this.adjustSegment(this.segments.shift(), 0);
  	    }
  	    if (this.isPaused) {
  	      this.play();
  	    }
  	  };
  	  AnimationItem.prototype.resetSegments = function (forceFlag) {
  	    this.segments.length = 0;
  	    this.segments.push([this.animationData.ip, this.animationData.op]);
  	    if (forceFlag) {
  	      this.checkSegments(0);
  	    }
  	  };
  	  AnimationItem.prototype.checkSegments = function (offset) {
  	    if (this.segments.length) {
  	      this.adjustSegment(this.segments.shift(), offset);
  	      return true;
  	    }
  	    return false;
  	  };
  	  AnimationItem.prototype.destroy = function (name) {
  	    if (name && this.name !== name || !this.renderer) {
  	      return;
  	    }
  	    this.renderer.destroy();
  	    this.imagePreloader.destroy();
  	    this.trigger('destroy');
  	    this._cbs = null;
  	    this.onEnterFrame = null;
  	    this.onLoopComplete = null;
  	    this.onComplete = null;
  	    this.onSegmentStart = null;
  	    this.onDestroy = null;
  	    this.renderer = null;
  	    this.expressionsPlugin = null;
  	    this.imagePreloader = null;
  	    this.projectInterface = null;
  	  };
  	  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
  	    this.currentRawFrame = value;
  	    this.gotoFrame();
  	  };
  	  AnimationItem.prototype.setSpeed = function (val) {
  	    this.playSpeed = val;
  	    this.updaFrameModifier();
  	  };
  	  AnimationItem.prototype.setDirection = function (val) {
  	    this.playDirection = val < 0 ? -1 : 1;
  	    this.updaFrameModifier();
  	  };
  	  AnimationItem.prototype.setLoop = function (isLooping) {
  	    this.loop = isLooping;
  	  };
  	  AnimationItem.prototype.setVolume = function (val, name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    this.audioController.setVolume(val);
  	  };
  	  AnimationItem.prototype.getVolume = function () {
  	    return this.audioController.getVolume();
  	  };
  	  AnimationItem.prototype.mute = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    this.audioController.mute();
  	  };
  	  AnimationItem.prototype.unmute = function (name) {
  	    if (name && this.name !== name) {
  	      return;
  	    }
  	    this.audioController.unmute();
  	  };
  	  AnimationItem.prototype.updaFrameModifier = function () {
  	    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
  	    this.audioController.setRate(this.playSpeed * this.playDirection);
  	  };
  	  AnimationItem.prototype.getPath = function () {
  	    return this.path;
  	  };
  	  AnimationItem.prototype.getAssetsPath = function (assetData) {
  	    var path = '';
  	    if (assetData.e) {
  	      path = assetData.p;
  	    } else if (this.assetsPath) {
  	      var imagePath = assetData.p;
  	      if (imagePath.indexOf('images/') !== -1) {
  	        imagePath = imagePath.split('/')[1];
  	      }
  	      path = this.assetsPath + imagePath;
  	    } else {
  	      path = this.path;
  	      path += assetData.u ? assetData.u : '';
  	      path += assetData.p;
  	    }
  	    return path;
  	  };
  	  AnimationItem.prototype.getAssetData = function (id) {
  	    var i = 0;
  	    var len = this.assets.length;
  	    while (i < len) {
  	      if (id === this.assets[i].id) {
  	        return this.assets[i];
  	      }
  	      i += 1;
  	    }
  	    return null;
  	  };
  	  AnimationItem.prototype.hide = function () {
  	    this.renderer.hide();
  	  };
  	  AnimationItem.prototype.show = function () {
  	    this.renderer.show();
  	  };
  	  AnimationItem.prototype.getDuration = function (isFrame) {
  	    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
  	  };
  	  AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {
  	    try {
  	      var element = this.renderer.getElementByPath(path);
  	      element.updateDocumentData(documentData, index);
  	    } catch (error) {
  	      // TODO: decide how to handle catch case
  	    }
  	  };
  	  AnimationItem.prototype.trigger = function (name) {
  	    if (this._cbs && this._cbs[name]) {
  	      switch (name) {
  	        case 'enterFrame':
  	          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
  	          break;
  	        case 'drawnFrame':
  	          this.drawnFrameEvent.currentTime = this.currentFrame;
  	          this.drawnFrameEvent.totalTime = this.totalFrames;
  	          this.drawnFrameEvent.direction = this.frameModifier;
  	          this.triggerEvent(name, this.drawnFrameEvent);
  	          break;
  	        case 'loopComplete':
  	          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
  	          break;
  	        case 'complete':
  	          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
  	          break;
  	        case 'segmentStart':
  	          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
  	          break;
  	        case 'destroy':
  	          this.triggerEvent(name, new BMDestroyEvent(name, this));
  	          break;
  	        default:
  	          this.triggerEvent(name);
  	      }
  	    }
  	    if (name === 'enterFrame' && this.onEnterFrame) {
  	      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
  	    }
  	    if (name === 'loopComplete' && this.onLoopComplete) {
  	      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
  	    }
  	    if (name === 'complete' && this.onComplete) {
  	      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
  	    }
  	    if (name === 'segmentStart' && this.onSegmentStart) {
  	      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
  	    }
  	    if (name === 'destroy' && this.onDestroy) {
  	      this.onDestroy.call(this, new BMDestroyEvent(name, this));
  	    }
  	  };
  	  AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
  	    var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
  	    this.triggerEvent('error', error);
  	    if (this.onError) {
  	      this.onError.call(this, error);
  	    }
  	  };
  	  AnimationItem.prototype.triggerConfigError = function (nativeError) {
  	    var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
  	    this.triggerEvent('error', error);
  	    if (this.onError) {
  	      this.onError.call(this, error);
  	    }
  	  };

  	  var animationManager = function () {
  	    var moduleOb = {};
  	    var registeredAnimations = [];
  	    var initTime = 0;
  	    var len = 0;
  	    var playingAnimationsNum = 0;
  	    var _stopped = true;
  	    var _isFrozen = false;
  	    function removeElement(ev) {
  	      var i = 0;
  	      var animItem = ev.target;
  	      while (i < len) {
  	        if (registeredAnimations[i].animation === animItem) {
  	          registeredAnimations.splice(i, 1);
  	          i -= 1;
  	          len -= 1;
  	          if (!animItem.isPaused) {
  	            subtractPlayingCount();
  	          }
  	        }
  	        i += 1;
  	      }
  	    }
  	    function registerAnimation(element, animationData) {
  	      if (!element) {
  	        return null;
  	      }
  	      var i = 0;
  	      while (i < len) {
  	        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
  	          return registeredAnimations[i].animation;
  	        }
  	        i += 1;
  	      }
  	      var animItem = new AnimationItem();
  	      setupAnimation(animItem, element);
  	      animItem.setData(element, animationData);
  	      return animItem;
  	    }
  	    function getRegisteredAnimations() {
  	      var i;
  	      var lenAnims = registeredAnimations.length;
  	      var animations = [];
  	      for (i = 0; i < lenAnims; i += 1) {
  	        animations.push(registeredAnimations[i].animation);
  	      }
  	      return animations;
  	    }
  	    function addPlayingCount() {
  	      playingAnimationsNum += 1;
  	      activate();
  	    }
  	    function subtractPlayingCount() {
  	      playingAnimationsNum -= 1;
  	    }
  	    function setupAnimation(animItem, element) {
  	      animItem.addEventListener('destroy', removeElement);
  	      animItem.addEventListener('_active', addPlayingCount);
  	      animItem.addEventListener('_idle', subtractPlayingCount);
  	      registeredAnimations.push({
  	        elem: element,
  	        animation: animItem
  	      });
  	      len += 1;
  	    }
  	    function loadAnimation(params) {
  	      var animItem = new AnimationItem();
  	      setupAnimation(animItem, null);
  	      animItem.setParams(params);
  	      return animItem;
  	    }
  	    function setSpeed(val, animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.setSpeed(val, animation);
  	      }
  	    }
  	    function setDirection(val, animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.setDirection(val, animation);
  	      }
  	    }
  	    function play(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.play(animation);
  	      }
  	    }
  	    function resume(nowTime) {
  	      var elapsedTime = nowTime - initTime;
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.advanceTime(elapsedTime);
  	      }
  	      initTime = nowTime;
  	      if (playingAnimationsNum && !_isFrozen) {
  	        window.requestAnimationFrame(resume);
  	      } else {
  	        _stopped = true;
  	      }
  	    }
  	    function first(nowTime) {
  	      initTime = nowTime;
  	      window.requestAnimationFrame(resume);
  	    }
  	    function pause(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.pause(animation);
  	      }
  	    }
  	    function goToAndStop(value, isFrame, animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
  	      }
  	    }
  	    function stop(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.stop(animation);
  	      }
  	    }
  	    function togglePause(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.togglePause(animation);
  	      }
  	    }
  	    function destroy(animation) {
  	      var i;
  	      for (i = len - 1; i >= 0; i -= 1) {
  	        registeredAnimations[i].animation.destroy(animation);
  	      }
  	    }
  	    function searchAnimations(animationData, standalone, renderer) {
  	      var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
  	      var i;
  	      var lenAnims = animElements.length;
  	      for (i = 0; i < lenAnims; i += 1) {
  	        if (renderer) {
  	          animElements[i].setAttribute('data-bm-type', renderer);
  	        }
  	        registerAnimation(animElements[i], animationData);
  	      }
  	      if (standalone && lenAnims === 0) {
  	        if (!renderer) {
  	          renderer = 'svg';
  	        }
  	        var body = document.getElementsByTagName('body')[0];
  	        body.innerText = '';
  	        var div = createTag('div');
  	        div.style.width = '100%';
  	        div.style.height = '100%';
  	        div.setAttribute('data-bm-type', renderer);
  	        body.appendChild(div);
  	        registerAnimation(div, animationData);
  	      }
  	    }
  	    function resize() {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.resize();
  	      }
  	    }
  	    function activate() {
  	      if (!_isFrozen && playingAnimationsNum) {
  	        if (_stopped) {
  	          window.requestAnimationFrame(first);
  	          _stopped = false;
  	        }
  	      }
  	    }
  	    function freeze() {
  	      _isFrozen = true;
  	    }
  	    function unfreeze() {
  	      _isFrozen = false;
  	      activate();
  	    }
  	    function setVolume(val, animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.setVolume(val, animation);
  	      }
  	    }
  	    function mute(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.mute(animation);
  	      }
  	    }
  	    function unmute(animation) {
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        registeredAnimations[i].animation.unmute(animation);
  	      }
  	    }
  	    moduleOb.registerAnimation = registerAnimation;
  	    moduleOb.loadAnimation = loadAnimation;
  	    moduleOb.setSpeed = setSpeed;
  	    moduleOb.setDirection = setDirection;
  	    moduleOb.play = play;
  	    moduleOb.pause = pause;
  	    moduleOb.stop = stop;
  	    moduleOb.togglePause = togglePause;
  	    moduleOb.searchAnimations = searchAnimations;
  	    moduleOb.resize = resize;
  	    // moduleOb.start = start;
  	    moduleOb.goToAndStop = goToAndStop;
  	    moduleOb.destroy = destroy;
  	    moduleOb.freeze = freeze;
  	    moduleOb.unfreeze = unfreeze;
  	    moduleOb.setVolume = setVolume;
  	    moduleOb.mute = mute;
  	    moduleOb.unmute = unmute;
  	    moduleOb.getRegisteredAnimations = getRegisteredAnimations;
  	    return moduleOb;
  	  }();

  	  /* eslint-disable */
  	  var BezierFactory = function () {
  	    /**
  	       * BezierEasing - use bezier curve for transition easing function
  	       * by Gatan Renaudeau 2014 - 2015  MIT License
  	       *
  	       * Credits: is based on Firefox's nsSMILKeySpline.cpp
  	       * Usage:
  	       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
  	       * spline.get(x) => returns the easing value | x must be in [0, 1] range
  	       *
  	       */

  	    var ob = {};
  	    ob.getBezierEasing = getBezierEasing;
  	    var beziers = {};
  	    function getBezierEasing(a, b, c, d, nm) {
  	      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
  	      if (beziers[str]) {
  	        return beziers[str];
  	      }
  	      var bezEasing = new BezierEasing([a, b, c, d]);
  	      beziers[str] = bezEasing;
  	      return bezEasing;
  	    }

  	    // These values are established by empiricism with tests (tradeoff: performance VS precision)
  	    var NEWTON_ITERATIONS = 4;
  	    var NEWTON_MIN_SLOPE = 0.001;
  	    var SUBDIVISION_PRECISION = 0.0000001;
  	    var SUBDIVISION_MAX_ITERATIONS = 10;
  	    var kSplineTableSize = 11;
  	    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  	    var float32ArraySupported = typeof Float32Array === 'function';
  	    function A(aA1, aA2) {
  	      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  	    }
  	    function B(aA1, aA2) {
  	      return 3.0 * aA2 - 6.0 * aA1;
  	    }
  	    function C(aA1) {
  	      return 3.0 * aA1;
  	    }

  	    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  	    function calcBezier(aT, aA1, aA2) {
  	      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  	    }

  	    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  	    function getSlope(aT, aA1, aA2) {
  	      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  	    }
  	    function binarySubdivide(aX, aA, aB, mX1, mX2) {
  	      var currentX,
  	        currentT,
  	        i = 0;
  	      do {
  	        currentT = aA + (aB - aA) / 2.0;
  	        currentX = calcBezier(currentT, mX1, mX2) - aX;
  	        if (currentX > 0.0) {
  	          aB = currentT;
  	        } else {
  	          aA = currentT;
  	        }
  	      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  	      return currentT;
  	    }
  	    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  	      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
  	        var currentSlope = getSlope(aGuessT, mX1, mX2);
  	        if (currentSlope === 0.0) return aGuessT;
  	        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
  	        aGuessT -= currentX / currentSlope;
  	      }
  	      return aGuessT;
  	    }

  	    /**
  	       * points is an array of [ mX1, mY1, mX2, mY2 ]
  	       */
  	    function BezierEasing(points) {
  	      this._p = points;
  	      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  	      this._precomputed = false;
  	      this.get = this.get.bind(this);
  	    }
  	    BezierEasing.prototype = {
  	      get: function get(x) {
  	        var mX1 = this._p[0],
  	          mY1 = this._p[1],
  	          mX2 = this._p[2],
  	          mY2 = this._p[3];
  	        if (!this._precomputed) this._precompute();
  	        if (mX1 === mY1 && mX2 === mY2) return x; // linear
  	        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
  	        if (x === 0) return 0;
  	        if (x === 1) return 1;
  	        return calcBezier(this._getTForX(x), mY1, mY2);
  	      },
  	      // Private part

  	      _precompute: function _precompute() {
  	        var mX1 = this._p[0],
  	          mY1 = this._p[1],
  	          mX2 = this._p[2],
  	          mY2 = this._p[3];
  	        this._precomputed = true;
  	        if (mX1 !== mY1 || mX2 !== mY2) {
  	          this._calcSampleValues();
  	        }
  	      },
  	      _calcSampleValues: function _calcSampleValues() {
  	        var mX1 = this._p[0],
  	          mX2 = this._p[2];
  	        for (var i = 0; i < kSplineTableSize; ++i) {
  	          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  	        }
  	      },
  	      /**
  	           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
  	           */
  	      _getTForX: function _getTForX(aX) {
  	        var mX1 = this._p[0],
  	          mX2 = this._p[2],
  	          mSampleValues = this._mSampleValues;
  	        var intervalStart = 0.0;
  	        var currentSample = 1;
  	        var lastSample = kSplineTableSize - 1;
  	        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
  	          intervalStart += kSampleStepSize;
  	        }
  	        --currentSample;

  	        // Interpolate to provide an initial guess for t
  	        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
  	        var guessForT = intervalStart + dist * kSampleStepSize;
  	        var initialSlope = getSlope(guessForT, mX1, mX2);
  	        if (initialSlope >= NEWTON_MIN_SLOPE) {
  	          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
  	        }
  	        if (initialSlope === 0.0) {
  	          return guessForT;
  	        }
  	        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
  	      }
  	    };
  	    return ob;
  	  }();

  	  var pooling = function () {
  	    function _double(arr) {
  	      return arr.concat(createSizedArray(arr.length));
  	    }
  	    return {
  	      "double": _double
  	    };
  	  }();

  	  var poolFactory = function () {
  	    return function (initialLength, _create, _release) {
  	      var _length = 0;
  	      var _maxLength = initialLength;
  	      var pool = createSizedArray(_maxLength);
  	      var ob = {
  	        newElement: newElement,
  	        release: release
  	      };
  	      function newElement() {
  	        var element;
  	        if (_length) {
  	          _length -= 1;
  	          element = pool[_length];
  	        } else {
  	          element = _create();
  	        }
  	        return element;
  	      }
  	      function release(element) {
  	        if (_length === _maxLength) {
  	          pool = pooling["double"](pool);
  	          _maxLength *= 2;
  	        }
  	        if (_release) {
  	          _release(element);
  	        }
  	        pool[_length] = element;
  	        _length += 1;
  	      }
  	      return ob;
  	    };
  	  }();

  	  var bezierLengthPool = function () {
  	    function create() {
  	      return {
  	        addedLength: 0,
  	        percents: createTypedArray('float32', getDefaultCurveSegments()),
  	        lengths: createTypedArray('float32', getDefaultCurveSegments())
  	      };
  	    }
  	    return poolFactory(8, create);
  	  }();

  	  var segmentsLengthPool = function () {
  	    function create() {
  	      return {
  	        lengths: [],
  	        totalLength: 0
  	      };
  	    }
  	    function release(element) {
  	      var i;
  	      var len = element.lengths.length;
  	      for (i = 0; i < len; i += 1) {
  	        bezierLengthPool.release(element.lengths[i]);
  	      }
  	      element.lengths.length = 0;
  	    }
  	    return poolFactory(8, create, release);
  	  }();

  	  function bezFunction() {
  	    var math = Math;
  	    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
  	      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
  	      return det1 > -0.001 && det1 < 0.001;
  	    }
  	    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
  	      if (z1 === 0 && z2 === 0 && z3 === 0) {
  	        return pointOnLine2D(x1, y1, x2, y2, x3, y3);
  	      }
  	      var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
  	      var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
  	      var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
  	      var diffDist;
  	      if (dist1 > dist2) {
  	        if (dist1 > dist3) {
  	          diffDist = dist1 - dist2 - dist3;
  	        } else {
  	          diffDist = dist3 - dist2 - dist1;
  	        }
  	      } else if (dist3 > dist2) {
  	        diffDist = dist3 - dist2 - dist1;
  	      } else {
  	        diffDist = dist2 - dist1 - dist3;
  	      }
  	      return diffDist > -0.0001 && diffDist < 0.0001;
  	    }
  	    var getBezierLength = function () {
  	      return function (pt1, pt2, pt3, pt4) {
  	        var curveSegments = getDefaultCurveSegments();
  	        var k;
  	        var i;
  	        var len;
  	        var ptCoord;
  	        var perc;
  	        var addedLength = 0;
  	        var ptDistance;
  	        var point = [];
  	        var lastPoint = [];
  	        var lengthData = bezierLengthPool.newElement();
  	        len = pt3.length;
  	        for (k = 0; k < curveSegments; k += 1) {
  	          perc = k / (curveSegments - 1);
  	          ptDistance = 0;
  	          for (i = 0; i < len; i += 1) {
  	            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
  	            point[i] = ptCoord;
  	            if (lastPoint[i] !== null) {
  	              ptDistance += bmPow(point[i] - lastPoint[i], 2);
  	            }
  	            lastPoint[i] = point[i];
  	          }
  	          if (ptDistance) {
  	            ptDistance = bmSqrt(ptDistance);
  	            addedLength += ptDistance;
  	          }
  	          lengthData.percents[k] = perc;
  	          lengthData.lengths[k] = addedLength;
  	        }
  	        lengthData.addedLength = addedLength;
  	        return lengthData;
  	      };
  	    }();
  	    function getSegmentsLength(shapeData) {
  	      var segmentsLength = segmentsLengthPool.newElement();
  	      var closed = shapeData.c;
  	      var pathV = shapeData.v;
  	      var pathO = shapeData.o;
  	      var pathI = shapeData.i;
  	      var i;
  	      var len = shapeData._length;
  	      var lengths = segmentsLength.lengths;
  	      var totalLength = 0;
  	      for (i = 0; i < len - 1; i += 1) {
  	        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
  	        totalLength += lengths[i].addedLength;
  	      }
  	      if (closed && len) {
  	        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
  	        totalLength += lengths[i].addedLength;
  	      }
  	      segmentsLength.totalLength = totalLength;
  	      return segmentsLength;
  	    }
  	    function BezierData(length) {
  	      this.segmentLength = 0;
  	      this.points = new Array(length);
  	    }
  	    function PointData(partial, point) {
  	      this.partialLength = partial;
  	      this.point = point;
  	    }
  	    var buildBezierData = function () {
  	      var storedData = {};
  	      return function (pt1, pt2, pt3, pt4) {
  	        var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
  	        if (!storedData[bezierName]) {
  	          var curveSegments = getDefaultCurveSegments();
  	          var k;
  	          var i;
  	          var len;
  	          var ptCoord;
  	          var perc;
  	          var addedLength = 0;
  	          var ptDistance;
  	          var point;
  	          var lastPoint = null;
  	          if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
  	            curveSegments = 2;
  	          }
  	          var bezierData = new BezierData(curveSegments);
  	          len = pt3.length;
  	          for (k = 0; k < curveSegments; k += 1) {
  	            point = createSizedArray(len);
  	            perc = k / (curveSegments - 1);
  	            ptDistance = 0;
  	            for (i = 0; i < len; i += 1) {
  	              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
  	              point[i] = ptCoord;
  	              if (lastPoint !== null) {
  	                ptDistance += bmPow(point[i] - lastPoint[i], 2);
  	              }
  	            }
  	            ptDistance = bmSqrt(ptDistance);
  	            addedLength += ptDistance;
  	            bezierData.points[k] = new PointData(ptDistance, point);
  	            lastPoint = point;
  	          }
  	          bezierData.segmentLength = addedLength;
  	          storedData[bezierName] = bezierData;
  	        }
  	        return storedData[bezierName];
  	      };
  	    }();
  	    function getDistancePerc(perc, bezierData) {
  	      var percents = bezierData.percents;
  	      var lengths = bezierData.lengths;
  	      var len = percents.length;
  	      var initPos = bmFloor((len - 1) * perc);
  	      var lengthPos = perc * bezierData.addedLength;
  	      var lPerc = 0;
  	      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
  	        return percents[initPos];
  	      }
  	      var dir = lengths[initPos] > lengthPos ? -1 : 1;
  	      var flag = true;
  	      while (flag) {
  	        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
  	          lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
  	          flag = false;
  	        } else {
  	          initPos += dir;
  	        }
  	        if (initPos < 0 || initPos >= len - 1) {
  	          // FIX for TypedArrays that don't store floating point values with enough accuracy
  	          if (initPos === len - 1) {
  	            return percents[initPos];
  	          }
  	          flag = false;
  	        }
  	      }
  	      return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
  	    }
  	    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
  	      var t1 = getDistancePerc(percent, bezierData);
  	      var u1 = 1 - t1;
  	      var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
  	      var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
  	      return [ptX, ptY];
  	    }
  	    var bezierSegmentPoints = createTypedArray('float32', 8);
  	    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
  	      if (startPerc < 0) {
  	        startPerc = 0;
  	      } else if (startPerc > 1) {
  	        startPerc = 1;
  	      }
  	      var t0 = getDistancePerc(startPerc, bezierData);
  	      endPerc = endPerc > 1 ? 1 : endPerc;
  	      var t1 = getDistancePerc(endPerc, bezierData);
  	      var i;
  	      var len = pt1.length;
  	      var u0 = 1 - t0;
  	      var u1 = 1 - t1;
  	      var u0u0u0 = u0 * u0 * u0;
  	      var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
  	      var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
  	      var t0t0t0 = t0 * t0 * t0;
  	      //
  	      var u0u0u1 = u0 * u0 * u1;
  	      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
  	      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
  	      var t0t0t1 = t0 * t0 * t1;
  	      //
  	      var u0u1u1 = u0 * u1 * u1;
  	      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
  	      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
  	      var t0t1t1 = t0 * t1 * t1;
  	      //
  	      var u1u1u1 = u1 * u1 * u1;
  	      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
  	      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
  	      var t1t1t1 = t1 * t1 * t1;
  	      for (i = 0; i < len; i += 1) {
  	        bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
  	        bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
  	        bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
  	        bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
  	      }
  	      return bezierSegmentPoints;
  	    }
  	    return {
  	      getSegmentsLength: getSegmentsLength,
  	      getNewSegment: getNewSegment,
  	      getPointInSegment: getPointInSegment,
  	      buildBezierData: buildBezierData,
  	      pointOnLine2D: pointOnLine2D,
  	      pointOnLine3D: pointOnLine3D
  	    };
  	  }
  	  var bez = bezFunction();

  	  var initFrame = initialDefaultFrame;
  	  var mathAbs = Math.abs;
  	  function interpolateValue(frameNum, caching) {
  	    var offsetTime = this.offsetTime;
  	    var newValue;
  	    if (this.propType === 'multidimensional') {
  	      newValue = createTypedArray('float32', this.pv.length);
  	    }
  	    var iterationIndex = caching.lastIndex;
  	    var i = iterationIndex;
  	    var len = this.keyframes.length - 1;
  	    var flag = true;
  	    var keyData;
  	    var nextKeyData;
  	    var keyframeMetadata;
  	    while (flag) {
  	      keyData = this.keyframes[i];
  	      nextKeyData = this.keyframes[i + 1];
  	      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
  	        if (keyData.h) {
  	          keyData = nextKeyData;
  	        }
  	        iterationIndex = 0;
  	        break;
  	      }
  	      if (nextKeyData.t - offsetTime > frameNum) {
  	        iterationIndex = i;
  	        break;
  	      }
  	      if (i < len - 1) {
  	        i += 1;
  	      } else {
  	        iterationIndex = 0;
  	        flag = false;
  	      }
  	    }
  	    keyframeMetadata = this.keyframesMetadata[i] || {};
  	    var k;
  	    var kLen;
  	    var perc;
  	    var jLen;
  	    var j;
  	    var fnc;
  	    var nextKeyTime = nextKeyData.t - offsetTime;
  	    var keyTime = keyData.t - offsetTime;
  	    var endValue;
  	    if (keyData.to) {
  	      if (!keyframeMetadata.bezierData) {
  	        keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
  	      }
  	      var bezierData = keyframeMetadata.bezierData;
  	      if (frameNum >= nextKeyTime || frameNum < keyTime) {
  	        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
  	        kLen = bezierData.points[ind].point.length;
  	        for (k = 0; k < kLen; k += 1) {
  	          newValue[k] = bezierData.points[ind].point[k];
  	        }
  	        // caching._lastKeyframeIndex = -1;
  	      } else {
  	        if (keyframeMetadata.__fnct) {
  	          fnc = keyframeMetadata.__fnct;
  	        } else {
  	          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
  	          keyframeMetadata.__fnct = fnc;
  	        }
  	        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
  	        var distanceInLine = bezierData.segmentLength * perc;
  	        var segmentPerc;
  	        var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
  	        j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
  	        flag = true;
  	        jLen = bezierData.points.length;
  	        while (flag) {
  	          addedLength += bezierData.points[j].partialLength;
  	          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
  	            kLen = bezierData.points[j].point.length;
  	            for (k = 0; k < kLen; k += 1) {
  	              newValue[k] = bezierData.points[j].point[k];
  	            }
  	            break;
  	          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
  	            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
  	            kLen = bezierData.points[j].point.length;
  	            for (k = 0; k < kLen; k += 1) {
  	              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
  	            }
  	            break;
  	          }
  	          if (j < jLen - 1) {
  	            j += 1;
  	          } else {
  	            flag = false;
  	          }
  	        }
  	        caching._lastPoint = j;
  	        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
  	        caching._lastKeyframeIndex = i;
  	      }
  	    } else {
  	      var outX;
  	      var outY;
  	      var inX;
  	      var inY;
  	      var keyValue;
  	      len = keyData.s.length;
  	      endValue = nextKeyData.s || keyData.e;
  	      if (this.sh && keyData.h !== 1) {
  	        if (frameNum >= nextKeyTime) {
  	          newValue[0] = endValue[0];
  	          newValue[1] = endValue[1];
  	          newValue[2] = endValue[2];
  	        } else if (frameNum <= keyTime) {
  	          newValue[0] = keyData.s[0];
  	          newValue[1] = keyData.s[1];
  	          newValue[2] = keyData.s[2];
  	        } else {
  	          var quatStart = createQuaternion(keyData.s);
  	          var quatEnd = createQuaternion(endValue);
  	          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
  	          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
  	        }
  	      } else {
  	        for (i = 0; i < len; i += 1) {
  	          if (keyData.h !== 1) {
  	            if (frameNum >= nextKeyTime) {
  	              perc = 1;
  	            } else if (frameNum < keyTime) {
  	              perc = 0;
  	            } else {
  	              if (keyData.o.x.constructor === Array) {
  	                if (!keyframeMetadata.__fnct) {
  	                  keyframeMetadata.__fnct = [];
  	                }
  	                if (!keyframeMetadata.__fnct[i]) {
  	                  outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
  	                  outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
  	                  inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
  	                  inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
  	                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
  	                  keyframeMetadata.__fnct[i] = fnc;
  	                } else {
  	                  fnc = keyframeMetadata.__fnct[i];
  	                }
  	              } else if (!keyframeMetadata.__fnct) {
  	                outX = keyData.o.x;
  	                outY = keyData.o.y;
  	                inX = keyData.i.x;
  	                inY = keyData.i.y;
  	                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
  	                keyData.keyframeMetadata = fnc;
  	              } else {
  	                fnc = keyframeMetadata.__fnct;
  	              }
  	              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
  	            }
  	          }
  	          endValue = nextKeyData.s || keyData.e;
  	          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
  	          if (this.propType === 'multidimensional') {
  	            newValue[i] = keyValue;
  	          } else {
  	            newValue = keyValue;
  	          }
  	        }
  	      }
  	    }
  	    caching.lastIndex = iterationIndex;
  	    return newValue;
  	  }

  	  // based on @Toji's https://github.com/toji/gl-matrix/
  	  function slerp(a, b, t) {
  	    var out = [];
  	    var ax = a[0];
  	    var ay = a[1];
  	    var az = a[2];
  	    var aw = a[3];
  	    var bx = b[0];
  	    var by = b[1];
  	    var bz = b[2];
  	    var bw = b[3];
  	    var omega;
  	    var cosom;
  	    var sinom;
  	    var scale0;
  	    var scale1;
  	    cosom = ax * bx + ay * by + az * bz + aw * bw;
  	    if (cosom < 0.0) {
  	      cosom = -cosom;
  	      bx = -bx;
  	      by = -by;
  	      bz = -bz;
  	      bw = -bw;
  	    }
  	    if (1.0 - cosom > 0.000001) {
  	      omega = Math.acos(cosom);
  	      sinom = Math.sin(omega);
  	      scale0 = Math.sin((1.0 - t) * omega) / sinom;
  	      scale1 = Math.sin(t * omega) / sinom;
  	    } else {
  	      scale0 = 1.0 - t;
  	      scale1 = t;
  	    }
  	    out[0] = scale0 * ax + scale1 * bx;
  	    out[1] = scale0 * ay + scale1 * by;
  	    out[2] = scale0 * az + scale1 * bz;
  	    out[3] = scale0 * aw + scale1 * bw;
  	    return out;
  	  }
  	  function quaternionToEuler(out, quat) {
  	    var qx = quat[0];
  	    var qy = quat[1];
  	    var qz = quat[2];
  	    var qw = quat[3];
  	    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
  	    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
  	    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
  	    out[0] = heading / degToRads;
  	    out[1] = attitude / degToRads;
  	    out[2] = bank / degToRads;
  	  }
  	  function createQuaternion(values) {
  	    var heading = values[0] * degToRads;
  	    var attitude = values[1] * degToRads;
  	    var bank = values[2] * degToRads;
  	    var c1 = Math.cos(heading / 2);
  	    var c2 = Math.cos(attitude / 2);
  	    var c3 = Math.cos(bank / 2);
  	    var s1 = Math.sin(heading / 2);
  	    var s2 = Math.sin(attitude / 2);
  	    var s3 = Math.sin(bank / 2);
  	    var w = c1 * c2 * c3 - s1 * s2 * s3;
  	    var x = s1 * s2 * c3 + c1 * c2 * s3;
  	    var y = s1 * c2 * c3 + c1 * s2 * s3;
  	    var z = c1 * s2 * c3 - s1 * c2 * s3;
  	    return [x, y, z, w];
  	  }
  	  function getValueAtCurrentTime() {
  	    var frameNum = this.comp.renderedFrame - this.offsetTime;
  	    var initTime = this.keyframes[0].t - this.offsetTime;
  	    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
  	    if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
  	      if (this._caching.lastFrame >= frameNum) {
  	        this._caching._lastKeyframeIndex = -1;
  	        this._caching.lastIndex = 0;
  	      }
  	      var renderResult = this.interpolateValue(frameNum, this._caching);
  	      this.pv = renderResult;
  	    }
  	    this._caching.lastFrame = frameNum;
  	    return this.pv;
  	  }
  	  function setVValue(val) {
  	    var multipliedValue;
  	    if (this.propType === 'unidimensional') {
  	      multipliedValue = val * this.mult;
  	      if (mathAbs(this.v - multipliedValue) > 0.00001) {
  	        this.v = multipliedValue;
  	        this._mdf = true;
  	      }
  	    } else {
  	      var i = 0;
  	      var len = this.v.length;
  	      while (i < len) {
  	        multipliedValue = val[i] * this.mult;
  	        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
  	          this.v[i] = multipliedValue;
  	          this._mdf = true;
  	        }
  	        i += 1;
  	      }
  	    }
  	  }
  	  function processEffectsSequence() {
  	    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
  	      return;
  	    }
  	    if (this.lock) {
  	      this.setVValue(this.pv);
  	      return;
  	    }
  	    this.lock = true;
  	    this._mdf = this._isFirstFrame;
  	    var i;
  	    var len = this.effectsSequence.length;
  	    var finalValue = this.kf ? this.pv : this.data.k;
  	    for (i = 0; i < len; i += 1) {
  	      finalValue = this.effectsSequence[i](finalValue);
  	    }
  	    this.setVValue(finalValue);
  	    this._isFirstFrame = false;
  	    this.lock = false;
  	    this.frameId = this.elem.globalData.frameId;
  	  }
  	  function addEffect(effectFunction) {
  	    this.effectsSequence.push(effectFunction);
  	    this.container.addDynamicProperty(this);
  	  }
  	  function ValueProperty(elem, data, mult, container) {
  	    this.propType = 'unidimensional';
  	    this.mult = mult || 1;
  	    this.data = data;
  	    this.v = mult ? data.k * mult : data.k;
  	    this.pv = data.k;
  	    this._mdf = false;
  	    this.elem = elem;
  	    this.container = container;
  	    this.comp = elem.comp;
  	    this.k = false;
  	    this.kf = false;
  	    this.vel = 0;
  	    this.effectsSequence = [];
  	    this._isFirstFrame = true;
  	    this.getValue = processEffectsSequence;
  	    this.setVValue = setVValue;
  	    this.addEffect = addEffect;
  	  }
  	  function MultiDimensionalProperty(elem, data, mult, container) {
  	    this.propType = 'multidimensional';
  	    this.mult = mult || 1;
  	    this.data = data;
  	    this._mdf = false;
  	    this.elem = elem;
  	    this.container = container;
  	    this.comp = elem.comp;
  	    this.k = false;
  	    this.kf = false;
  	    this.frameId = -1;
  	    var i;
  	    var len = data.k.length;
  	    this.v = createTypedArray('float32', len);
  	    this.pv = createTypedArray('float32', len);
  	    this.vel = createTypedArray('float32', len);
  	    for (i = 0; i < len; i += 1) {
  	      this.v[i] = data.k[i] * this.mult;
  	      this.pv[i] = data.k[i];
  	    }
  	    this._isFirstFrame = true;
  	    this.effectsSequence = [];
  	    this.getValue = processEffectsSequence;
  	    this.setVValue = setVValue;
  	    this.addEffect = addEffect;
  	  }
  	  function KeyframedValueProperty(elem, data, mult, container) {
  	    this.propType = 'unidimensional';
  	    this.keyframes = data.k;
  	    this.keyframesMetadata = [];
  	    this.offsetTime = elem.data.st;
  	    this.frameId = -1;
  	    this._caching = {
  	      lastFrame: initFrame,
  	      lastIndex: 0,
  	      value: 0,
  	      _lastKeyframeIndex: -1
  	    };
  	    this.k = true;
  	    this.kf = true;
  	    this.data = data;
  	    this.mult = mult || 1;
  	    this.elem = elem;
  	    this.container = container;
  	    this.comp = elem.comp;
  	    this.v = initFrame;
  	    this.pv = initFrame;
  	    this._isFirstFrame = true;
  	    this.getValue = processEffectsSequence;
  	    this.setVValue = setVValue;
  	    this.interpolateValue = interpolateValue;
  	    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
  	    this.addEffect = addEffect;
  	  }
  	  function KeyframedMultidimensionalProperty(elem, data, mult, container) {
  	    this.propType = 'multidimensional';
  	    var i;
  	    var len = data.k.length;
  	    var s;
  	    var e;
  	    var to;
  	    var ti;
  	    for (i = 0; i < len - 1; i += 1) {
  	      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
  	        s = data.k[i].s;
  	        e = data.k[i + 1].s;
  	        to = data.k[i].to;
  	        ti = data.k[i].ti;
  	        if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
  	          data.k[i].to = null;
  	          data.k[i].ti = null;
  	        }
  	        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
  	          if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
  	            data.k[i].to = null;
  	            data.k[i].ti = null;
  	          }
  	        }
  	      }
  	    }
  	    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
  	    this.data = data;
  	    this.keyframes = data.k;
  	    this.keyframesMetadata = [];
  	    this.offsetTime = elem.data.st;
  	    this.k = true;
  	    this.kf = true;
  	    this._isFirstFrame = true;
  	    this.mult = mult || 1;
  	    this.elem = elem;
  	    this.container = container;
  	    this.comp = elem.comp;
  	    this.getValue = processEffectsSequence;
  	    this.setVValue = setVValue;
  	    this.interpolateValue = interpolateValue;
  	    this.frameId = -1;
  	    var arrLen = data.k[0].s.length;
  	    this.v = createTypedArray('float32', arrLen);
  	    this.pv = createTypedArray('float32', arrLen);
  	    for (i = 0; i < arrLen; i += 1) {
  	      this.v[i] = initFrame;
  	      this.pv[i] = initFrame;
  	    }
  	    this._caching = {
  	      lastFrame: initFrame,
  	      lastIndex: 0,
  	      value: createTypedArray('float32', arrLen)
  	    };
  	    this.addEffect = addEffect;
  	  }
  	  var PropertyFactory = function () {
  	    function getProp(elem, data, type, mult, container) {
  	      if (data.sid) {
  	        data = elem.globalData.slotManager.getProp(data);
  	      }
  	      var p;
  	      if (!data.k.length) {
  	        p = new ValueProperty(elem, data, mult, container);
  	      } else if (typeof data.k[0] === 'number') {
  	        p = new MultiDimensionalProperty(elem, data, mult, container);
  	      } else {
  	        switch (type) {
  	          case 0:
  	            p = new KeyframedValueProperty(elem, data, mult, container);
  	            break;
  	          case 1:
  	            p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
  	            break;
  	        }
  	      }
  	      if (p.effectsSequence.length) {
  	        container.addDynamicProperty(p);
  	      }
  	      return p;
  	    }
  	    var ob = {
  	      getProp: getProp
  	    };
  	    return ob;
  	  }();

  	  function DynamicPropertyContainer() {}
  	  DynamicPropertyContainer.prototype = {
  	    addDynamicProperty: function addDynamicProperty(prop) {
  	      if (this.dynamicProperties.indexOf(prop) === -1) {
  	        this.dynamicProperties.push(prop);
  	        this.container.addDynamicProperty(this);
  	        this._isAnimated = true;
  	      }
  	    },
  	    iterateDynamicProperties: function iterateDynamicProperties() {
  	      this._mdf = false;
  	      var i;
  	      var len = this.dynamicProperties.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.dynamicProperties[i].getValue();
  	        if (this.dynamicProperties[i]._mdf) {
  	          this._mdf = true;
  	        }
  	      }
  	    },
  	    initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
  	      this.container = container;
  	      this.dynamicProperties = [];
  	      this._mdf = false;
  	      this._isAnimated = false;
  	    }
  	  };

  	  var pointPool = function () {
  	    function create() {
  	      return createTypedArray('float32', 2);
  	    }
  	    return poolFactory(8, create);
  	  }();

  	  function ShapePath() {
  	    this.c = false;
  	    this._length = 0;
  	    this._maxLength = 8;
  	    this.v = createSizedArray(this._maxLength);
  	    this.o = createSizedArray(this._maxLength);
  	    this.i = createSizedArray(this._maxLength);
  	  }
  	  ShapePath.prototype.setPathData = function (closed, len) {
  	    this.c = closed;
  	    this.setLength(len);
  	    var i = 0;
  	    while (i < len) {
  	      this.v[i] = pointPool.newElement();
  	      this.o[i] = pointPool.newElement();
  	      this.i[i] = pointPool.newElement();
  	      i += 1;
  	    }
  	  };
  	  ShapePath.prototype.setLength = function (len) {
  	    while (this._maxLength < len) {
  	      this.doubleArrayLength();
  	    }
  	    this._length = len;
  	  };
  	  ShapePath.prototype.doubleArrayLength = function () {
  	    this.v = this.v.concat(createSizedArray(this._maxLength));
  	    this.i = this.i.concat(createSizedArray(this._maxLength));
  	    this.o = this.o.concat(createSizedArray(this._maxLength));
  	    this._maxLength *= 2;
  	  };
  	  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
  	    var arr;
  	    this._length = Math.max(this._length, pos + 1);
  	    if (this._length >= this._maxLength) {
  	      this.doubleArrayLength();
  	    }
  	    switch (type) {
  	      case 'v':
  	        arr = this.v;
  	        break;
  	      case 'i':
  	        arr = this.i;
  	        break;
  	      case 'o':
  	        arr = this.o;
  	        break;
  	      default:
  	        arr = [];
  	        break;
  	    }
  	    if (!arr[pos] || arr[pos] && !replace) {
  	      arr[pos] = pointPool.newElement();
  	    }
  	    arr[pos][0] = x;
  	    arr[pos][1] = y;
  	  };
  	  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
  	    this.setXYAt(vX, vY, 'v', pos, replace);
  	    this.setXYAt(oX, oY, 'o', pos, replace);
  	    this.setXYAt(iX, iY, 'i', pos, replace);
  	  };
  	  ShapePath.prototype.reverse = function () {
  	    var newPath = new ShapePath();
  	    newPath.setPathData(this.c, this._length);
  	    var vertices = this.v;
  	    var outPoints = this.o;
  	    var inPoints = this.i;
  	    var init = 0;
  	    if (this.c) {
  	      newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
  	      init = 1;
  	    }
  	    var cnt = this._length - 1;
  	    var len = this._length;
  	    var i;
  	    for (i = init; i < len; i += 1) {
  	      newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
  	      cnt -= 1;
  	    }
  	    return newPath;
  	  };
  	  ShapePath.prototype.length = function () {
  	    return this._length;
  	  };

  	  var shapePool = function () {
  	    function create() {
  	      return new ShapePath();
  	    }
  	    function release(shapePath) {
  	      var len = shapePath._length;
  	      var i;
  	      for (i = 0; i < len; i += 1) {
  	        pointPool.release(shapePath.v[i]);
  	        pointPool.release(shapePath.i[i]);
  	        pointPool.release(shapePath.o[i]);
  	        shapePath.v[i] = null;
  	        shapePath.i[i] = null;
  	        shapePath.o[i] = null;
  	      }
  	      shapePath._length = 0;
  	      shapePath.c = false;
  	    }
  	    function clone(shape) {
  	      var cloned = factory.newElement();
  	      var i;
  	      var len = shape._length === undefined ? shape.v.length : shape._length;
  	      cloned.setLength(len);
  	      cloned.c = shape.c;
  	      for (i = 0; i < len; i += 1) {
  	        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
  	      }
  	      return cloned;
  	    }
  	    var factory = poolFactory(4, create, release);
  	    factory.clone = clone;
  	    return factory;
  	  }();

  	  function ShapeCollection() {
  	    this._length = 0;
  	    this._maxLength = 4;
  	    this.shapes = createSizedArray(this._maxLength);
  	  }
  	  ShapeCollection.prototype.addShape = function (shapeData) {
  	    if (this._length === this._maxLength) {
  	      this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
  	      this._maxLength *= 2;
  	    }
  	    this.shapes[this._length] = shapeData;
  	    this._length += 1;
  	  };
  	  ShapeCollection.prototype.releaseShapes = function () {
  	    var i;
  	    for (i = 0; i < this._length; i += 1) {
  	      shapePool.release(this.shapes[i]);
  	    }
  	    this._length = 0;
  	  };

  	  var shapeCollectionPool = function () {
  	    var ob = {
  	      newShapeCollection: newShapeCollection,
  	      release: release
  	    };
  	    var _length = 0;
  	    var _maxLength = 4;
  	    var pool = createSizedArray(_maxLength);
  	    function newShapeCollection() {
  	      var shapeCollection;
  	      if (_length) {
  	        _length -= 1;
  	        shapeCollection = pool[_length];
  	      } else {
  	        shapeCollection = new ShapeCollection();
  	      }
  	      return shapeCollection;
  	    }
  	    function release(shapeCollection) {
  	      var i;
  	      var len = shapeCollection._length;
  	      for (i = 0; i < len; i += 1) {
  	        shapePool.release(shapeCollection.shapes[i]);
  	      }
  	      shapeCollection._length = 0;
  	      if (_length === _maxLength) {
  	        pool = pooling["double"](pool);
  	        _maxLength *= 2;
  	      }
  	      pool[_length] = shapeCollection;
  	      _length += 1;
  	    }
  	    return ob;
  	  }();

  	  var ShapePropertyFactory = function () {
  	    var initFrame = -999999;
  	    function interpolateShape(frameNum, previousValue, caching) {
  	      var iterationIndex = caching.lastIndex;
  	      var keyPropS;
  	      var keyPropE;
  	      var isHold;
  	      var j;
  	      var k;
  	      var jLen;
  	      var kLen;
  	      var perc;
  	      var vertexValue;
  	      var kf = this.keyframes;
  	      if (frameNum < kf[0].t - this.offsetTime) {
  	        keyPropS = kf[0].s[0];
  	        isHold = true;
  	        iterationIndex = 0;
  	      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
  	        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
  	        /* if(kf[kf.length - 1].s){
  	                  keyPropS = kf[kf.length - 1].s[0];
  	              }else{
  	                  keyPropS = kf[kf.length - 2].e[0];
  	              } */
  	        isHold = true;
  	      } else {
  	        var i = iterationIndex;
  	        var len = kf.length - 1;
  	        var flag = true;
  	        var keyData;
  	        var nextKeyData;
  	        var keyframeMetadata;
  	        while (flag) {
  	          keyData = kf[i];
  	          nextKeyData = kf[i + 1];
  	          if (nextKeyData.t - this.offsetTime > frameNum) {
  	            break;
  	          }
  	          if (i < len - 1) {
  	            i += 1;
  	          } else {
  	            flag = false;
  	          }
  	        }
  	        keyframeMetadata = this.keyframesMetadata[i] || {};
  	        isHold = keyData.h === 1;
  	        iterationIndex = i;
  	        if (!isHold) {
  	          if (frameNum >= nextKeyData.t - this.offsetTime) {
  	            perc = 1;
  	          } else if (frameNum < keyData.t - this.offsetTime) {
  	            perc = 0;
  	          } else {
  	            var fnc;
  	            if (keyframeMetadata.__fnct) {
  	              fnc = keyframeMetadata.__fnct;
  	            } else {
  	              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
  	              keyframeMetadata.__fnct = fnc;
  	            }
  	            perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
  	          }
  	          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
  	        }
  	        keyPropS = keyData.s[0];
  	      }
  	      jLen = previousValue._length;
  	      kLen = keyPropS.i[0].length;
  	      caching.lastIndex = iterationIndex;
  	      for (j = 0; j < jLen; j += 1) {
  	        for (k = 0; k < kLen; k += 1) {
  	          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
  	          previousValue.i[j][k] = vertexValue;
  	          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
  	          previousValue.o[j][k] = vertexValue;
  	          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
  	          previousValue.v[j][k] = vertexValue;
  	        }
  	      }
  	    }
  	    function interpolateShapeCurrentTime() {
  	      var frameNum = this.comp.renderedFrame - this.offsetTime;
  	      var initTime = this.keyframes[0].t - this.offsetTime;
  	      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
  	      var lastFrame = this._caching.lastFrame;
  	      if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
  	        /// /
  	        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
  	        this.interpolateShape(frameNum, this.pv, this._caching);
  	        /// /
  	      }
  	      this._caching.lastFrame = frameNum;
  	      return this.pv;
  	    }
  	    function resetShape() {
  	      this.paths = this.localShapeCollection;
  	    }
  	    function shapesEqual(shape1, shape2) {
  	      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
  	        return false;
  	      }
  	      var i;
  	      var len = shape1._length;
  	      for (i = 0; i < len; i += 1) {
  	        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
  	          return false;
  	        }
  	      }
  	      return true;
  	    }
  	    function setVValue(newPath) {
  	      if (!shapesEqual(this.v, newPath)) {
  	        this.v = shapePool.clone(newPath);
  	        this.localShapeCollection.releaseShapes();
  	        this.localShapeCollection.addShape(this.v);
  	        this._mdf = true;
  	        this.paths = this.localShapeCollection;
  	      }
  	    }
  	    function processEffectsSequence() {
  	      if (this.elem.globalData.frameId === this.frameId) {
  	        return;
  	      }
  	      if (!this.effectsSequence.length) {
  	        this._mdf = false;
  	        return;
  	      }
  	      if (this.lock) {
  	        this.setVValue(this.pv);
  	        return;
  	      }
  	      this.lock = true;
  	      this._mdf = false;
  	      var finalValue;
  	      if (this.kf) {
  	        finalValue = this.pv;
  	      } else if (this.data.ks) {
  	        finalValue = this.data.ks.k;
  	      } else {
  	        finalValue = this.data.pt.k;
  	      }
  	      var i;
  	      var len = this.effectsSequence.length;
  	      for (i = 0; i < len; i += 1) {
  	        finalValue = this.effectsSequence[i](finalValue);
  	      }
  	      this.setVValue(finalValue);
  	      this.lock = false;
  	      this.frameId = this.elem.globalData.frameId;
  	    }
  	    function ShapeProperty(elem, data, type) {
  	      this.propType = 'shape';
  	      this.comp = elem.comp;
  	      this.container = elem;
  	      this.elem = elem;
  	      this.data = data;
  	      this.k = false;
  	      this.kf = false;
  	      this._mdf = false;
  	      var pathData = type === 3 ? data.pt.k : data.ks.k;
  	      this.v = shapePool.clone(pathData);
  	      this.pv = shapePool.clone(this.v);
  	      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
  	      this.paths = this.localShapeCollection;
  	      this.paths.addShape(this.v);
  	      this.reset = resetShape;
  	      this.effectsSequence = [];
  	    }
  	    function addEffect(effectFunction) {
  	      this.effectsSequence.push(effectFunction);
  	      this.container.addDynamicProperty(this);
  	    }
  	    ShapeProperty.prototype.interpolateShape = interpolateShape;
  	    ShapeProperty.prototype.getValue = processEffectsSequence;
  	    ShapeProperty.prototype.setVValue = setVValue;
  	    ShapeProperty.prototype.addEffect = addEffect;
  	    function KeyframedShapeProperty(elem, data, type) {
  	      this.propType = 'shape';
  	      this.comp = elem.comp;
  	      this.elem = elem;
  	      this.container = elem;
  	      this.offsetTime = elem.data.st;
  	      this.keyframes = type === 3 ? data.pt.k : data.ks.k;
  	      this.keyframesMetadata = [];
  	      this.k = true;
  	      this.kf = true;
  	      var len = this.keyframes[0].s[0].i.length;
  	      this.v = shapePool.newElement();
  	      this.v.setPathData(this.keyframes[0].s[0].c, len);
  	      this.pv = shapePool.clone(this.v);
  	      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
  	      this.paths = this.localShapeCollection;
  	      this.paths.addShape(this.v);
  	      this.lastFrame = initFrame;
  	      this.reset = resetShape;
  	      this._caching = {
  	        lastFrame: initFrame,
  	        lastIndex: 0
  	      };
  	      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
  	    }
  	    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
  	    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
  	    KeyframedShapeProperty.prototype.setVValue = setVValue;
  	    KeyframedShapeProperty.prototype.addEffect = addEffect;
  	    var EllShapeProperty = function () {
  	      var cPoint = roundCorner;
  	      function EllShapePropertyFactory(elem, data) {
  	        this.v = shapePool.newElement();
  	        this.v.setPathData(true, 4);
  	        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
  	        this.paths = this.localShapeCollection;
  	        this.localShapeCollection.addShape(this.v);
  	        this.d = data.d;
  	        this.elem = elem;
  	        this.comp = elem.comp;
  	        this.frameId = -1;
  	        this.initDynamicPropertyContainer(elem);
  	        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
  	        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
  	        if (this.dynamicProperties.length) {
  	          this.k = true;
  	        } else {
  	          this.k = false;
  	          this.convertEllToPath();
  	        }
  	      }
  	      EllShapePropertyFactory.prototype = {
  	        reset: resetShape,
  	        getValue: function getValue() {
  	          if (this.elem.globalData.frameId === this.frameId) {
  	            return;
  	          }
  	          this.frameId = this.elem.globalData.frameId;
  	          this.iterateDynamicProperties();
  	          if (this._mdf) {
  	            this.convertEllToPath();
  	          }
  	        },
  	        convertEllToPath: function convertEllToPath() {
  	          var p0 = this.p.v[0];
  	          var p1 = this.p.v[1];
  	          var s0 = this.s.v[0] / 2;
  	          var s1 = this.s.v[1] / 2;
  	          var _cw = this.d !== 3;
  	          var _v = this.v;
  	          _v.v[0][0] = p0;
  	          _v.v[0][1] = p1 - s1;
  	          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
  	          _v.v[1][1] = p1;
  	          _v.v[2][0] = p0;
  	          _v.v[2][1] = p1 + s1;
  	          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
  	          _v.v[3][1] = p1;
  	          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
  	          _v.i[0][1] = p1 - s1;
  	          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
  	          _v.i[1][1] = p1 - s1 * cPoint;
  	          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
  	          _v.i[2][1] = p1 + s1;
  	          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
  	          _v.i[3][1] = p1 + s1 * cPoint;
  	          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
  	          _v.o[0][1] = p1 - s1;
  	          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
  	          _v.o[1][1] = p1 + s1 * cPoint;
  	          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
  	          _v.o[2][1] = p1 + s1;
  	          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
  	          _v.o[3][1] = p1 - s1 * cPoint;
  	        }
  	      };
  	      extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
  	      return EllShapePropertyFactory;
  	    }();
  	    var StarShapeProperty = function () {
  	      function StarShapePropertyFactory(elem, data) {
  	        this.v = shapePool.newElement();
  	        this.v.setPathData(true, 0);
  	        this.elem = elem;
  	        this.comp = elem.comp;
  	        this.data = data;
  	        this.frameId = -1;
  	        this.d = data.d;
  	        this.initDynamicPropertyContainer(elem);
  	        if (data.sy === 1) {
  	          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
  	          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
  	          this.convertToPath = this.convertStarToPath;
  	        } else {
  	          this.convertToPath = this.convertPolygonToPath;
  	        }
  	        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
  	        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
  	        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
  	        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
  	        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
  	        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
  	        this.localShapeCollection.addShape(this.v);
  	        this.paths = this.localShapeCollection;
  	        if (this.dynamicProperties.length) {
  	          this.k = true;
  	        } else {
  	          this.k = false;
  	          this.convertToPath();
  	        }
  	      }
  	      StarShapePropertyFactory.prototype = {
  	        reset: resetShape,
  	        getValue: function getValue() {
  	          if (this.elem.globalData.frameId === this.frameId) {
  	            return;
  	          }
  	          this.frameId = this.elem.globalData.frameId;
  	          this.iterateDynamicProperties();
  	          if (this._mdf) {
  	            this.convertToPath();
  	          }
  	        },
  	        convertStarToPath: function convertStarToPath() {
  	          var numPts = Math.floor(this.pt.v) * 2;
  	          var angle = Math.PI * 2 / numPts;
  	          /* this.v.v.length = numPts;
  	                  this.v.i.length = numPts;
  	                  this.v.o.length = numPts; */
  	          var longFlag = true;
  	          var longRad = this.or.v;
  	          var shortRad = this.ir.v;
  	          var longRound = this.os.v;
  	          var shortRound = this.is.v;
  	          var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
  	          var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
  	          var i;
  	          var rad;
  	          var roundness;
  	          var perimSegment;
  	          var currentAng = -Math.PI / 2;
  	          currentAng += this.r.v;
  	          var dir = this.data.d === 3 ? -1 : 1;
  	          this.v._length = 0;
  	          for (i = 0; i < numPts; i += 1) {
  	            rad = longFlag ? longRad : shortRad;
  	            roundness = longFlag ? longRound : shortRound;
  	            perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
  	            var x = rad * Math.cos(currentAng);
  	            var y = rad * Math.sin(currentAng);
  	            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
  	            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
  	            x += +this.p.v[0];
  	            y += +this.p.v[1];
  	            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

  	            /* this.v.v[i] = [x,y];
  	                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
  	                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
  	                      this.v._length = numPts; */
  	            longFlag = !longFlag;
  	            currentAng += angle * dir;
  	          }
  	        },
  	        convertPolygonToPath: function convertPolygonToPath() {
  	          var numPts = Math.floor(this.pt.v);
  	          var angle = Math.PI * 2 / numPts;
  	          var rad = this.or.v;
  	          var roundness = this.os.v;
  	          var perimSegment = 2 * Math.PI * rad / (numPts * 4);
  	          var i;
  	          var currentAng = -Math.PI * 0.5;
  	          var dir = this.data.d === 3 ? -1 : 1;
  	          currentAng += this.r.v;
  	          this.v._length = 0;
  	          for (i = 0; i < numPts; i += 1) {
  	            var x = rad * Math.cos(currentAng);
  	            var y = rad * Math.sin(currentAng);
  	            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
  	            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
  	            x += +this.p.v[0];
  	            y += +this.p.v[1];
  	            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
  	            currentAng += angle * dir;
  	          }
  	          this.paths.length = 0;
  	          this.paths[0] = this.v;
  	        }
  	      };
  	      extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
  	      return StarShapePropertyFactory;
  	    }();
  	    var RectShapeProperty = function () {
  	      function RectShapePropertyFactory(elem, data) {
  	        this.v = shapePool.newElement();
  	        this.v.c = true;
  	        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
  	        this.localShapeCollection.addShape(this.v);
  	        this.paths = this.localShapeCollection;
  	        this.elem = elem;
  	        this.comp = elem.comp;
  	        this.frameId = -1;
  	        this.d = data.d;
  	        this.initDynamicPropertyContainer(elem);
  	        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
  	        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
  	        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
  	        if (this.dynamicProperties.length) {
  	          this.k = true;
  	        } else {
  	          this.k = false;
  	          this.convertRectToPath();
  	        }
  	      }
  	      RectShapePropertyFactory.prototype = {
  	        convertRectToPath: function convertRectToPath() {
  	          var p0 = this.p.v[0];
  	          var p1 = this.p.v[1];
  	          var v0 = this.s.v[0] / 2;
  	          var v1 = this.s.v[1] / 2;
  	          var round = bmMin(v0, v1, this.r.v);
  	          var cPoint = round * (1 - roundCorner);
  	          this.v._length = 0;
  	          if (this.d === 2 || this.d === 1) {
  	            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
  	            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
  	            if (round !== 0) {
  	              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
  	              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
  	              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
  	              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
  	              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
  	              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
  	            } else {
  	              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
  	              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
  	            }
  	          } else {
  	            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
  	            if (round !== 0) {
  	              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
  	              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
  	              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
  	              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
  	              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
  	              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
  	              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
  	            } else {
  	              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
  	              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
  	              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
  	            }
  	          }
  	        },
  	        getValue: function getValue() {
  	          if (this.elem.globalData.frameId === this.frameId) {
  	            return;
  	          }
  	          this.frameId = this.elem.globalData.frameId;
  	          this.iterateDynamicProperties();
  	          if (this._mdf) {
  	            this.convertRectToPath();
  	          }
  	        },
  	        reset: resetShape
  	      };
  	      extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
  	      return RectShapePropertyFactory;
  	    }();
  	    function getShapeProp(elem, data, type) {
  	      var prop;
  	      if (type === 3 || type === 4) {
  	        var dataProp = type === 3 ? data.pt : data.ks;
  	        var keys = dataProp.k;
  	        if (keys.length) {
  	          prop = new KeyframedShapeProperty(elem, data, type);
  	        } else {
  	          prop = new ShapeProperty(elem, data, type);
  	        }
  	      } else if (type === 5) {
  	        prop = new RectShapeProperty(elem, data);
  	      } else if (type === 6) {
  	        prop = new EllShapeProperty(elem, data);
  	      } else if (type === 7) {
  	        prop = new StarShapeProperty(elem, data);
  	      }
  	      if (prop.k) {
  	        elem.addDynamicProperty(prop);
  	      }
  	      return prop;
  	    }
  	    function getConstructorFunction() {
  	      return ShapeProperty;
  	    }
  	    function getKeyframedConstructorFunction() {
  	      return KeyframedShapeProperty;
  	    }
  	    var ob = {};
  	    ob.getShapeProp = getShapeProp;
  	    ob.getConstructorFunction = getConstructorFunction;
  	    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
  	    return ob;
  	  }();

  	  /*!
  	   Transformation Matrix v2.0
  	   (c) Epistemex 2014-2015
  	   www.epistemex.com
  	   By Ken Fyrstenberg
  	   Contributions by leeoniya.
  	   License: MIT, header required.
  	   */

  	  /**
  	   * 2D transformation matrix object initialized with identity matrix.
  	   *
  	   * The matrix can synchronize a canvas context by supplying the context
  	   * as an argument, or later apply current absolute transform to an
  	   * existing context.
  	   *
  	   * All values are handled as floating point values.
  	   *
  	   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
  	   * @prop {number} a - scale x
  	   * @prop {number} b - shear y
  	   * @prop {number} c - shear x
  	   * @prop {number} d - scale y
  	   * @prop {number} e - translate x
  	   * @prop {number} f - translate y
  	   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
  	   * @constructor
  	   */

  	  var Matrix = function () {
  	    var _cos = Math.cos;
  	    var _sin = Math.sin;
  	    var _tan = Math.tan;
  	    var _rnd = Math.round;
  	    function reset() {
  	      this.props[0] = 1;
  	      this.props[1] = 0;
  	      this.props[2] = 0;
  	      this.props[3] = 0;
  	      this.props[4] = 0;
  	      this.props[5] = 1;
  	      this.props[6] = 0;
  	      this.props[7] = 0;
  	      this.props[8] = 0;
  	      this.props[9] = 0;
  	      this.props[10] = 1;
  	      this.props[11] = 0;
  	      this.props[12] = 0;
  	      this.props[13] = 0;
  	      this.props[14] = 0;
  	      this.props[15] = 1;
  	      return this;
  	    }
  	    function rotate(angle) {
  	      if (angle === 0) {
  	        return this;
  	      }
  	      var mCos = _cos(angle);
  	      var mSin = _sin(angle);
  	      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  	    }
  	    function rotateX(angle) {
  	      if (angle === 0) {
  	        return this;
  	      }
  	      var mCos = _cos(angle);
  	      var mSin = _sin(angle);
  	      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
  	    }
  	    function rotateY(angle) {
  	      if (angle === 0) {
  	        return this;
  	      }
  	      var mCos = _cos(angle);
  	      var mSin = _sin(angle);
  	      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
  	    }
  	    function rotateZ(angle) {
  	      if (angle === 0) {
  	        return this;
  	      }
  	      var mCos = _cos(angle);
  	      var mSin = _sin(angle);
  	      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  	    }
  	    function shear(sx, sy) {
  	      return this._t(1, sy, sx, 1, 0, 0);
  	    }
  	    function skew(ax, ay) {
  	      return this.shear(_tan(ax), _tan(ay));
  	    }
  	    function skewFromAxis(ax, angle) {
  	      var mCos = _cos(angle);
  	      var mSin = _sin(angle);
  	      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  	      // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
  	    }
  	    function scale(sx, sy, sz) {
  	      if (!sz && sz !== 0) {
  	        sz = 1;
  	      }
  	      if (sx === 1 && sy === 1 && sz === 1) {
  	        return this;
  	      }
  	      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
  	    }
  	    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
  	      this.props[0] = a;
  	      this.props[1] = b;
  	      this.props[2] = c;
  	      this.props[3] = d;
  	      this.props[4] = e;
  	      this.props[5] = f;
  	      this.props[6] = g;
  	      this.props[7] = h;
  	      this.props[8] = i;
  	      this.props[9] = j;
  	      this.props[10] = k;
  	      this.props[11] = l;
  	      this.props[12] = m;
  	      this.props[13] = n;
  	      this.props[14] = o;
  	      this.props[15] = p;
  	      return this;
  	    }
  	    function translate(tx, ty, tz) {
  	      tz = tz || 0;
  	      if (tx !== 0 || ty !== 0 || tz !== 0) {
  	        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
  	      }
  	      return this;
  	    }
  	    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
  	      var _p = this.props;
  	      if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
  	        // NOTE: commenting this condition because TurboFan deoptimizes code when present
  	        // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
  	        _p[12] = _p[12] * a2 + _p[15] * m2;
  	        _p[13] = _p[13] * f2 + _p[15] * n2;
  	        _p[14] = _p[14] * k2 + _p[15] * o2;
  	        _p[15] *= p2;
  	        // }
  	        this._identityCalculated = false;
  	        return this;
  	      }
  	      var a1 = _p[0];
  	      var b1 = _p[1];
  	      var c1 = _p[2];
  	      var d1 = _p[3];
  	      var e1 = _p[4];
  	      var f1 = _p[5];
  	      var g1 = _p[6];
  	      var h1 = _p[7];
  	      var i1 = _p[8];
  	      var j1 = _p[9];
  	      var k1 = _p[10];
  	      var l1 = _p[11];
  	      var m1 = _p[12];
  	      var n1 = _p[13];
  	      var o1 = _p[14];
  	      var p1 = _p[15];

  	      /* matrix order (canvas compatible):
  	           * ace
  	           * bdf
  	           * 001
  	           */
  	      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
  	      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
  	      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
  	      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
  	      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
  	      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
  	      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
  	      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
  	      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
  	      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
  	      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
  	      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
  	      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
  	      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
  	      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
  	      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
  	      this._identityCalculated = false;
  	      return this;
  	    }
  	    function multiply(matrix) {
  	      var matrixProps = matrix.props;
  	      return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
  	    }
  	    function isIdentity() {
  	      if (!this._identityCalculated) {
  	        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
  	        this._identityCalculated = true;
  	      }
  	      return this._identity;
  	    }
  	    function equals(matr) {
  	      var i = 0;
  	      while (i < 16) {
  	        if (matr.props[i] !== this.props[i]) {
  	          return false;
  	        }
  	        i += 1;
  	      }
  	      return true;
  	    }
  	    function clone(matr) {
  	      var i;
  	      for (i = 0; i < 16; i += 1) {
  	        matr.props[i] = this.props[i];
  	      }
  	      return matr;
  	    }
  	    function cloneFromProps(props) {
  	      var i;
  	      for (i = 0; i < 16; i += 1) {
  	        this.props[i] = props[i];
  	      }
  	    }
  	    function applyToPoint(x, y, z) {
  	      return {
  	        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
  	        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
  	        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
  	      };
  	      /* return {
  	           x: x * me.a + y * me.c + me.e,
  	           y: x * me.b + y * me.d + me.f
  	           }; */
  	    }
  	    function applyToX(x, y, z) {
  	      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
  	    }
  	    function applyToY(x, y, z) {
  	      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
  	    }
  	    function applyToZ(x, y, z) {
  	      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
  	    }
  	    function getInverseMatrix() {
  	      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
  	      var a = this.props[5] / determinant;
  	      var b = -this.props[1] / determinant;
  	      var c = -this.props[4] / determinant;
  	      var d = this.props[0] / determinant;
  	      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
  	      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
  	      var inverseMatrix = new Matrix();
  	      inverseMatrix.props[0] = a;
  	      inverseMatrix.props[1] = b;
  	      inverseMatrix.props[4] = c;
  	      inverseMatrix.props[5] = d;
  	      inverseMatrix.props[12] = e;
  	      inverseMatrix.props[13] = f;
  	      return inverseMatrix;
  	    }
  	    function inversePoint(pt) {
  	      var inverseMatrix = this.getInverseMatrix();
  	      return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
  	    }
  	    function inversePoints(pts) {
  	      var i;
  	      var len = pts.length;
  	      var retPts = [];
  	      for (i = 0; i < len; i += 1) {
  	        retPts[i] = inversePoint(pts[i]);
  	      }
  	      return retPts;
  	    }
  	    function applyToTriplePoints(pt1, pt2, pt3) {
  	      var arr = createTypedArray('float32', 6);
  	      if (this.isIdentity()) {
  	        arr[0] = pt1[0];
  	        arr[1] = pt1[1];
  	        arr[2] = pt2[0];
  	        arr[3] = pt2[1];
  	        arr[4] = pt3[0];
  	        arr[5] = pt3[1];
  	      } else {
  	        var p0 = this.props[0];
  	        var p1 = this.props[1];
  	        var p4 = this.props[4];
  	        var p5 = this.props[5];
  	        var p12 = this.props[12];
  	        var p13 = this.props[13];
  	        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
  	        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
  	        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
  	        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
  	        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
  	        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
  	      }
  	      return arr;
  	    }
  	    function applyToPointArray(x, y, z) {
  	      var arr;
  	      if (this.isIdentity()) {
  	        arr = [x, y, z];
  	      } else {
  	        arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
  	      }
  	      return arr;
  	    }
  	    function applyToPointStringified(x, y) {
  	      if (this.isIdentity()) {
  	        return x + ',' + y;
  	      }
  	      var _p = this.props;
  	      return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
  	    }
  	    function toCSS() {
  	      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
  	      /* if(this.isIdentity()) {
  	              return '';
  	          } */
  	      var i = 0;
  	      var props = this.props;
  	      var cssValue = 'matrix3d(';
  	      var v = 10000;
  	      while (i < 16) {
  	        cssValue += _rnd(props[i] * v) / v;
  	        cssValue += i === 15 ? ')' : ',';
  	        i += 1;
  	      }
  	      return cssValue;
  	    }
  	    function roundMatrixProperty(val) {
  	      var v = 10000;
  	      if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
  	        return _rnd(val * v) / v;
  	      }
  	      return val;
  	    }
  	    function to2dCSS() {
  	      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
  	      /* if(this.isIdentity()) {
  	              return '';
  	          } */
  	      var props = this.props;
  	      var _a = roundMatrixProperty(props[0]);
  	      var _b = roundMatrixProperty(props[1]);
  	      var _c = roundMatrixProperty(props[4]);
  	      var _d = roundMatrixProperty(props[5]);
  	      var _e = roundMatrixProperty(props[12]);
  	      var _f = roundMatrixProperty(props[13]);
  	      return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
  	    }
  	    return function () {
  	      this.reset = reset;
  	      this.rotate = rotate;
  	      this.rotateX = rotateX;
  	      this.rotateY = rotateY;
  	      this.rotateZ = rotateZ;
  	      this.skew = skew;
  	      this.skewFromAxis = skewFromAxis;
  	      this.shear = shear;
  	      this.scale = scale;
  	      this.setTransform = setTransform;
  	      this.translate = translate;
  	      this.transform = transform;
  	      this.multiply = multiply;
  	      this.applyToPoint = applyToPoint;
  	      this.applyToX = applyToX;
  	      this.applyToY = applyToY;
  	      this.applyToZ = applyToZ;
  	      this.applyToPointArray = applyToPointArray;
  	      this.applyToTriplePoints = applyToTriplePoints;
  	      this.applyToPointStringified = applyToPointStringified;
  	      this.toCSS = toCSS;
  	      this.to2dCSS = to2dCSS;
  	      this.clone = clone;
  	      this.cloneFromProps = cloneFromProps;
  	      this.equals = equals;
  	      this.inversePoints = inversePoints;
  	      this.inversePoint = inversePoint;
  	      this.getInverseMatrix = getInverseMatrix;
  	      this._t = this.transform;
  	      this.isIdentity = isIdentity;
  	      this._identity = true;
  	      this._identityCalculated = false;
  	      this.props = createTypedArray('float32', 16);
  	      this.reset();
  	    };
  	  }();

  	  function _typeof$3(o) { "@babel/helpers - typeof"; return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$3(o); }
  	  var lottie = {};
  	  function setLocation(href) {
  	    setLocationHref(href);
  	  }
  	  function searchAnimations() {
  	    {
  	      animationManager.searchAnimations();
  	    }
  	  }
  	  function setSubframeRendering(flag) {
  	    setSubframeEnabled(flag);
  	  }
  	  function setPrefix(prefix) {
  	    setIdPrefix(prefix);
  	  }
  	  function loadAnimation(params) {
  	    return animationManager.loadAnimation(params);
  	  }
  	  function setQuality(value) {
  	    if (typeof value === 'string') {
  	      switch (value) {
  	        case 'high':
  	          setDefaultCurveSegments(200);
  	          break;
  	        default:
  	        case 'medium':
  	          setDefaultCurveSegments(50);
  	          break;
  	        case 'low':
  	          setDefaultCurveSegments(10);
  	          break;
  	      }
  	    } else if (!isNaN(value) && value > 1) {
  	      setDefaultCurveSegments(value);
  	    }
  	  }
  	  function inBrowser() {
  	    return typeof navigator !== 'undefined';
  	  }
  	  function installPlugin(type, plugin) {
  	    if (type === 'expressions') {
  	      setExpressionsPlugin(plugin);
  	    }
  	  }
  	  function getFactory(name) {
  	    switch (name) {
  	      case 'propertyFactory':
  	        return PropertyFactory;
  	      case 'shapePropertyFactory':
  	        return ShapePropertyFactory;
  	      case 'matrix':
  	        return Matrix;
  	      default:
  	        return null;
  	    }
  	  }
  	  lottie.play = animationManager.play;
  	  lottie.pause = animationManager.pause;
  	  lottie.setLocationHref = setLocation;
  	  lottie.togglePause = animationManager.togglePause;
  	  lottie.setSpeed = animationManager.setSpeed;
  	  lottie.setDirection = animationManager.setDirection;
  	  lottie.stop = animationManager.stop;
  	  lottie.searchAnimations = searchAnimations;
  	  lottie.registerAnimation = animationManager.registerAnimation;
  	  lottie.loadAnimation = loadAnimation;
  	  lottie.setSubframeRendering = setSubframeRendering;
  	  lottie.resize = animationManager.resize;
  	  // lottie.start = start;
  	  lottie.goToAndStop = animationManager.goToAndStop;
  	  lottie.destroy = animationManager.destroy;
  	  lottie.setQuality = setQuality;
  	  lottie.inBrowser = inBrowser;
  	  lottie.installPlugin = installPlugin;
  	  lottie.freeze = animationManager.freeze;
  	  lottie.unfreeze = animationManager.unfreeze;
  	  lottie.setVolume = animationManager.setVolume;
  	  lottie.mute = animationManager.mute;
  	  lottie.unmute = animationManager.unmute;
  	  lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
  	  lottie.useWebWorker = setWebWorker;
  	  lottie.setIDPrefix = setPrefix;
  	  lottie.__getFactory = getFactory;
  	  lottie.version = '5.13.0';
  	  function checkReady() {
  	    if (document.readyState === 'complete') {
  	      clearInterval(readyStateCheckInterval);
  	      searchAnimations();
  	    }
  	  }
  	  function getQueryVariable(variable) {
  	    var vars = queryString.split('&');
  	    for (var i = 0; i < vars.length; i += 1) {
  	      var pair = vars[i].split('=');
  	      if (decodeURIComponent(pair[0]) == variable) {
  	        // eslint-disable-line eqeqeq
  	        return decodeURIComponent(pair[1]);
  	      }
  	    }
  	    return null;
  	  }
  	  var queryString = '';
  	  {
  	    var scripts = document.getElementsByTagName('script');
  	    var index = scripts.length - 1;
  	    var myScript = scripts[index] || {
  	      src: ''
  	    };
  	    queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, '') : ''; // eslint-disable-line no-useless-escape
  	    getQueryVariable('renderer');
  	  }
  	  var readyStateCheckInterval = setInterval(checkReady, 100);

  	  // this adds bodymovin to the window object for backwards compatibility
  	  try {
  	    if (!(('object' === "undefined" ? "undefined" : _typeof$3(exports)) === 'object' && 'object' !== 'undefined') && !(typeof undefined === 'function' && undefined.amd) // eslint-disable-line no-undef
  	    ) {
  	      window.bodymovin = lottie;
  	    }
  	  } catch (err) {
  	    //
  	  }

  	  var ShapeModifiers = function () {
  	    var ob = {};
  	    var modifiers = {};
  	    ob.registerModifier = registerModifier;
  	    ob.getModifier = getModifier;
  	    function registerModifier(nm, factory) {
  	      if (!modifiers[nm]) {
  	        modifiers[nm] = factory;
  	      }
  	    }
  	    function getModifier(nm, elem, data) {
  	      return new modifiers[nm](elem, data);
  	    }
  	    return ob;
  	  }();
  	  function ShapeModifier() {}
  	  ShapeModifier.prototype.initModifierProperties = function () {};
  	  ShapeModifier.prototype.addShapeToModifier = function () {};
  	  ShapeModifier.prototype.addShape = function (data) {
  	    if (!this.closed) {
  	      // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
  	      data.sh.container.addDynamicProperty(data.sh);
  	      var shapeData = {
  	        shape: data.sh,
  	        data: data,
  	        localShapeCollection: shapeCollectionPool.newShapeCollection()
  	      };
  	      this.shapes.push(shapeData);
  	      this.addShapeToModifier(shapeData);
  	      if (this._isAnimated) {
  	        data.setAsAnimated();
  	      }
  	    }
  	  };
  	  ShapeModifier.prototype.init = function (elem, data) {
  	    this.shapes = [];
  	    this.elem = elem;
  	    this.initDynamicPropertyContainer(elem);
  	    this.initModifierProperties(elem, data);
  	    this.frameId = initialDefaultFrame;
  	    this.closed = false;
  	    this.k = false;
  	    if (this.dynamicProperties.length) {
  	      this.k = true;
  	    } else {
  	      this.getValue(true);
  	    }
  	  };
  	  ShapeModifier.prototype.processKeys = function () {
  	    if (this.elem.globalData.frameId === this.frameId) {
  	      return;
  	    }
  	    this.frameId = this.elem.globalData.frameId;
  	    this.iterateDynamicProperties();
  	  };
  	  extendPrototype([DynamicPropertyContainer], ShapeModifier);

  	  function TrimModifier() {}
  	  extendPrototype([ShapeModifier], TrimModifier);
  	  TrimModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
  	    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
  	    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
  	    this.sValue = 0;
  	    this.eValue = 0;
  	    this.getValue = this.processKeys;
  	    this.m = data.m;
  	    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
  	  };
  	  TrimModifier.prototype.addShapeToModifier = function (shapeData) {
  	    shapeData.pathsData = [];
  	  };
  	  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
  	    var segments = [];
  	    if (e <= 1) {
  	      segments.push({
  	        s: s,
  	        e: e
  	      });
  	    } else if (s >= 1) {
  	      segments.push({
  	        s: s - 1,
  	        e: e - 1
  	      });
  	    } else {
  	      segments.push({
  	        s: s,
  	        e: 1
  	      });
  	      segments.push({
  	        s: 0,
  	        e: e - 1
  	      });
  	    }
  	    var shapeSegments = [];
  	    var i;
  	    var len = segments.length;
  	    var segmentOb;
  	    for (i = 0; i < len; i += 1) {
  	      segmentOb = segments[i];
  	      if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
  	        var shapeS;
  	        var shapeE;
  	        if (segmentOb.s * totalModifierLength <= addedLength) {
  	          shapeS = 0;
  	        } else {
  	          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
  	        }
  	        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
  	          shapeE = 1;
  	        } else {
  	          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
  	        }
  	        shapeSegments.push([shapeS, shapeE]);
  	      }
  	    }
  	    if (!shapeSegments.length) {
  	      shapeSegments.push([0, 0]);
  	    }
  	    return shapeSegments;
  	  };
  	  TrimModifier.prototype.releasePathsData = function (pathsData) {
  	    var i;
  	    var len = pathsData.length;
  	    for (i = 0; i < len; i += 1) {
  	      segmentsLengthPool.release(pathsData[i]);
  	    }
  	    pathsData.length = 0;
  	    return pathsData;
  	  };
  	  TrimModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var s;
  	    var e;
  	    if (this._mdf || _isFirstFrame) {
  	      var o = this.o.v % 360 / 360;
  	      if (o < 0) {
  	        o += 1;
  	      }
  	      if (this.s.v > 1) {
  	        s = 1 + o;
  	      } else if (this.s.v < 0) {
  	        s = 0 + o;
  	      } else {
  	        s = this.s.v + o;
  	      }
  	      if (this.e.v > 1) {
  	        e = 1 + o;
  	      } else if (this.e.v < 0) {
  	        e = 0 + o;
  	      } else {
  	        e = this.e.v + o;
  	      }
  	      if (s > e) {
  	        var _s = s;
  	        s = e;
  	        e = _s;
  	      }
  	      s = Math.round(s * 10000) * 0.0001;
  	      e = Math.round(e * 10000) * 0.0001;
  	      this.sValue = s;
  	      this.eValue = e;
  	    } else {
  	      s = this.sValue;
  	      e = this.eValue;
  	    }
  	    var shapePaths;
  	    var i;
  	    var len = this.shapes.length;
  	    var j;
  	    var jLen;
  	    var pathsData;
  	    var pathData;
  	    var totalShapeLength;
  	    var totalModifierLength = 0;
  	    if (e === s) {
  	      for (i = 0; i < len; i += 1) {
  	        this.shapes[i].localShapeCollection.releaseShapes();
  	        this.shapes[i].shape._mdf = true;
  	        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
  	        if (this._mdf) {
  	          this.shapes[i].pathsData.length = 0;
  	        }
  	      }
  	    } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
  	      var segments = [];
  	      var shapeData;
  	      var localShapeCollection;
  	      for (i = 0; i < len; i += 1) {
  	        shapeData = this.shapes[i];
  	        // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
  	        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
  	          shapeData.shape.paths = shapeData.localShapeCollection;
  	        } else {
  	          shapePaths = shapeData.shape.paths;
  	          jLen = shapePaths._length;
  	          totalShapeLength = 0;
  	          if (!shapeData.shape._mdf && shapeData.pathsData.length) {
  	            totalShapeLength = shapeData.totalShapeLength;
  	          } else {
  	            pathsData = this.releasePathsData(shapeData.pathsData);
  	            for (j = 0; j < jLen; j += 1) {
  	              pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
  	              pathsData.push(pathData);
  	              totalShapeLength += pathData.totalLength;
  	            }
  	            shapeData.totalShapeLength = totalShapeLength;
  	            shapeData.pathsData = pathsData;
  	          }
  	          totalModifierLength += totalShapeLength;
  	          shapeData.shape._mdf = true;
  	        }
  	      }
  	      var shapeS = s;
  	      var shapeE = e;
  	      var addedLength = 0;
  	      var edges;
  	      for (i = len - 1; i >= 0; i -= 1) {
  	        shapeData = this.shapes[i];
  	        if (shapeData.shape._mdf) {
  	          localShapeCollection = shapeData.localShapeCollection;
  	          localShapeCollection.releaseShapes();
  	          // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
  	          if (this.m === 2 && len > 1) {
  	            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
  	            addedLength += shapeData.totalShapeLength;
  	          } else {
  	            edges = [[shapeS, shapeE]];
  	          }
  	          jLen = edges.length;
  	          for (j = 0; j < jLen; j += 1) {
  	            shapeS = edges[j][0];
  	            shapeE = edges[j][1];
  	            segments.length = 0;
  	            if (shapeE <= 1) {
  	              segments.push({
  	                s: shapeData.totalShapeLength * shapeS,
  	                e: shapeData.totalShapeLength * shapeE
  	              });
  	            } else if (shapeS >= 1) {
  	              segments.push({
  	                s: shapeData.totalShapeLength * (shapeS - 1),
  	                e: shapeData.totalShapeLength * (shapeE - 1)
  	              });
  	            } else {
  	              segments.push({
  	                s: shapeData.totalShapeLength * shapeS,
  	                e: shapeData.totalShapeLength
  	              });
  	              segments.push({
  	                s: 0,
  	                e: shapeData.totalShapeLength * (shapeE - 1)
  	              });
  	            }
  	            var newShapesData = this.addShapes(shapeData, segments[0]);
  	            if (segments[0].s !== segments[0].e) {
  	              if (segments.length > 1) {
  	                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
  	                if (lastShapeInCollection.c) {
  	                  var lastShape = newShapesData.pop();
  	                  this.addPaths(newShapesData, localShapeCollection);
  	                  newShapesData = this.addShapes(shapeData, segments[1], lastShape);
  	                } else {
  	                  this.addPaths(newShapesData, localShapeCollection);
  	                  newShapesData = this.addShapes(shapeData, segments[1]);
  	                }
  	              }
  	              this.addPaths(newShapesData, localShapeCollection);
  	            }
  	          }
  	          shapeData.shape.paths = localShapeCollection;
  	        }
  	      }
  	    } else if (this._mdf) {
  	      for (i = 0; i < len; i += 1) {
  	        // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
  	        // Don't remove this even if it's losing cached info.
  	        this.shapes[i].pathsData.length = 0;
  	        this.shapes[i].shape._mdf = true;
  	      }
  	    }
  	  };
  	  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
  	    var i;
  	    var len = newPaths.length;
  	    for (i = 0; i < len; i += 1) {
  	      localShapeCollection.addShape(newPaths[i]);
  	    }
  	  };
  	  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
  	    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
  	    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
  	    if (newShape) {
  	      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
  	    }
  	    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
  	  };
  	  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
  	    shapePath.setXYAt(points[1], points[5], 'o', pos);
  	    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
  	    if (newShape) {
  	      shapePath.setXYAt(points[0], points[4], 'v', pos);
  	    }
  	    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
  	  };
  	  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
  	    var pathsData = shapeData.pathsData;
  	    var shapePaths = shapeData.shape.paths.shapes;
  	    var i;
  	    var len = shapeData.shape.paths._length;
  	    var j;
  	    var jLen;
  	    var addedLength = 0;
  	    var currentLengthData;
  	    var segmentCount;
  	    var lengths;
  	    var segment;
  	    var shapes = [];
  	    var initPos;
  	    var newShape = true;
  	    if (!shapePath) {
  	      shapePath = shapePool.newElement();
  	      segmentCount = 0;
  	      initPos = 0;
  	    } else {
  	      segmentCount = shapePath._length;
  	      initPos = shapePath._length;
  	    }
  	    shapes.push(shapePath);
  	    for (i = 0; i < len; i += 1) {
  	      lengths = pathsData[i].lengths;
  	      shapePath.c = shapePaths[i].c;
  	      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
  	      for (j = 1; j < jLen; j += 1) {
  	        currentLengthData = lengths[j - 1];
  	        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
  	          addedLength += currentLengthData.addedLength;
  	          shapePath.c = false;
  	        } else if (addedLength > shapeSegment.e) {
  	          shapePath.c = false;
  	          break;
  	        } else {
  	          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
  	            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
  	            newShape = false;
  	          } else {
  	            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
  	            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
  	            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
  	            newShape = false;
  	            shapePath.c = false;
  	          }
  	          addedLength += currentLengthData.addedLength;
  	          segmentCount += 1;
  	        }
  	      }
  	      if (shapePaths[i].c && lengths.length) {
  	        currentLengthData = lengths[j - 1];
  	        if (addedLength <= shapeSegment.e) {
  	          var segmentLength = lengths[j - 1].addedLength;
  	          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
  	            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
  	            newShape = false;
  	          } else {
  	            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
  	            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
  	            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
  	            newShape = false;
  	            shapePath.c = false;
  	          }
  	        } else {
  	          shapePath.c = false;
  	        }
  	        addedLength += currentLengthData.addedLength;
  	        segmentCount += 1;
  	      }
  	      if (shapePath._length) {
  	        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
  	        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
  	      }
  	      if (addedLength > shapeSegment.e) {
  	        break;
  	      }
  	      if (i < len - 1) {
  	        shapePath = shapePool.newElement();
  	        newShape = true;
  	        shapes.push(shapePath);
  	        segmentCount = 0;
  	      }
  	    }
  	    return shapes;
  	  };

  	  function PuckerAndBloatModifier() {}
  	  extendPrototype([ShapeModifier], PuckerAndBloatModifier);
  	  PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.getValue = this.processKeys;
  	    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
  	    this._isAnimated = !!this.amount.effectsSequence.length;
  	  };
  	  PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
  	    var percent = amount / 100;
  	    var centerPoint = [0, 0];
  	    var pathLength = path._length;
  	    var i = 0;
  	    for (i = 0; i < pathLength; i += 1) {
  	      centerPoint[0] += path.v[i][0];
  	      centerPoint[1] += path.v[i][1];
  	    }
  	    centerPoint[0] /= pathLength;
  	    centerPoint[1] /= pathLength;
  	    var clonedPath = shapePool.newElement();
  	    clonedPath.c = path.c;
  	    var vX;
  	    var vY;
  	    var oX;
  	    var oY;
  	    var iX;
  	    var iY;
  	    for (i = 0; i < pathLength; i += 1) {
  	      vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
  	      vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
  	      oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
  	      oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
  	      iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
  	      iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
  	      clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
  	    }
  	    return clonedPath;
  	  };
  	  PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var shapePaths;
  	    var i;
  	    var len = this.shapes.length;
  	    var j;
  	    var jLen;
  	    var amount = this.amount.v;
  	    if (amount !== 0) {
  	      var shapeData;
  	      var localShapeCollection;
  	      for (i = 0; i < len; i += 1) {
  	        shapeData = this.shapes[i];
  	        localShapeCollection = shapeData.localShapeCollection;
  	        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
  	          localShapeCollection.releaseShapes();
  	          shapeData.shape._mdf = true;
  	          shapePaths = shapeData.shape.paths.shapes;
  	          jLen = shapeData.shape.paths._length;
  	          for (j = 0; j < jLen; j += 1) {
  	            localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
  	          }
  	        }
  	        shapeData.shape.paths = shapeData.localShapeCollection;
  	      }
  	    }
  	    if (!this.dynamicProperties.length) {
  	      this._mdf = false;
  	    }
  	  };

  	  var TransformPropertyFactory = function () {
  	    var defaultVector = [0, 0];
  	    function applyToMatrix(mat) {
  	      var _mdf = this._mdf;
  	      this.iterateDynamicProperties();
  	      this._mdf = this._mdf || _mdf;
  	      if (this.a) {
  	        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
  	      }
  	      if (this.s) {
  	        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
  	      }
  	      if (this.sk) {
  	        mat.skewFromAxis(-this.sk.v, this.sa.v);
  	      }
  	      if (this.r) {
  	        mat.rotate(-this.r.v);
  	      } else {
  	        mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
  	      }
  	      if (this.data.p.s) {
  	        if (this.data.p.z) {
  	          mat.translate(this.px.v, this.py.v, -this.pz.v);
  	        } else {
  	          mat.translate(this.px.v, this.py.v, 0);
  	        }
  	      } else {
  	        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
  	      }
  	    }
  	    function processKeys(forceRender) {
  	      if (this.elem.globalData.frameId === this.frameId) {
  	        return;
  	      }
  	      if (this._isDirty) {
  	        this.precalculateMatrix();
  	        this._isDirty = false;
  	      }
  	      this.iterateDynamicProperties();
  	      if (this._mdf || forceRender) {
  	        var frameRate;
  	        this.v.cloneFromProps(this.pre.props);
  	        if (this.appliedTransformations < 1) {
  	          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
  	        }
  	        if (this.appliedTransformations < 2) {
  	          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
  	        }
  	        if (this.sk && this.appliedTransformations < 3) {
  	          this.v.skewFromAxis(-this.sk.v, this.sa.v);
  	        }
  	        if (this.r && this.appliedTransformations < 4) {
  	          this.v.rotate(-this.r.v);
  	        } else if (!this.r && this.appliedTransformations < 4) {
  	          this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
  	        }
  	        if (this.autoOriented) {
  	          var v1;
  	          var v2;
  	          frameRate = this.elem.globalData.frameRate;
  	          if (this.p && this.p.keyframes && this.p.getValueAtTime) {
  	            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
  	              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
  	              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
  	            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
  	              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
  	              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
  	            } else {
  	              v1 = this.p.pv;
  	              v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
  	            }
  	          } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
  	            v1 = [];
  	            v2 = [];
  	            var px = this.px;
  	            var py = this.py;
  	            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
  	              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
  	              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
  	              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
  	              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
  	            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
  	              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
  	              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
  	              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
  	              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
  	            } else {
  	              v1 = [px.pv, py.pv];
  	              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
  	              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
  	            }
  	          } else {
  	            v2 = defaultVector;
  	            v1 = v2;
  	          }
  	          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
  	        }
  	        if (this.data.p && this.data.p.s) {
  	          if (this.data.p.z) {
  	            this.v.translate(this.px.v, this.py.v, -this.pz.v);
  	          } else {
  	            this.v.translate(this.px.v, this.py.v, 0);
  	          }
  	        } else {
  	          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
  	        }
  	      }
  	      this.frameId = this.elem.globalData.frameId;
  	    }
  	    function precalculateMatrix() {
  	      this.appliedTransformations = 0;
  	      this.pre.reset();
  	      if (!this.a.effectsSequence.length) {
  	        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
  	        this.appliedTransformations = 1;
  	      } else {
  	        return;
  	      }
  	      if (!this.s.effectsSequence.length) {
  	        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
  	        this.appliedTransformations = 2;
  	      } else {
  	        return;
  	      }
  	      if (this.sk) {
  	        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
  	          this.pre.skewFromAxis(-this.sk.v, this.sa.v);
  	          this.appliedTransformations = 3;
  	        } else {
  	          return;
  	        }
  	      }
  	      if (this.r) {
  	        if (!this.r.effectsSequence.length) {
  	          this.pre.rotate(-this.r.v);
  	          this.appliedTransformations = 4;
  	        }
  	      } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
  	        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
  	        this.appliedTransformations = 4;
  	      }
  	    }
  	    function autoOrient() {
  	      //
  	      // var prevP = this.getValueAtTime();
  	    }
  	    function addDynamicProperty(prop) {
  	      this._addDynamicProperty(prop);
  	      this.elem.addDynamicProperty(prop);
  	      this._isDirty = true;
  	    }
  	    function TransformProperty(elem, data, container) {
  	      this.elem = elem;
  	      this.frameId = -1;
  	      this.propType = 'transform';
  	      this.data = data;
  	      this.v = new Matrix();
  	      // Precalculated matrix with non animated properties
  	      this.pre = new Matrix();
  	      this.appliedTransformations = 0;
  	      this.initDynamicPropertyContainer(container || elem);
  	      if (data.p && data.p.s) {
  	        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
  	        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
  	        if (data.p.z) {
  	          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
  	        }
  	      } else {
  	        this.p = PropertyFactory.getProp(elem, data.p || {
  	          k: [0, 0, 0]
  	        }, 1, 0, this);
  	      }
  	      if (data.rx) {
  	        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
  	        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
  	        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
  	        if (data.or.k[0].ti) {
  	          var i;
  	          var len = data.or.k.length;
  	          for (i = 0; i < len; i += 1) {
  	            data.or.k[i].to = null;
  	            data.or.k[i].ti = null;
  	          }
  	        }
  	        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
  	        // sh Indicates it needs to be capped between -180 and 180
  	        this.or.sh = true;
  	      } else {
  	        this.r = PropertyFactory.getProp(elem, data.r || {
  	          k: 0
  	        }, 0, degToRads, this);
  	      }
  	      if (data.sk) {
  	        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
  	        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
  	      }
  	      this.a = PropertyFactory.getProp(elem, data.a || {
  	        k: [0, 0, 0]
  	      }, 1, 0, this);
  	      this.s = PropertyFactory.getProp(elem, data.s || {
  	        k: [100, 100, 100]
  	      }, 1, 0.01, this);
  	      // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
  	      if (data.o) {
  	        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
  	      } else {
  	        this.o = {
  	          _mdf: false,
  	          v: 1
  	        };
  	      }
  	      this._isDirty = true;
  	      if (!this.dynamicProperties.length) {
  	        this.getValue(true);
  	      }
  	    }
  	    TransformProperty.prototype = {
  	      applyToMatrix: applyToMatrix,
  	      getValue: processKeys,
  	      precalculateMatrix: precalculateMatrix,
  	      autoOrient: autoOrient
  	    };
  	    extendPrototype([DynamicPropertyContainer], TransformProperty);
  	    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
  	    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
  	    function getTransformProperty(elem, data, container) {
  	      return new TransformProperty(elem, data, container);
  	    }
  	    return {
  	      getTransformProperty: getTransformProperty
  	    };
  	  }();

  	  function RepeaterModifier() {}
  	  extendPrototype([ShapeModifier], RepeaterModifier);
  	  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.getValue = this.processKeys;
  	    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
  	    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
  	    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
  	    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
  	    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
  	    this.data = data;
  	    if (!this.dynamicProperties.length) {
  	      this.getValue(true);
  	    }
  	    this._isAnimated = !!this.dynamicProperties.length;
  	    this.pMatrix = new Matrix();
  	    this.rMatrix = new Matrix();
  	    this.sMatrix = new Matrix();
  	    this.tMatrix = new Matrix();
  	    this.matrix = new Matrix();
  	  };
  	  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
  	    var dir = inv ? -1 : 1;
  	    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
  	    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
  	    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
  	    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  	    rMatrix.rotate(-transform.r.v * dir * perc);
  	    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
  	    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  	    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
  	    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
  	  };
  	  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
  	    this.elem = elem;
  	    this.arr = arr;
  	    this.pos = pos;
  	    this.elemsData = elemsData;
  	    this._currentCopies = 0;
  	    this._elements = [];
  	    this._groups = [];
  	    this.frameId = -1;
  	    this.initDynamicPropertyContainer(elem);
  	    this.initModifierProperties(elem, arr[pos]);
  	    while (pos > 0) {
  	      pos -= 1;
  	      // this._elements.unshift(arr.splice(pos,1)[0]);
  	      this._elements.unshift(arr[pos]);
  	    }
  	    if (this.dynamicProperties.length) {
  	      this.k = true;
  	    } else {
  	      this.getValue(true);
  	    }
  	  };
  	  RepeaterModifier.prototype.resetElements = function (elements) {
  	    var i;
  	    var len = elements.length;
  	    for (i = 0; i < len; i += 1) {
  	      elements[i]._processed = false;
  	      if (elements[i].ty === 'gr') {
  	        this.resetElements(elements[i].it);
  	      }
  	    }
  	  };
  	  RepeaterModifier.prototype.cloneElements = function (elements) {
  	    var newElements = JSON.parse(JSON.stringify(elements));
  	    this.resetElements(newElements);
  	    return newElements;
  	  };
  	  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
  	    var i;
  	    var len = elements.length;
  	    for (i = 0; i < len; i += 1) {
  	      elements[i]._render = renderFlag;
  	      if (elements[i].ty === 'gr') {
  	        this.changeGroupRender(elements[i].it, renderFlag);
  	      }
  	    }
  	  };
  	  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var items;
  	    var itemsTransform;
  	    var i;
  	    var dir;
  	    var cont;
  	    var hasReloaded = false;
  	    if (this._mdf || _isFirstFrame) {
  	      var copies = Math.ceil(this.c.v);
  	      if (this._groups.length < copies) {
  	        while (this._groups.length < copies) {
  	          var group = {
  	            it: this.cloneElements(this._elements),
  	            ty: 'gr'
  	          };
  	          group.it.push({
  	            a: {
  	              a: 0,
  	              ix: 1,
  	              k: [0, 0]
  	            },
  	            nm: 'Transform',
  	            o: {
  	              a: 0,
  	              ix: 7,
  	              k: 100
  	            },
  	            p: {
  	              a: 0,
  	              ix: 2,
  	              k: [0, 0]
  	            },
  	            r: {
  	              a: 1,
  	              ix: 6,
  	              k: [{
  	                s: 0,
  	                e: 0,
  	                t: 0
  	              }, {
  	                s: 0,
  	                e: 0,
  	                t: 1
  	              }]
  	            },
  	            s: {
  	              a: 0,
  	              ix: 3,
  	              k: [100, 100]
  	            },
  	            sa: {
  	              a: 0,
  	              ix: 5,
  	              k: 0
  	            },
  	            sk: {
  	              a: 0,
  	              ix: 4,
  	              k: 0
  	            },
  	            ty: 'tr'
  	          });
  	          this.arr.splice(0, 0, group);
  	          this._groups.splice(0, 0, group);
  	          this._currentCopies += 1;
  	        }
  	        this.elem.reloadShapes();
  	        hasReloaded = true;
  	      }
  	      cont = 0;
  	      var renderFlag;
  	      for (i = 0; i <= this._groups.length - 1; i += 1) {
  	        renderFlag = cont < copies;
  	        this._groups[i]._render = renderFlag;
  	        this.changeGroupRender(this._groups[i].it, renderFlag);
  	        if (!renderFlag) {
  	          var elems = this.elemsData[i].it;
  	          var transformData = elems[elems.length - 1];
  	          if (transformData.transform.op.v !== 0) {
  	            transformData.transform.op._mdf = true;
  	            transformData.transform.op.v = 0;
  	          } else {
  	            transformData.transform.op._mdf = false;
  	          }
  	        }
  	        cont += 1;
  	      }
  	      this._currentCopies = copies;
  	      /// /

  	      var offset = this.o.v;
  	      var offsetModulo = offset % 1;
  	      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
  	      var pProps = this.pMatrix.props;
  	      var rProps = this.rMatrix.props;
  	      var sProps = this.sMatrix.props;
  	      this.pMatrix.reset();
  	      this.rMatrix.reset();
  	      this.sMatrix.reset();
  	      this.tMatrix.reset();
  	      this.matrix.reset();
  	      var iteration = 0;
  	      if (offset > 0) {
  	        while (iteration < roundOffset) {
  	          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
  	          iteration += 1;
  	        }
  	        if (offsetModulo) {
  	          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
  	          iteration += offsetModulo;
  	        }
  	      } else if (offset < 0) {
  	        while (iteration > roundOffset) {
  	          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
  	          iteration -= 1;
  	        }
  	        if (offsetModulo) {
  	          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
  	          iteration -= offsetModulo;
  	        }
  	      }
  	      i = this.data.m === 1 ? 0 : this._currentCopies - 1;
  	      dir = this.data.m === 1 ? 1 : -1;
  	      cont = this._currentCopies;
  	      var j;
  	      var jLen;
  	      while (cont) {
  	        items = this.elemsData[i].it;
  	        itemsTransform = items[items.length - 1].transform.mProps.v.props;
  	        jLen = itemsTransform.length;
  	        items[items.length - 1].transform.mProps._mdf = true;
  	        items[items.length - 1].transform.op._mdf = true;
  	        items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
  	        if (iteration !== 0) {
  	          if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
  	            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
  	          }
  	          this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
  	          this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
  	          this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
  	          for (j = 0; j < jLen; j += 1) {
  	            itemsTransform[j] = this.matrix.props[j];
  	          }
  	          this.matrix.reset();
  	        } else {
  	          this.matrix.reset();
  	          for (j = 0; j < jLen; j += 1) {
  	            itemsTransform[j] = this.matrix.props[j];
  	          }
  	        }
  	        iteration += 1;
  	        cont -= 1;
  	        i += dir;
  	      }
  	    } else {
  	      cont = this._currentCopies;
  	      i = 0;
  	      dir = 1;
  	      while (cont) {
  	        items = this.elemsData[i].it;
  	        itemsTransform = items[items.length - 1].transform.mProps.v.props;
  	        items[items.length - 1].transform.mProps._mdf = false;
  	        items[items.length - 1].transform.op._mdf = false;
  	        cont -= 1;
  	        i += dir;
  	      }
  	    }
  	    return hasReloaded;
  	  };
  	  RepeaterModifier.prototype.addShape = function () {};

  	  function RoundCornersModifier() {}
  	  extendPrototype([ShapeModifier], RoundCornersModifier);
  	  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.getValue = this.processKeys;
  	    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
  	    this._isAnimated = !!this.rd.effectsSequence.length;
  	  };
  	  RoundCornersModifier.prototype.processPath = function (path, round) {
  	    var clonedPath = shapePool.newElement();
  	    clonedPath.c = path.c;
  	    var i;
  	    var len = path._length;
  	    var currentV;
  	    var currentI;
  	    var currentO;
  	    var closerV;
  	    var distance;
  	    var newPosPerc;
  	    var index = 0;
  	    var vX;
  	    var vY;
  	    var oX;
  	    var oY;
  	    var iX;
  	    var iY;
  	    for (i = 0; i < len; i += 1) {
  	      currentV = path.v[i];
  	      currentO = path.o[i];
  	      currentI = path.i[i];
  	      if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
  	        if ((i === 0 || i === len - 1) && !path.c) {
  	          clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
  	          /* clonedPath.v[index] = currentV;
  	                  clonedPath.o[index] = currentO;
  	                  clonedPath.i[index] = currentI; */
  	          index += 1;
  	        } else {
  	          if (i === 0) {
  	            closerV = path.v[len - 1];
  	          } else {
  	            closerV = path.v[i - 1];
  	          }
  	          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
  	          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
  	          iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
  	          vX = iX;
  	          iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
  	          vY = iY;
  	          oX = vX - (vX - currentV[0]) * roundCorner;
  	          oY = vY - (vY - currentV[1]) * roundCorner;
  	          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
  	          index += 1;
  	          if (i === len - 1) {
  	            closerV = path.v[0];
  	          } else {
  	            closerV = path.v[i + 1];
  	          }
  	          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
  	          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
  	          oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
  	          vX = oX;
  	          oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
  	          vY = oY;
  	          iX = vX - (vX - currentV[0]) * roundCorner;
  	          iY = vY - (vY - currentV[1]) * roundCorner;
  	          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
  	          index += 1;
  	        }
  	      } else {
  	        clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
  	        index += 1;
  	      }
  	    }
  	    return clonedPath;
  	  };
  	  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var shapePaths;
  	    var i;
  	    var len = this.shapes.length;
  	    var j;
  	    var jLen;
  	    var rd = this.rd.v;
  	    if (rd !== 0) {
  	      var shapeData;
  	      var localShapeCollection;
  	      for (i = 0; i < len; i += 1) {
  	        shapeData = this.shapes[i];
  	        localShapeCollection = shapeData.localShapeCollection;
  	        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
  	          localShapeCollection.releaseShapes();
  	          shapeData.shape._mdf = true;
  	          shapePaths = shapeData.shape.paths.shapes;
  	          jLen = shapeData.shape.paths._length;
  	          for (j = 0; j < jLen; j += 1) {
  	            localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
  	          }
  	        }
  	        shapeData.shape.paths = shapeData.localShapeCollection;
  	      }
  	    }
  	    if (!this.dynamicProperties.length) {
  	      this._mdf = false;
  	    }
  	  };

  	  function floatEqual(a, b) {
  	    return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));
  	  }
  	  function floatZero(f) {
  	    return Math.abs(f) <= 0.00001;
  	  }
  	  function lerp(p0, p1, amount) {
  	    return p0 * (1 - amount) + p1 * amount;
  	  }
  	  function lerpPoint(p0, p1, amount) {
  	    return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
  	  }
  	  function quadRoots(a, b, c) {
  	    // no root
  	    if (a === 0) return [];
  	    var s = b * b - 4 * a * c;
  	    // Complex roots
  	    if (s < 0) return [];
  	    var singleRoot = -b / (2 * a);
  	    // 1 root
  	    if (s === 0) return [singleRoot];
  	    var delta = Math.sqrt(s) / (2 * a);
  	    // 2 roots
  	    return [singleRoot - delta, singleRoot + delta];
  	  }
  	  function polynomialCoefficients(p0, p1, p2, p3) {
  	    return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
  	  }
  	  function singlePoint(p) {
  	    return new PolynomialBezier(p, p, p, p, false);
  	  }
  	  function PolynomialBezier(p0, p1, p2, p3, linearize) {
  	    if (linearize && pointEqual(p0, p1)) {
  	      p1 = lerpPoint(p0, p3, 1 / 3);
  	    }
  	    if (linearize && pointEqual(p2, p3)) {
  	      p2 = lerpPoint(p0, p3, 2 / 3);
  	    }
  	    var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
  	    var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
  	    this.a = [coeffx[0], coeffy[0]];
  	    this.b = [coeffx[1], coeffy[1]];
  	    this.c = [coeffx[2], coeffy[2]];
  	    this.d = [coeffx[3], coeffy[3]];
  	    this.points = [p0, p1, p2, p3];
  	  }
  	  PolynomialBezier.prototype.point = function (t) {
  	    return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
  	  };
  	  PolynomialBezier.prototype.derivative = function (t) {
  	    return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
  	  };
  	  PolynomialBezier.prototype.tangentAngle = function (t) {
  	    var p = this.derivative(t);
  	    return Math.atan2(p[1], p[0]);
  	  };
  	  PolynomialBezier.prototype.normalAngle = function (t) {
  	    var p = this.derivative(t);
  	    return Math.atan2(p[0], p[1]);
  	  };
  	  PolynomialBezier.prototype.inflectionPoints = function () {
  	    var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
  	    if (floatZero(denom)) return [];
  	    var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
  	    var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
  	    if (square < 0) return [];
  	    var root = Math.sqrt(square);
  	    if (floatZero(root)) {
  	      if (root > 0 && root < 1) return [tcusp];
  	      return [];
  	    }
  	    return [tcusp - root, tcusp + root].filter(function (r) {
  	      return r > 0 && r < 1;
  	    });
  	  };
  	  PolynomialBezier.prototype.split = function (t) {
  	    if (t <= 0) return [singlePoint(this.points[0]), this];
  	    if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
  	    var p10 = lerpPoint(this.points[0], this.points[1], t);
  	    var p11 = lerpPoint(this.points[1], this.points[2], t);
  	    var p12 = lerpPoint(this.points[2], this.points[3], t);
  	    var p20 = lerpPoint(p10, p11, t);
  	    var p21 = lerpPoint(p11, p12, t);
  	    var p3 = lerpPoint(p20, p21, t);
  	    return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
  	  };
  	  function extrema(bez, comp) {
  	    var min = bez.points[0][comp];
  	    var max = bez.points[bez.points.length - 1][comp];
  	    if (min > max) {
  	      var e = max;
  	      max = min;
  	      min = e;
  	    }
  	    // Derivative roots to find min/max
  	    var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);
  	    for (var i = 0; i < f.length; i += 1) {
  	      if (f[i] > 0 && f[i] < 1) {
  	        var val = bez.point(f[i])[comp];
  	        if (val < min) min = val;else if (val > max) max = val;
  	      }
  	    }
  	    return {
  	      min: min,
  	      max: max
  	    };
  	  }
  	  PolynomialBezier.prototype.bounds = function () {
  	    return {
  	      x: extrema(this, 0),
  	      y: extrema(this, 1)
  	    };
  	  };
  	  PolynomialBezier.prototype.boundingBox = function () {
  	    var bounds = this.bounds();
  	    return {
  	      left: bounds.x.min,
  	      right: bounds.x.max,
  	      top: bounds.y.min,
  	      bottom: bounds.y.max,
  	      width: bounds.x.max - bounds.x.min,
  	      height: bounds.y.max - bounds.y.min,
  	      cx: (bounds.x.max + bounds.x.min) / 2,
  	      cy: (bounds.y.max + bounds.y.min) / 2
  	    };
  	  };
  	  function intersectData(bez, t1, t2) {
  	    var box = bez.boundingBox();
  	    return {
  	      cx: box.cx,
  	      cy: box.cy,
  	      width: box.width,
  	      height: box.height,
  	      bez: bez,
  	      t: (t1 + t2) / 2,
  	      t1: t1,
  	      t2: t2
  	    };
  	  }
  	  function splitData(data) {
  	    var split = data.bez.split(0.5);
  	    return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];
  	  }
  	  function boxIntersect(b1, b2) {
  	    return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
  	  }
  	  function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
  	    if (!boxIntersect(d1, d2)) return;
  	    if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
  	      intersections.push([d1.t, d2.t]);
  	      return;
  	    }
  	    var d1s = splitData(d1);
  	    var d2s = splitData(d2);
  	    intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
  	    intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
  	    intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
  	    intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
  	  }
  	  PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {
  	    if (tolerance === undefined) tolerance = 2;
  	    if (maxRecursion === undefined) maxRecursion = 7;
  	    var intersections = [];
  	    intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
  	    return intersections;
  	  };
  	  PolynomialBezier.shapeSegment = function (shapePath, index) {
  	    var nextIndex = (index + 1) % shapePath.length();
  	    return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
  	  };
  	  PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {
  	    var nextIndex = (index + 1) % shapePath.length();
  	    return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);
  	  };
  	  function crossProduct(a, b) {
  	    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  	  }
  	  function lineIntersection(start1, end1, start2, end2) {
  	    var v1 = [start1[0], start1[1], 1];
  	    var v2 = [end1[0], end1[1], 1];
  	    var v3 = [start2[0], start2[1], 1];
  	    var v4 = [end2[0], end2[1], 1];
  	    var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
  	    if (floatZero(r[2])) return null;
  	    return [r[0] / r[2], r[1] / r[2]];
  	  }
  	  function polarOffset(p, angle, length) {
  	    return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];
  	  }
  	  function pointDistance(p1, p2) {
  	    return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
  	  }
  	  function pointEqual(p1, p2) {
  	    return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
  	  }

  	  function ZigZagModifier() {}
  	  extendPrototype([ShapeModifier], ZigZagModifier);
  	  ZigZagModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.getValue = this.processKeys;
  	    this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);
  	    this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);
  	    this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);
  	    this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
  	  };
  	  function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
  	    var angO = angle - Math.PI / 2;
  	    var angI = angle + Math.PI / 2;
  	    var px = point[0] + Math.cos(angle) * direction * amplitude;
  	    var py = point[1] - Math.sin(angle) * direction * amplitude;
  	    outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
  	  }
  	  function getPerpendicularVector(pt1, pt2) {
  	    var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
  	    var rot = -Math.PI * 0.5;
  	    var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
  	    return rotatedVector;
  	  }
  	  function getProjectingAngle(path, cur) {
  	    var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
  	    var nextIndex = (cur + 1) % path.length();
  	    var prevPoint = path.v[prevIndex];
  	    var nextPoint = path.v[nextIndex];
  	    var pVector = getPerpendicularVector(prevPoint, nextPoint);
  	    return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
  	  }
  	  function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
  	    var angle = getProjectingAngle(path, cur);
  	    var point = path.v[cur % path._length];
  	    var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
  	    var nextPoint = path.v[(cur + 1) % path._length];
  	    var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
  	    var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
  	    setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
  	  }
  	  function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
  	    for (var i = 0; i < frequency; i += 1) {
  	      var t = (i + 1) / (frequency + 1);
  	      var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
  	      var angle = segment.normalAngle(t);
  	      var point = segment.point(t);
  	      setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
  	      direction = -direction;
  	    }
  	    return direction;
  	  }
  	  ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {
  	    var count = path._length;
  	    var clonedPath = shapePool.newElement();
  	    clonedPath.c = path.c;
  	    if (!path.c) {
  	      count -= 1;
  	    }
  	    if (count === 0) return clonedPath;
  	    var direction = -1;
  	    var segment = PolynomialBezier.shapeSegment(path, 0);
  	    zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
  	    for (var i = 0; i < count; i += 1) {
  	      direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
  	      if (i === count - 1 && !path.c) {
  	        segment = null;
  	      } else {
  	        segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
  	      }
  	      zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
  	    }
  	    return clonedPath;
  	  };
  	  ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var shapePaths;
  	    var i;
  	    var len = this.shapes.length;
  	    var j;
  	    var jLen;
  	    var amplitude = this.amplitude.v;
  	    var frequency = Math.max(0, Math.round(this.frequency.v));
  	    var pointType = this.pointsType.v;
  	    if (amplitude !== 0) {
  	      var shapeData;
  	      var localShapeCollection;
  	      for (i = 0; i < len; i += 1) {
  	        shapeData = this.shapes[i];
  	        localShapeCollection = shapeData.localShapeCollection;
  	        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
  	          localShapeCollection.releaseShapes();
  	          shapeData.shape._mdf = true;
  	          shapePaths = shapeData.shape.paths.shapes;
  	          jLen = shapeData.shape.paths._length;
  	          for (j = 0; j < jLen; j += 1) {
  	            localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
  	          }
  	        }
  	        shapeData.shape.paths = shapeData.localShapeCollection;
  	      }
  	    }
  	    if (!this.dynamicProperties.length) {
  	      this._mdf = false;
  	    }
  	  };

  	  function linearOffset(p1, p2, amount) {
  	    var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
  	    return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
  	  }
  	  function offsetSegment(segment, amount) {
  	    var p0;
  	    var p1a;
  	    var p1b;
  	    var p2b;
  	    var p2a;
  	    var p3;
  	    var e;
  	    e = linearOffset(segment.points[0], segment.points[1], amount);
  	    p0 = e[0];
  	    p1a = e[1];
  	    e = linearOffset(segment.points[1], segment.points[2], amount);
  	    p1b = e[0];
  	    p2b = e[1];
  	    e = linearOffset(segment.points[2], segment.points[3], amount);
  	    p2a = e[0];
  	    p3 = e[1];
  	    var p1 = lineIntersection(p0, p1a, p1b, p2b);
  	    if (p1 === null) p1 = p1a;
  	    var p2 = lineIntersection(p2a, p3, p1b, p2b);
  	    if (p2 === null) p2 = p2a;
  	    return new PolynomialBezier(p0, p1, p2, p3);
  	  }
  	  function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
  	    var p0 = seg1.points[3];
  	    var p1 = seg2.points[0];

  	    // Bevel
  	    if (lineJoin === 3) return p0;

  	    // Connected, they don't need a joint
  	    if (pointEqual(p0, p1)) return p0;

  	    // Round
  	    if (lineJoin === 2) {
  	      var angleOut = -seg1.tangentAngle(1);
  	      var angleIn = -seg2.tangentAngle(0) + Math.PI;
  	      var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
  	      var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
  	      var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
  	      outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);
  	      tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
  	      outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
  	      return p1;
  	    }

  	    // Miter
  	    var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
  	    var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
  	    var intersection = lineIntersection(t0, p0, p1, t1);
  	    if (intersection && pointDistance(intersection, p0) < miterLimit) {
  	      outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
  	      return intersection;
  	    }
  	    return p0;
  	  }
  	  function getIntersection(a, b) {
  	    var intersect = a.intersections(b);
  	    if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
  	    if (intersect.length) return intersect[0];
  	    return null;
  	  }
  	  function pruneSegmentIntersection(a, b) {
  	    var outa = a.slice();
  	    var outb = b.slice();
  	    var intersect = getIntersection(a[a.length - 1], b[0]);
  	    if (intersect) {
  	      outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
  	      outb[0] = b[0].split(intersect[1])[1];
  	    }
  	    if (a.length > 1 && b.length > 1) {
  	      intersect = getIntersection(a[0], b[b.length - 1]);
  	      if (intersect) {
  	        return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
  	      }
  	    }
  	    return [outa, outb];
  	  }
  	  function pruneIntersections(segments) {
  	    var e;
  	    for (var i = 1; i < segments.length; i += 1) {
  	      e = pruneSegmentIntersection(segments[i - 1], segments[i]);
  	      segments[i - 1] = e[0];
  	      segments[i] = e[1];
  	    }
  	    if (segments.length > 1) {
  	      e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
  	      segments[segments.length - 1] = e[0];
  	      segments[0] = e[1];
  	    }
  	    return segments;
  	  }
  	  function offsetSegmentSplit(segment, amount) {
  	    /*
  	      We split each bezier segment into smaller pieces based
  	      on inflection points, this ensures the control point
  	      polygon is convex.
  	       (A cubic bezier can have none, one, or two inflection points)
  	    */
  	    var flex = segment.inflectionPoints();
  	    var left;
  	    var right;
  	    var split;
  	    var mid;
  	    if (flex.length === 0) {
  	      return [offsetSegment(segment, amount)];
  	    }
  	    if (flex.length === 1 || floatEqual(flex[1], 1)) {
  	      split = segment.split(flex[0]);
  	      left = split[0];
  	      right = split[1];
  	      return [offsetSegment(left, amount), offsetSegment(right, amount)];
  	    }
  	    split = segment.split(flex[0]);
  	    left = split[0];
  	    var t = (flex[1] - flex[0]) / (1 - flex[0]);
  	    split = split[1].split(t);
  	    mid = split[0];
  	    right = split[1];
  	    return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
  	  }
  	  function OffsetPathModifier() {}
  	  extendPrototype([ShapeModifier], OffsetPathModifier);
  	  OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {
  	    this.getValue = this.processKeys;
  	    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
  	    this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);
  	    this.lineJoin = data.lj;
  	    this._isAnimated = this.amount.effectsSequence.length !== 0;
  	  };
  	  OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {
  	    var outputBezier = shapePool.newElement();
  	    outputBezier.c = inputBezier.c;
  	    var count = inputBezier.length();
  	    if (!inputBezier.c) {
  	      count -= 1;
  	    }
  	    var i;
  	    var j;
  	    var segment;
  	    var multiSegments = [];
  	    for (i = 0; i < count; i += 1) {
  	      segment = PolynomialBezier.shapeSegment(inputBezier, i);
  	      multiSegments.push(offsetSegmentSplit(segment, amount));
  	    }
  	    if (!inputBezier.c) {
  	      for (i = count - 1; i >= 0; i -= 1) {
  	        segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
  	        multiSegments.push(offsetSegmentSplit(segment, amount));
  	      }
  	    }
  	    multiSegments = pruneIntersections(multiSegments);

  	    // Add bezier segments to the output and apply line joints
  	    var lastPoint = null;
  	    var lastSeg = null;
  	    for (i = 0; i < multiSegments.length; i += 1) {
  	      var multiSegment = multiSegments[i];
  	      if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
  	      lastSeg = multiSegment[multiSegment.length - 1];
  	      for (j = 0; j < multiSegment.length; j += 1) {
  	        segment = multiSegment[j];
  	        if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
  	          outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);
  	        } else {
  	          outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
  	        }
  	        outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
  	        lastPoint = segment.points[3];
  	      }
  	    }
  	    if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
  	    return outputBezier;
  	  };
  	  OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {
  	    var shapePaths;
  	    var i;
  	    var len = this.shapes.length;
  	    var j;
  	    var jLen;
  	    var amount = this.amount.v;
  	    var miterLimit = this.miterLimit.v;
  	    var lineJoin = this.lineJoin;
  	    if (amount !== 0) {
  	      var shapeData;
  	      var localShapeCollection;
  	      for (i = 0; i < len; i += 1) {
  	        shapeData = this.shapes[i];
  	        localShapeCollection = shapeData.localShapeCollection;
  	        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
  	          localShapeCollection.releaseShapes();
  	          shapeData.shape._mdf = true;
  	          shapePaths = shapeData.shape.paths.shapes;
  	          jLen = shapeData.shape.paths._length;
  	          for (j = 0; j < jLen; j += 1) {
  	            localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
  	          }
  	        }
  	        shapeData.shape.paths = shapeData.localShapeCollection;
  	      }
  	    }
  	    if (!this.dynamicProperties.length) {
  	      this._mdf = false;
  	    }
  	  };

  	  function getFontProperties(fontData) {
  	    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
  	    var fWeight = 'normal';
  	    var fStyle = 'normal';
  	    var len = styles.length;
  	    var styleName;
  	    for (var i = 0; i < len; i += 1) {
  	      styleName = styles[i].toLowerCase();
  	      switch (styleName) {
  	        case 'italic':
  	          fStyle = 'italic';
  	          break;
  	        case 'bold':
  	          fWeight = '700';
  	          break;
  	        case 'black':
  	          fWeight = '900';
  	          break;
  	        case 'medium':
  	          fWeight = '500';
  	          break;
  	        case 'regular':
  	        case 'normal':
  	          fWeight = '400';
  	          break;
  	        case 'light':
  	        case 'thin':
  	          fWeight = '200';
  	          break;
  	      }
  	    }
  	    return {
  	      style: fStyle,
  	      weight: fontData.fWeight || fWeight
  	    };
  	  }

  	  var FontManager = function () {
  	    var maxWaitingTime = 5000;
  	    var emptyChar = {
  	      w: 0,
  	      size: 0,
  	      shapes: [],
  	      data: {
  	        shapes: []
  	      }
  	    };
  	    var combinedCharacters = [];
  	    // Hindi characters
  	    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
  	    var BLACK_FLAG_CODE_POINT = 127988;
  	    var CANCEL_TAG_CODE_POINT = 917631;
  	    var A_TAG_CODE_POINT = 917601;
  	    var Z_TAG_CODE_POINT = 917626;
  	    var VARIATION_SELECTOR_16_CODE_POINT = 65039;
  	    var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
  	    var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
  	    var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
  	    var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];
  	    function trimFontOptions(font) {
  	      var familyArray = font.split(',');
  	      var i;
  	      var len = familyArray.length;
  	      var enabledFamilies = [];
  	      for (i = 0; i < len; i += 1) {
  	        if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
  	          enabledFamilies.push(familyArray[i]);
  	        }
  	      }
  	      return enabledFamilies.join(',');
  	    }
  	    function setUpNode(font, family) {
  	      var parentNode = createTag('span');
  	      // Node is invisible to screen readers.
  	      parentNode.setAttribute('aria-hidden', true);
  	      parentNode.style.fontFamily = family;
  	      var node = createTag('span');
  	      // Characters that vary significantly among different fonts
  	      node.innerText = 'giItT1WQy@!-/#';
  	      // Visible - so we can measure it - but not on the screen
  	      parentNode.style.position = 'absolute';
  	      parentNode.style.left = '-10000px';
  	      parentNode.style.top = '-10000px';
  	      // Large font size makes even subtle changes obvious
  	      parentNode.style.fontSize = '300px';
  	      // Reset any font properties
  	      parentNode.style.fontVariant = 'normal';
  	      parentNode.style.fontStyle = 'normal';
  	      parentNode.style.fontWeight = 'normal';
  	      parentNode.style.letterSpacing = '0';
  	      parentNode.appendChild(node);
  	      document.body.appendChild(parentNode);

  	      // Remember width with no applied web font
  	      var width = node.offsetWidth;
  	      node.style.fontFamily = trimFontOptions(font) + ', ' + family;
  	      return {
  	        node: node,
  	        w: width,
  	        parent: parentNode
  	      };
  	    }
  	    function checkLoadedFonts() {
  	      var i;
  	      var len = this.fonts.length;
  	      var node;
  	      var w;
  	      var loadedCount = len;
  	      for (i = 0; i < len; i += 1) {
  	        if (this.fonts[i].loaded) {
  	          loadedCount -= 1;
  	        } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
  	          this.fonts[i].loaded = true;
  	        } else {
  	          node = this.fonts[i].monoCase.node;
  	          w = this.fonts[i].monoCase.w;
  	          if (node.offsetWidth !== w) {
  	            loadedCount -= 1;
  	            this.fonts[i].loaded = true;
  	          } else {
  	            node = this.fonts[i].sansCase.node;
  	            w = this.fonts[i].sansCase.w;
  	            if (node.offsetWidth !== w) {
  	              loadedCount -= 1;
  	              this.fonts[i].loaded = true;
  	            }
  	          }
  	          if (this.fonts[i].loaded) {
  	            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
  	            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
  	          }
  	        }
  	      }
  	      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
  	        setTimeout(this.checkLoadedFontsBinded, 20);
  	      } else {
  	        setTimeout(this.setIsLoadedBinded, 10);
  	      }
  	    }
  	    function createHelper(fontData, def) {
  	      var engine = document.body && def ? 'svg' : 'canvas';
  	      var helper;
  	      var fontProps = getFontProperties(fontData);
  	      if (engine === 'svg') {
  	        var tHelper = createNS('text');
  	        tHelper.style.fontSize = '100px';
  	        // tHelper.style.fontFamily = fontData.fFamily;
  	        tHelper.setAttribute('font-family', fontData.fFamily);
  	        tHelper.setAttribute('font-style', fontProps.style);
  	        tHelper.setAttribute('font-weight', fontProps.weight);
  	        tHelper.textContent = '1';
  	        if (fontData.fClass) {
  	          tHelper.style.fontFamily = 'inherit';
  	          tHelper.setAttribute('class', fontData.fClass);
  	        } else {
  	          tHelper.style.fontFamily = fontData.fFamily;
  	        }
  	        def.appendChild(tHelper);
  	        helper = tHelper;
  	      } else {
  	        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');
  	        tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;
  	        helper = tCanvasHelper;
  	      }
  	      function measure(text) {
  	        if (engine === 'svg') {
  	          helper.textContent = text;
  	          return helper.getComputedTextLength();
  	        }
  	        return helper.measureText(text).width;
  	      }
  	      return {
  	        measureText: measure
  	      };
  	    }
  	    function addFonts(fontData, defs) {
  	      if (!fontData) {
  	        this.isLoaded = true;
  	        return;
  	      }
  	      if (this.chars) {
  	        this.isLoaded = true;
  	        this.fonts = fontData.list;
  	        return;
  	      }
  	      if (!document.body) {
  	        this.isLoaded = true;
  	        fontData.list.forEach(function (data) {
  	          data.helper = createHelper(data);
  	          data.cache = {};
  	        });
  	        this.fonts = fontData.list;
  	        return;
  	      }
  	      var fontArr = fontData.list;
  	      var i;
  	      var len = fontArr.length;
  	      var _pendingFonts = len;
  	      for (i = 0; i < len; i += 1) {
  	        var shouldLoadFont = true;
  	        var loadedSelector;
  	        var j;
  	        fontArr[i].loaded = false;
  	        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
  	        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
  	        if (!fontArr[i].fPath) {
  	          fontArr[i].loaded = true;
  	          _pendingFonts -= 1;
  	        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
  	          loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
  	          if (loadedSelector.length > 0) {
  	            shouldLoadFont = false;
  	          }
  	          if (shouldLoadFont) {
  	            var s = createTag('style');
  	            s.setAttribute('f-forigin', fontArr[i].fOrigin);
  	            s.setAttribute('f-origin', fontArr[i].origin);
  	            s.setAttribute('f-family', fontArr[i].fFamily);
  	            s.type = 'text/css';
  	            s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
  	            defs.appendChild(s);
  	          }
  	        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
  	          loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
  	          for (j = 0; j < loadedSelector.length; j += 1) {
  	            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
  	              // Font is already loaded
  	              shouldLoadFont = false;
  	            }
  	          }
  	          if (shouldLoadFont) {
  	            var l = createTag('link');
  	            l.setAttribute('f-forigin', fontArr[i].fOrigin);
  	            l.setAttribute('f-origin', fontArr[i].origin);
  	            l.type = 'text/css';
  	            l.rel = 'stylesheet';
  	            l.href = fontArr[i].fPath;
  	            document.body.appendChild(l);
  	          }
  	        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
  	          loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
  	          for (j = 0; j < loadedSelector.length; j += 1) {
  	            if (fontArr[i].fPath === loadedSelector[j].src) {
  	              // Font is already loaded
  	              shouldLoadFont = false;
  	            }
  	          }
  	          if (shouldLoadFont) {
  	            var sc = createTag('link');
  	            sc.setAttribute('f-forigin', fontArr[i].fOrigin);
  	            sc.setAttribute('f-origin', fontArr[i].origin);
  	            sc.setAttribute('rel', 'stylesheet');
  	            sc.setAttribute('href', fontArr[i].fPath);
  	            defs.appendChild(sc);
  	          }
  	        }
  	        fontArr[i].helper = createHelper(fontArr[i], defs);
  	        fontArr[i].cache = {};
  	        this.fonts.push(fontArr[i]);
  	      }
  	      if (_pendingFonts === 0) {
  	        this.isLoaded = true;
  	      } else {
  	        // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
  	        // Adding this timeout seems to fix it
  	        setTimeout(this.checkLoadedFonts.bind(this), 100);
  	      }
  	    }
  	    function addChars(chars) {
  	      if (!chars) {
  	        return;
  	      }
  	      if (!this.chars) {
  	        this.chars = [];
  	      }
  	      var i;
  	      var len = chars.length;
  	      var j;
  	      var jLen = this.chars.length;
  	      var found;
  	      for (i = 0; i < len; i += 1) {
  	        j = 0;
  	        found = false;
  	        while (j < jLen) {
  	          if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
  	            found = true;
  	          }
  	          j += 1;
  	        }
  	        if (!found) {
  	          this.chars.push(chars[i]);
  	          jLen += 1;
  	        }
  	      }
  	    }
  	    function getCharData(_char, style, font) {
  	      var i = 0;
  	      var len = this.chars.length;
  	      while (i < len) {
  	        if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
  	          return this.chars[i];
  	        }
  	        i += 1;
  	      }
  	      if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
  	      && !this._warned) {
  	        this._warned = true;
  	        console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console
  	      }
  	      return emptyChar;
  	    }
  	    function measureText(_char2, fontName, size) {
  	      var fontData = this.getFontByName(fontName);
  	      // Using the char instead of char.charCodeAt(0)
  	      // to avoid collisions between equal chars
  	      var index = _char2;
  	      if (!fontData.cache[index]) {
  	        var tHelper = fontData.helper;
  	        if (_char2 === ' ') {
  	          var doubleSize = tHelper.measureText('|' + _char2 + '|');
  	          var singleSize = tHelper.measureText('||');
  	          fontData.cache[index] = (doubleSize - singleSize) / 100;
  	        } else {
  	          fontData.cache[index] = tHelper.measureText(_char2) / 100;
  	        }
  	      }
  	      return fontData.cache[index] * size;
  	    }
  	    function getFontByName(name) {
  	      var i = 0;
  	      var len = this.fonts.length;
  	      while (i < len) {
  	        if (this.fonts[i].fName === name) {
  	          return this.fonts[i];
  	        }
  	        i += 1;
  	      }
  	      return this.fonts[0];
  	    }
  	    function getCodePoint(string) {
  	      var codePoint = 0;
  	      var first = string.charCodeAt(0);
  	      if (first >= 0xD800 && first <= 0xDBFF) {
  	        var second = string.charCodeAt(1);
  	        if (second >= 0xDC00 && second <= 0xDFFF) {
  	          codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  	        }
  	      }
  	      return codePoint;
  	    }

  	    // Skin tone modifiers
  	    function isModifier(firstCharCode, secondCharCode) {
  	      var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
  	      return surrogateModifiers.indexOf(sum) !== -1;
  	    }
  	    function isZeroWidthJoiner(charCode) {
  	      return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
  	    }

  	    // This codepoint may change the appearance of the preceding character.
  	    // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered
  	    // as a colorful image as compared to a monochrome text variant.
  	    function isVariationSelector(charCode) {
  	      return charCode === VARIATION_SELECTOR_16_CODE_POINT;
  	    }

  	    // The regional indicator symbols are a set of 26 alphabetic Unicode
  	    /// characters (AZ) intended to be used to encode ISO 3166-1 alpha-2
  	    // two-letter country codes in a way that allows optional special treatment.
  	    function isRegionalCode(string) {
  	      var codePoint = getCodePoint(string);
  	      if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
  	        return true;
  	      }
  	      return false;
  	    }

  	    // Some Emoji implementations represent combinations of
  	    // two regional indicator letters as a single flag symbol.
  	    function isFlagEmoji(string) {
  	      return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
  	    }
  	    function isCombinedCharacter(_char3) {
  	      return combinedCharacters.indexOf(_char3) !== -1;
  	    }

  	    // Regional flags start with a BLACK_FLAG_CODE_POINT
  	    // folowed by 5 chars in the TAG range
  	    // and end with a CANCEL_TAG_CODE_POINT
  	    function isRegionalFlag(text, index) {
  	      var codePoint = getCodePoint(text.substr(index, 2));
  	      if (codePoint !== BLACK_FLAG_CODE_POINT) {
  	        return false;
  	      }
  	      var count = 0;
  	      index += 2;
  	      while (count < 5) {
  	        codePoint = getCodePoint(text.substr(index, 2));
  	        if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
  	          return false;
  	        }
  	        count += 1;
  	        index += 2;
  	      }
  	      return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;
  	    }
  	    function setIsLoaded() {
  	      this.isLoaded = true;
  	    }
  	    var Font = function Font() {
  	      this.fonts = [];
  	      this.chars = null;
  	      this.typekitLoaded = 0;
  	      this.isLoaded = false;
  	      this._warned = false;
  	      this.initTime = Date.now();
  	      this.setIsLoadedBinded = this.setIsLoaded.bind(this);
  	      this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
  	    };
  	    Font.isModifier = isModifier;
  	    Font.isZeroWidthJoiner = isZeroWidthJoiner;
  	    Font.isFlagEmoji = isFlagEmoji;
  	    Font.isRegionalCode = isRegionalCode;
  	    Font.isCombinedCharacter = isCombinedCharacter;
  	    Font.isRegionalFlag = isRegionalFlag;
  	    Font.isVariationSelector = isVariationSelector;
  	    Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
  	    var fontPrototype = {
  	      addChars: addChars,
  	      addFonts: addFonts,
  	      getCharData: getCharData,
  	      getFontByName: getFontByName,
  	      measureText: measureText,
  	      checkLoadedFonts: checkLoadedFonts,
  	      setIsLoaded: setIsLoaded
  	    };
  	    Font.prototype = fontPrototype;
  	    return Font;
  	  }();

  	  function SlotManager(animationData) {
  	    this.animationData = animationData;
  	  }
  	  SlotManager.prototype.getProp = function (data) {
  	    if (this.animationData.slots && this.animationData.slots[data.sid]) {
  	      return Object.assign(data, this.animationData.slots[data.sid].p);
  	    }
  	    return data;
  	  };
  	  function slotFactory(animationData) {
  	    return new SlotManager(animationData);
  	  }

  	  function RenderableElement() {}
  	  RenderableElement.prototype = {
  	    initRenderable: function initRenderable() {
  	      // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
  	      this.isInRange = false;
  	      // layer's display state
  	      this.hidden = false;
  	      // If layer's transparency equals 0, it can be hidden
  	      this.isTransparent = false;
  	      // list of animated components
  	      this.renderableComponents = [];
  	    },
  	    addRenderableComponent: function addRenderableComponent(component) {
  	      if (this.renderableComponents.indexOf(component) === -1) {
  	        this.renderableComponents.push(component);
  	      }
  	    },
  	    removeRenderableComponent: function removeRenderableComponent(component) {
  	      if (this.renderableComponents.indexOf(component) !== -1) {
  	        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
  	      }
  	    },
  	    prepareRenderableFrame: function prepareRenderableFrame(num) {
  	      this.checkLayerLimits(num);
  	    },
  	    checkTransparency: function checkTransparency() {
  	      if (this.finalTransform.mProp.o.v <= 0) {
  	        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
  	          this.isTransparent = true;
  	          this.hide();
  	        }
  	      } else if (this.isTransparent) {
  	        this.isTransparent = false;
  	        this.show();
  	      }
  	    },
  	    /**
  	       * @function
  	       * Initializes frame related properties.
  	       *
  	       * @param {number} num
  	       * current frame number in Layer's time
  	       *
  	       */
  	    checkLayerLimits: function checkLayerLimits(num) {
  	      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
  	        if (this.isInRange !== true) {
  	          this.globalData._mdf = true;
  	          this._mdf = true;
  	          this.isInRange = true;
  	          this.show();
  	        }
  	      } else if (this.isInRange !== false) {
  	        this.globalData._mdf = true;
  	        this.isInRange = false;
  	        this.hide();
  	      }
  	    },
  	    renderRenderable: function renderRenderable() {
  	      var i;
  	      var len = this.renderableComponents.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.renderableComponents[i].renderFrame(this._isFirstFrame);
  	      }
  	      /* this.maskManager.renderFrame(this.finalTransform.mat);
  	          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
  	    },
  	    sourceRectAtTime: function sourceRectAtTime() {
  	      return {
  	        top: 0,
  	        left: 0,
  	        width: 100,
  	        height: 100
  	      };
  	    },
  	    getLayerSize: function getLayerSize() {
  	      if (this.data.ty === 5) {
  	        return {
  	          w: this.data.textData.width,
  	          h: this.data.textData.height
  	        };
  	      }
  	      return {
  	        w: this.data.width,
  	        h: this.data.height
  	      };
  	    }
  	  };

  	  var getBlendMode = function () {
  	    var blendModeEnums = {
  	      0: 'source-over',
  	      1: 'multiply',
  	      2: 'screen',
  	      3: 'overlay',
  	      4: 'darken',
  	      5: 'lighten',
  	      6: 'color-dodge',
  	      7: 'color-burn',
  	      8: 'hard-light',
  	      9: 'soft-light',
  	      10: 'difference',
  	      11: 'exclusion',
  	      12: 'hue',
  	      13: 'saturation',
  	      14: 'color',
  	      15: 'luminosity'
  	    };
  	    return function (mode) {
  	      return blendModeEnums[mode] || '';
  	    };
  	  }();

  	  function SliderEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  	  }
  	  function AngleEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  	  }
  	  function ColorEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
  	  }
  	  function PointEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
  	  }
  	  function LayerIndexEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  	  }
  	  function MaskIndexEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  	  }
  	  function CheckboxEffect(data, elem, container) {
  	    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  	  }
  	  function NoValueEffect() {
  	    this.p = {};
  	  }

  	  function EffectsManager(data, element) {
  	    var effects = data.ef || [];
  	    this.effectElements = [];
  	    var i;
  	    var len = effects.length;
  	    var effectItem;
  	    for (i = 0; i < len; i += 1) {
  	      effectItem = new GroupEffect(effects[i], element);
  	      this.effectElements.push(effectItem);
  	    }
  	  }
  	  function GroupEffect(data, element) {
  	    this.init(data, element);
  	  }
  	  extendPrototype([DynamicPropertyContainer], GroupEffect);
  	  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
  	  GroupEffect.prototype.init = function (data, element) {
  	    this.data = data;
  	    this.effectElements = [];
  	    this.initDynamicPropertyContainer(element);
  	    var i;
  	    var len = this.data.ef.length;
  	    var eff;
  	    var effects = this.data.ef;
  	    for (i = 0; i < len; i += 1) {
  	      eff = null;
  	      switch (effects[i].ty) {
  	        case 0:
  	          eff = new SliderEffect(effects[i], element, this);
  	          break;
  	        case 1:
  	          eff = new AngleEffect(effects[i], element, this);
  	          break;
  	        case 2:
  	          eff = new ColorEffect(effects[i], element, this);
  	          break;
  	        case 3:
  	          eff = new PointEffect(effects[i], element, this);
  	          break;
  	        case 4:
  	        case 7:
  	          eff = new CheckboxEffect(effects[i], element, this);
  	          break;
  	        case 10:
  	          eff = new LayerIndexEffect(effects[i], element, this);
  	          break;
  	        case 11:
  	          eff = new MaskIndexEffect(effects[i], element, this);
  	          break;
  	        case 5:
  	          eff = new EffectsManager(effects[i], element);
  	          break;
  	        // case 6:
  	        default:
  	          eff = new NoValueEffect(effects[i]);
  	          break;
  	      }
  	      if (eff) {
  	        this.effectElements.push(eff);
  	      }
  	    }
  	  };

  	  function BaseElement() {}
  	  BaseElement.prototype = {
  	    checkMasks: function checkMasks() {
  	      if (!this.data.hasMask) {
  	        return false;
  	      }
  	      var i = 0;
  	      var len = this.data.masksProperties.length;
  	      while (i < len) {
  	        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
  	          return true;
  	        }
  	        i += 1;
  	      }
  	      return false;
  	    },
  	    initExpressions: function initExpressions() {
  	      var expressionsInterfaces = getExpressionInterfaces();
  	      if (!expressionsInterfaces) {
  	        return;
  	      }
  	      var LayerExpressionInterface = expressionsInterfaces('layer');
  	      var EffectsExpressionInterface = expressionsInterfaces('effects');
  	      var ShapeExpressionInterface = expressionsInterfaces('shape');
  	      var TextExpressionInterface = expressionsInterfaces('text');
  	      var CompExpressionInterface = expressionsInterfaces('comp');
  	      this.layerInterface = LayerExpressionInterface(this);
  	      if (this.data.hasMask && this.maskManager) {
  	        this.layerInterface.registerMaskInterface(this.maskManager);
  	      }
  	      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
  	      this.layerInterface.registerEffectsInterface(effectsInterface);
  	      if (this.data.ty === 0 || this.data.xt) {
  	        this.compInterface = CompExpressionInterface(this);
  	      } else if (this.data.ty === 4) {
  	        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
  	        this.layerInterface.content = this.layerInterface.shapeInterface;
  	      } else if (this.data.ty === 5) {
  	        this.layerInterface.textInterface = TextExpressionInterface(this);
  	        this.layerInterface.text = this.layerInterface.textInterface;
  	      }
  	    },
  	    setBlendMode: function setBlendMode() {
  	      var blendModeValue = getBlendMode(this.data.bm);
  	      var elem = this.baseElement || this.layerElement;
  	      elem.style['mix-blend-mode'] = blendModeValue;
  	    },
  	    initBaseData: function initBaseData(data, globalData, comp) {
  	      this.globalData = globalData;
  	      this.comp = comp;
  	      this.data = data;
  	      this.layerId = createElementID();

  	      // Stretch factor for old animations missing this property.
  	      if (!this.data.sr) {
  	        this.data.sr = 1;
  	      }
  	      // effects manager
  	      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
  	    },
  	    getType: function getType() {
  	      return this.type;
  	    },
  	    sourceRectAtTime: function sourceRectAtTime() {}
  	  };

  	  /**
  	   * @file
  	   * Handles element's layer frame update.
  	   * Checks layer in point and out point
  	   *
  	   */

  	  function FrameElement() {}
  	  FrameElement.prototype = {
  	    /**
  	       * @function
  	       * Initializes frame related properties.
  	       *
  	       */
  	    initFrame: function initFrame() {
  	      // set to true when inpoint is rendered
  	      this._isFirstFrame = false;
  	      // list of animated properties
  	      this.dynamicProperties = [];
  	      // If layer has been modified in current tick this will be true
  	      this._mdf = false;
  	    },
  	    /**
  	       * @function
  	       * Calculates all dynamic values
  	       *
  	       * @param {number} num
  	       * current frame number in Layer's time
  	       * @param {boolean} isVisible
  	       * if layers is currently in range
  	       *
  	       */
  	    prepareProperties: function prepareProperties(num, isVisible) {
  	      var i;
  	      var len = this.dynamicProperties.length;
  	      for (i = 0; i < len; i += 1) {
  	        if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
  	          this.dynamicProperties[i].getValue();
  	          if (this.dynamicProperties[i]._mdf) {
  	            this.globalData._mdf = true;
  	            this._mdf = true;
  	          }
  	        }
  	      }
  	    },
  	    addDynamicProperty: function addDynamicProperty(prop) {
  	      if (this.dynamicProperties.indexOf(prop) === -1) {
  	        this.dynamicProperties.push(prop);
  	      }
  	    }
  	  };

  	  function FootageElement(data, globalData, comp) {
  	    this.initFrame();
  	    this.initRenderable();
  	    this.assetData = globalData.getAssetData(data.refId);
  	    this.footageData = globalData.imageLoader.getAsset(this.assetData);
  	    this.initBaseData(data, globalData, comp);
  	  }
  	  FootageElement.prototype.prepareFrame = function () {};
  	  extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
  	  FootageElement.prototype.getBaseElement = function () {
  	    return null;
  	  };
  	  FootageElement.prototype.renderFrame = function () {};
  	  FootageElement.prototype.destroy = function () {};
  	  FootageElement.prototype.initExpressions = function () {
  	    var expressionsInterfaces = getExpressionInterfaces();
  	    if (!expressionsInterfaces) {
  	      return;
  	    }
  	    var FootageInterface = expressionsInterfaces('footage');
  	    this.layerInterface = FootageInterface(this);
  	  };
  	  FootageElement.prototype.getFootageData = function () {
  	    return this.footageData;
  	  };

  	  function AudioElement(data, globalData, comp) {
  	    this.initFrame();
  	    this.initRenderable();
  	    this.assetData = globalData.getAssetData(data.refId);
  	    this.initBaseData(data, globalData, comp);
  	    this._isPlaying = false;
  	    this._canPlay = false;
  	    var assetPath = this.globalData.getAssetsPath(this.assetData);
  	    this.audio = this.globalData.audioController.createAudio(assetPath);
  	    this._currentTime = 0;
  	    this.globalData.audioController.addAudio(this);
  	    this._volumeMultiplier = 1;
  	    this._volume = 1;
  	    this._previousVolume = null;
  	    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
  	      _placeholder: true
  	    };
  	    this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
  	      k: [100]
  	    }, 1, 0.01, this);
  	  }
  	  AudioElement.prototype.prepareFrame = function (num) {
  	    this.prepareRenderableFrame(num, true);
  	    this.prepareProperties(num, true);
  	    if (!this.tm._placeholder) {
  	      var timeRemapped = this.tm.v;
  	      this._currentTime = timeRemapped;
  	    } else {
  	      this._currentTime = num / this.data.sr;
  	    }
  	    this._volume = this.lv.v[0];
  	    var totalVolume = this._volume * this._volumeMultiplier;
  	    if (this._previousVolume !== totalVolume) {
  	      this._previousVolume = totalVolume;
  	      this.audio.volume(totalVolume);
  	    }
  	  };
  	  extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
  	  AudioElement.prototype.renderFrame = function () {
  	    if (this.isInRange && this._canPlay) {
  	      if (!this._isPlaying) {
  	        this.audio.play();
  	        this.audio.seek(this._currentTime / this.globalData.frameRate);
  	        this._isPlaying = true;
  	      } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
  	        this.audio.seek(this._currentTime / this.globalData.frameRate);
  	      }
  	    }
  	  };
  	  AudioElement.prototype.show = function () {
  	    // this.audio.play()
  	  };
  	  AudioElement.prototype.hide = function () {
  	    this.audio.pause();
  	    this._isPlaying = false;
  	  };
  	  AudioElement.prototype.pause = function () {
  	    this.audio.pause();
  	    this._isPlaying = false;
  	    this._canPlay = false;
  	  };
  	  AudioElement.prototype.resume = function () {
  	    this._canPlay = true;
  	  };
  	  AudioElement.prototype.setRate = function (rateValue) {
  	    this.audio.rate(rateValue);
  	  };
  	  AudioElement.prototype.volume = function (volumeValue) {
  	    this._volumeMultiplier = volumeValue;
  	    this._previousVolume = volumeValue * this._volume;
  	    this.audio.volume(this._previousVolume);
  	  };
  	  AudioElement.prototype.getBaseElement = function () {
  	    return null;
  	  };
  	  AudioElement.prototype.destroy = function () {};
  	  AudioElement.prototype.sourceRectAtTime = function () {};
  	  AudioElement.prototype.initExpressions = function () {};

  	  function BaseRenderer() {}
  	  BaseRenderer.prototype.checkLayers = function (num) {
  	    var i;
  	    var len = this.layers.length;
  	    var data;
  	    this.completeLayers = true;
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (!this.elements[i]) {
  	        data = this.layers[i];
  	        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
  	          this.buildItem(i);
  	        }
  	      }
  	      this.completeLayers = this.elements[i] ? this.completeLayers : false;
  	    }
  	    this.checkPendingElements();
  	  };
  	  BaseRenderer.prototype.createItem = function (layer) {
  	    switch (layer.ty) {
  	      case 2:
  	        return this.createImage(layer);
  	      case 0:
  	        return this.createComp(layer);
  	      case 1:
  	        return this.createSolid(layer);
  	      case 3:
  	        return this.createNull(layer);
  	      case 4:
  	        return this.createShape(layer);
  	      case 5:
  	        return this.createText(layer);
  	      case 6:
  	        return this.createAudio(layer);
  	      case 13:
  	        return this.createCamera(layer);
  	      case 15:
  	        return this.createFootage(layer);
  	      default:
  	        return this.createNull(layer);
  	    }
  	  };
  	  BaseRenderer.prototype.createCamera = function () {
  	    throw new Error('You\'re using a 3d camera. Try the html renderer.');
  	  };
  	  BaseRenderer.prototype.createAudio = function (data) {
  	    return new AudioElement(data, this.globalData, this);
  	  };
  	  BaseRenderer.prototype.createFootage = function (data) {
  	    return new FootageElement(data, this.globalData, this);
  	  };
  	  BaseRenderer.prototype.buildAllItems = function () {
  	    var i;
  	    var len = this.layers.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.buildItem(i);
  	    }
  	    this.checkPendingElements();
  	  };
  	  BaseRenderer.prototype.includeLayers = function (newLayers) {
  	    this.completeLayers = false;
  	    var i;
  	    var len = newLayers.length;
  	    var j;
  	    var jLen = this.layers.length;
  	    for (i = 0; i < len; i += 1) {
  	      j = 0;
  	      while (j < jLen) {
  	        if (this.layers[j].id === newLayers[i].id) {
  	          this.layers[j] = newLayers[i];
  	          break;
  	        }
  	        j += 1;
  	      }
  	    }
  	  };
  	  BaseRenderer.prototype.setProjectInterface = function (pInterface) {
  	    this.globalData.projectInterface = pInterface;
  	  };
  	  BaseRenderer.prototype.initItems = function () {
  	    if (!this.globalData.progressiveLoad) {
  	      this.buildAllItems();
  	    }
  	  };
  	  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
  	    var elements = this.elements;
  	    var layers = this.layers;
  	    var i = 0;
  	    var len = layers.length;
  	    while (i < len) {
  	      if (layers[i].ind == parentName) {
  	        // eslint-disable-line eqeqeq
  	        if (!elements[i] || elements[i] === true) {
  	          this.buildItem(i);
  	          this.addPendingElement(element);
  	        } else {
  	          hierarchy.push(elements[i]);
  	          elements[i].setAsParent();
  	          if (layers[i].parent !== undefined) {
  	            this.buildElementParenting(element, layers[i].parent, hierarchy);
  	          } else {
  	            element.setHierarchy(hierarchy);
  	          }
  	        }
  	      }
  	      i += 1;
  	    }
  	  };
  	  BaseRenderer.prototype.addPendingElement = function (element) {
  	    this.pendingElements.push(element);
  	  };
  	  BaseRenderer.prototype.searchExtraCompositions = function (assets) {
  	    var i;
  	    var len = assets.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (assets[i].xt) {
  	        var comp = this.createComp(assets[i]);
  	        comp.initExpressions();
  	        this.globalData.projectInterface.registerComposition(comp);
  	      }
  	    }
  	  };
  	  BaseRenderer.prototype.getElementById = function (ind) {
  	    var i;
  	    var len = this.elements.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.elements[i].data.ind === ind) {
  	        return this.elements[i];
  	      }
  	    }
  	    return null;
  	  };
  	  BaseRenderer.prototype.getElementByPath = function (path) {
  	    var pathValue = path.shift();
  	    var element;
  	    if (typeof pathValue === 'number') {
  	      element = this.elements[pathValue];
  	    } else {
  	      var i;
  	      var len = this.elements.length;
  	      for (i = 0; i < len; i += 1) {
  	        if (this.elements[i].data.nm === pathValue) {
  	          element = this.elements[i];
  	          break;
  	        }
  	      }
  	    }
  	    if (path.length === 0) {
  	      return element;
  	    }
  	    return element.getElementByPath(path);
  	  };
  	  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
  	    this.globalData.fontManager = new FontManager();
  	    this.globalData.slotManager = slotFactory(animData);
  	    this.globalData.fontManager.addChars(animData.chars);
  	    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
  	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
  	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
  	    this.globalData.imageLoader = this.animationItem.imagePreloader;
  	    this.globalData.audioController = this.animationItem.audioController;
  	    this.globalData.frameId = 0;
  	    this.globalData.frameRate = animData.fr;
  	    this.globalData.nm = animData.nm;
  	    this.globalData.compSize = {
  	      w: animData.w,
  	      h: animData.h
  	    };
  	  };

  	  var effectTypes = {
  	    TRANSFORM_EFFECT: 'transformEFfect'
  	  };

  	  function TransformElement() {}
  	  TransformElement.prototype = {
  	    initTransform: function initTransform() {
  	      var mat = new Matrix();
  	      this.finalTransform = {
  	        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
  	          o: 0
  	        },
  	        _matMdf: false,
  	        _localMatMdf: false,
  	        _opMdf: false,
  	        mat: mat,
  	        localMat: mat,
  	        localOpacity: 1
  	      };
  	      if (this.data.ao) {
  	        this.finalTransform.mProp.autoOriented = true;
  	      }

  	      // TODO: check TYPE 11: Guided elements
  	      if (this.data.ty !== 11) ;
  	    },
  	    renderTransform: function renderTransform() {
  	      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
  	      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
  	      if (this.hierarchy) {
  	        var mat;
  	        var finalMat = this.finalTransform.mat;
  	        var i = 0;
  	        var len = this.hierarchy.length;
  	        // Checking if any of the transformation matrices in the hierarchy chain has changed.
  	        if (!this.finalTransform._matMdf) {
  	          while (i < len) {
  	            if (this.hierarchy[i].finalTransform.mProp._mdf) {
  	              this.finalTransform._matMdf = true;
  	              break;
  	            }
  	            i += 1;
  	          }
  	        }
  	        if (this.finalTransform._matMdf) {
  	          mat = this.finalTransform.mProp.v.props;
  	          finalMat.cloneFromProps(mat);
  	          for (i = 0; i < len; i += 1) {
  	            finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
  	          }
  	        }
  	      }
  	      if (!this.localTransforms || this.finalTransform._matMdf) {
  	        this.finalTransform._localMatMdf = this.finalTransform._matMdf;
  	      }
  	      if (this.finalTransform._opMdf) {
  	        this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
  	      }
  	    },
  	    renderLocalTransform: function renderLocalTransform() {
  	      if (this.localTransforms) {
  	        var i = 0;
  	        var len = this.localTransforms.length;
  	        this.finalTransform._localMatMdf = this.finalTransform._matMdf;
  	        if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
  	          while (i < len) {
  	            if (this.localTransforms[i]._mdf) {
  	              this.finalTransform._localMatMdf = true;
  	            }
  	            if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
  	              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
  	              this.finalTransform._opMdf = true;
  	            }
  	            i += 1;
  	          }
  	        }
  	        if (this.finalTransform._localMatMdf) {
  	          var localMat = this.finalTransform.localMat;
  	          this.localTransforms[0].matrix.clone(localMat);
  	          for (i = 1; i < len; i += 1) {
  	            var lmat = this.localTransforms[i].matrix;
  	            localMat.multiply(lmat);
  	          }
  	          localMat.multiply(this.finalTransform.mat);
  	        }
  	        if (this.finalTransform._opMdf) {
  	          var localOp = this.finalTransform.localOpacity;
  	          for (i = 0; i < len; i += 1) {
  	            localOp *= this.localTransforms[i].opacity * 0.01;
  	          }
  	          this.finalTransform.localOpacity = localOp;
  	        }
  	      }
  	    },
  	    searchEffectTransforms: function searchEffectTransforms() {
  	      if (this.renderableEffectsManager) {
  	        var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
  	        if (transformEffects.length) {
  	          this.localTransforms = [];
  	          this.finalTransform.localMat = new Matrix();
  	          var i = 0;
  	          var len = transformEffects.length;
  	          for (i = 0; i < len; i += 1) {
  	            this.localTransforms.push(transformEffects[i]);
  	          }
  	        }
  	      }
  	    },
  	    globalToLocal: function globalToLocal(pt) {
  	      var transforms = [];
  	      transforms.push(this.finalTransform);
  	      var flag = true;
  	      var comp = this.comp;
  	      while (flag) {
  	        if (comp.finalTransform) {
  	          if (comp.data.hasMask) {
  	            transforms.splice(0, 0, comp.finalTransform);
  	          }
  	          comp = comp.comp;
  	        } else {
  	          flag = false;
  	        }
  	      }
  	      var i;
  	      var len = transforms.length;
  	      var ptNew;
  	      for (i = 0; i < len; i += 1) {
  	        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
  	        // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
  	        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
  	      }
  	      return pt;
  	    },
  	    mHelper: new Matrix()
  	  };

  	  function MaskElement(data, element, globalData) {
  	    this.data = data;
  	    this.element = element;
  	    this.globalData = globalData;
  	    this.storedData = [];
  	    this.masksProperties = this.data.masksProperties || [];
  	    this.maskElement = null;
  	    var defs = this.globalData.defs;
  	    var i;
  	    var len = this.masksProperties ? this.masksProperties.length : 0;
  	    this.viewData = createSizedArray(len);
  	    this.solidPath = '';
  	    var path;
  	    var properties = this.masksProperties;
  	    var count = 0;
  	    var currentMasks = [];
  	    var j;
  	    var jLen;
  	    var layerId = createElementID();
  	    var rect;
  	    var expansor;
  	    var feMorph;
  	    var x;
  	    var maskType = 'clipPath';
  	    var maskRef = 'clip-path';
  	    for (i = 0; i < len; i += 1) {
  	      if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
  	        maskType = 'mask';
  	        maskRef = 'mask';
  	      }
  	      if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
  	        rect = createNS('rect');
  	        rect.setAttribute('fill', '#ffffff');
  	        rect.setAttribute('width', this.element.comp.data.w || 0);
  	        rect.setAttribute('height', this.element.comp.data.h || 0);
  	        currentMasks.push(rect);
  	      } else {
  	        rect = null;
  	      }
  	      path = createNS('path');
  	      if (properties[i].mode === 'n') {
  	        // TODO move this to a factory or to a constructor
  	        this.viewData[i] = {
  	          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
  	          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
  	          elem: path,
  	          lastPath: ''
  	        };
  	        defs.appendChild(path);
  	      } else {
  	        count += 1;
  	        path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
  	        path.setAttribute('clip-rule', 'nonzero');
  	        var filterID;
  	        if (properties[i].x.k !== 0) {
  	          maskType = 'mask';
  	          maskRef = 'mask';
  	          x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
  	          filterID = createElementID();
  	          expansor = createNS('filter');
  	          expansor.setAttribute('id', filterID);
  	          feMorph = createNS('feMorphology');
  	          feMorph.setAttribute('operator', 'erode');
  	          feMorph.setAttribute('in', 'SourceGraphic');
  	          feMorph.setAttribute('radius', '0');
  	          expansor.appendChild(feMorph);
  	          defs.appendChild(expansor);
  	          path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
  	        } else {
  	          feMorph = null;
  	          x = null;
  	        }

  	        // TODO move this to a factory or to a constructor
  	        this.storedData[i] = {
  	          elem: path,
  	          x: x,
  	          expan: feMorph,
  	          lastPath: '',
  	          lastOperator: '',
  	          filterId: filterID,
  	          lastRadius: 0
  	        };
  	        if (properties[i].mode === 'i') {
  	          jLen = currentMasks.length;
  	          var g = createNS('g');
  	          for (j = 0; j < jLen; j += 1) {
  	            g.appendChild(currentMasks[j]);
  	          }
  	          var mask = createNS('mask');
  	          mask.setAttribute('mask-type', 'alpha');
  	          mask.setAttribute('id', layerId + '_' + count);
  	          mask.appendChild(path);
  	          defs.appendChild(mask);
  	          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');
  	          currentMasks.length = 0;
  	          currentMasks.push(g);
  	        } else {
  	          currentMasks.push(path);
  	        }
  	        if (properties[i].inv && !this.solidPath) {
  	          this.solidPath = this.createLayerSolidPath();
  	        }
  	        // TODO move this to a factory or to a constructor
  	        this.viewData[i] = {
  	          elem: path,
  	          lastPath: '',
  	          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
  	          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
  	          invRect: rect
  	        };
  	        if (!this.viewData[i].prop.k) {
  	          this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
  	        }
  	      }
  	    }
  	    this.maskElement = createNS(maskType);
  	    len = currentMasks.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.maskElement.appendChild(currentMasks[i]);
  	    }
  	    if (count > 0) {
  	      this.maskElement.setAttribute('id', layerId);
  	      this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');
  	      defs.appendChild(this.maskElement);
  	    }
  	    if (this.viewData.length) {
  	      this.element.addRenderableComponent(this);
  	    }
  	  }
  	  MaskElement.prototype.getMaskProperty = function (pos) {
  	    return this.viewData[pos].prop;
  	  };
  	  MaskElement.prototype.renderFrame = function (isFirstFrame) {
  	    var finalMat = this.element.finalTransform.mat;
  	    var i;
  	    var len = this.masksProperties.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.viewData[i].prop._mdf || isFirstFrame) {
  	        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
  	      }
  	      if (this.viewData[i].op._mdf || isFirstFrame) {
  	        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
  	      }
  	      if (this.masksProperties[i].mode !== 'n') {
  	        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
  	          this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
  	        }
  	        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
  	          var feMorph = this.storedData[i].expan;
  	          if (this.storedData[i].x.v < 0) {
  	            if (this.storedData[i].lastOperator !== 'erode') {
  	              this.storedData[i].lastOperator = 'erode';
  	              this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');
  	            }
  	            feMorph.setAttribute('radius', -this.storedData[i].x.v);
  	          } else {
  	            if (this.storedData[i].lastOperator !== 'dilate') {
  	              this.storedData[i].lastOperator = 'dilate';
  	              this.storedData[i].elem.setAttribute('filter', null);
  	            }
  	            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
  	          }
  	        }
  	      }
  	    }
  	  };
  	  MaskElement.prototype.getMaskelement = function () {
  	    return this.maskElement;
  	  };
  	  MaskElement.prototype.createLayerSolidPath = function () {
  	    var path = 'M0,0 ';
  	    path += ' h' + this.globalData.compSize.w;
  	    path += ' v' + this.globalData.compSize.h;
  	    path += ' h-' + this.globalData.compSize.w;
  	    path += ' v-' + this.globalData.compSize.h + ' ';
  	    return path;
  	  };
  	  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
  	    var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  	    var i;
  	    var len;
  	    len = pathNodes._length;
  	    for (i = 1; i < len; i += 1) {
  	      // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
  	      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
  	    }
  	    // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
  	    if (pathNodes.c && len > 1) {
  	      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  	    }
  	    // pathNodes.__renderedString = pathString;

  	    if (viewData.lastPath !== pathString) {
  	      var pathShapeValue = '';
  	      if (viewData.elem) {
  	        if (pathNodes.c) {
  	          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
  	        }
  	        viewData.elem.setAttribute('d', pathShapeValue);
  	      }
  	      viewData.lastPath = pathString;
  	    }
  	  };
  	  MaskElement.prototype.destroy = function () {
  	    this.element = null;
  	    this.globalData = null;
  	    this.maskElement = null;
  	    this.data = null;
  	    this.masksProperties = null;
  	  };

  	  var filtersFactory = function () {
  	    var ob = {};
  	    ob.createFilter = createFilter;
  	    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
  	    function createFilter(filId, skipCoordinates) {
  	      var fil = createNS('filter');
  	      fil.setAttribute('id', filId);
  	      if (skipCoordinates !== true) {
  	        fil.setAttribute('filterUnits', 'objectBoundingBox');
  	        fil.setAttribute('x', '0%');
  	        fil.setAttribute('y', '0%');
  	        fil.setAttribute('width', '100%');
  	        fil.setAttribute('height', '100%');
  	      }
  	      return fil;
  	    }
  	    function createAlphaToLuminanceFilter() {
  	      var feColorMatrix = createNS('feColorMatrix');
  	      feColorMatrix.setAttribute('type', 'matrix');
  	      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  	      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
  	      return feColorMatrix;
  	    }
  	    return ob;
  	  }();

  	  var featureSupport = function () {
  	    var ob = {
  	      maskType: true,
  	      svgLumaHidden: true,
  	      offscreenCanvas: typeof OffscreenCanvas !== 'undefined'
  	    };
  	    if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
  	      ob.maskType = false;
  	    }
  	    if (/firefox/i.test(navigator.userAgent)) {
  	      ob.svgLumaHidden = false;
  	    }
  	    return ob;
  	  }();

  	  var registeredEffects$1 = {};
  	  var idPrefix = 'filter_result_';
  	  function SVGEffects(elem) {
  	    var i;
  	    var source = 'SourceGraphic';
  	    var len = elem.data.ef ? elem.data.ef.length : 0;
  	    var filId = createElementID();
  	    var fil = filtersFactory.createFilter(filId, true);
  	    var count = 0;
  	    this.filters = [];
  	    var filterManager;
  	    for (i = 0; i < len; i += 1) {
  	      filterManager = null;
  	      var type = elem.data.ef[i].ty;
  	      if (registeredEffects$1[type]) {
  	        var Effect = registeredEffects$1[type].effect;
  	        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
  	        source = idPrefix + count;
  	        if (registeredEffects$1[type].countsAsEffect) {
  	          count += 1;
  	        }
  	      }
  	      if (filterManager) {
  	        this.filters.push(filterManager);
  	      }
  	    }
  	    if (count) {
  	      elem.globalData.defs.appendChild(fil);
  	      elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
  	    }
  	    if (this.filters.length) {
  	      elem.addRenderableComponent(this);
  	    }
  	  }
  	  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
  	    var i;
  	    var len = this.filters.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.filters[i].renderFrame(_isFirstFrame);
  	    }
  	  };
  	  SVGEffects.prototype.getEffects = function (type) {
  	    var i;
  	    var len = this.filters.length;
  	    var effects = [];
  	    for (i = 0; i < len; i += 1) {
  	      if (this.filters[i].type === type) {
  	        effects.push(this.filters[i]);
  	      }
  	    }
  	    return effects;
  	  };
  	  function registerEffect$1(id, effect, countsAsEffect) {
  	    registeredEffects$1[id] = {
  	      effect: effect,
  	      countsAsEffect: countsAsEffect
  	    };
  	  }

  	  function SVGBaseElement() {}
  	  SVGBaseElement.prototype = {
  	    initRendererElement: function initRendererElement() {
  	      this.layerElement = createNS('g');
  	    },
  	    createContainerElements: function createContainerElements() {
  	      this.matteElement = createNS('g');
  	      this.transformedElement = this.layerElement;
  	      this.maskedElement = this.layerElement;
  	      this._sizeChanged = false;
  	      var layerElementParent = null;
  	      // If this layer acts as a mask for the following layer
  	      if (this.data.td) {
  	        this.matteMasks = {};
  	        var gg = createNS('g');
  	        gg.setAttribute('id', this.layerId);
  	        gg.appendChild(this.layerElement);
  	        layerElementParent = gg;
  	        this.globalData.defs.appendChild(gg);
  	      } else if (this.data.tt) {
  	        this.matteElement.appendChild(this.layerElement);
  	        layerElementParent = this.matteElement;
  	        this.baseElement = this.matteElement;
  	      } else {
  	        this.baseElement = this.layerElement;
  	      }
  	      if (this.data.ln) {
  	        this.layerElement.setAttribute('id', this.data.ln);
  	      }
  	      if (this.data.cl) {
  	        this.layerElement.setAttribute('class', this.data.cl);
  	      }
  	      // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
  	      if (this.data.ty === 0 && !this.data.hd) {
  	        var cp = createNS('clipPath');
  	        var pt = createNS('path');
  	        pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
  	        var clipId = createElementID();
  	        cp.setAttribute('id', clipId);
  	        cp.appendChild(pt);
  	        this.globalData.defs.appendChild(cp);
  	        if (this.checkMasks()) {
  	          var cpGroup = createNS('g');
  	          cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
  	          cpGroup.appendChild(this.layerElement);
  	          this.transformedElement = cpGroup;
  	          if (layerElementParent) {
  	            layerElementParent.appendChild(this.transformedElement);
  	          } else {
  	            this.baseElement = this.transformedElement;
  	          }
  	        } else {
  	          this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
  	        }
  	      }
  	      if (this.data.bm !== 0) {
  	        this.setBlendMode();
  	      }
  	    },
  	    renderElement: function renderElement() {
  	      if (this.finalTransform._localMatMdf) {
  	        this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());
  	      }
  	      if (this.finalTransform._opMdf) {
  	        this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);
  	      }
  	    },
  	    destroyBaseElement: function destroyBaseElement() {
  	      this.layerElement = null;
  	      this.matteElement = null;
  	      this.maskManager.destroy();
  	    },
  	    getBaseElement: function getBaseElement() {
  	      if (this.data.hd) {
  	        return null;
  	      }
  	      return this.baseElement;
  	    },
  	    createRenderableComponents: function createRenderableComponents() {
  	      this.maskManager = new MaskElement(this.data, this, this.globalData);
  	      this.renderableEffectsManager = new SVGEffects(this);
  	      this.searchEffectTransforms();
  	    },
  	    getMatte: function getMatte(matteType) {
  	      // This should not be a common case. But for backward compatibility, we'll create the matte object.
  	      // It solves animations that have two consecutive layers marked as matte masks.
  	      // Which is an undefined behavior in AE.
  	      if (!this.matteMasks) {
  	        this.matteMasks = {};
  	      }
  	      if (!this.matteMasks[matteType]) {
  	        var id = this.layerId + '_' + matteType;
  	        var filId;
  	        var fil;
  	        var useElement;
  	        var gg;
  	        if (matteType === 1 || matteType === 3) {
  	          var masker = createNS('mask');
  	          masker.setAttribute('id', id);
  	          masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');
  	          useElement = createNS('use');
  	          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
  	          masker.appendChild(useElement);
  	          this.globalData.defs.appendChild(masker);
  	          if (!featureSupport.maskType && matteType === 1) {
  	            masker.setAttribute('mask-type', 'luminance');
  	            filId = createElementID();
  	            fil = filtersFactory.createFilter(filId);
  	            this.globalData.defs.appendChild(fil);
  	            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
  	            gg = createNS('g');
  	            gg.appendChild(useElement);
  	            masker.appendChild(gg);
  	            gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
  	          }
  	        } else if (matteType === 2) {
  	          var maskGroup = createNS('mask');
  	          maskGroup.setAttribute('id', id);
  	          maskGroup.setAttribute('mask-type', 'alpha');
  	          var maskGrouper = createNS('g');
  	          maskGroup.appendChild(maskGrouper);
  	          filId = createElementID();
  	          fil = filtersFactory.createFilter(filId);
  	          /// /
  	          var feCTr = createNS('feComponentTransfer');
  	          feCTr.setAttribute('in', 'SourceGraphic');
  	          fil.appendChild(feCTr);
  	          var feFunc = createNS('feFuncA');
  	          feFunc.setAttribute('type', 'table');
  	          feFunc.setAttribute('tableValues', '1.0 0.0');
  	          feCTr.appendChild(feFunc);
  	          /// /
  	          this.globalData.defs.appendChild(fil);
  	          var alphaRect = createNS('rect');
  	          alphaRect.setAttribute('width', this.comp.data.w);
  	          alphaRect.setAttribute('height', this.comp.data.h);
  	          alphaRect.setAttribute('x', '0');
  	          alphaRect.setAttribute('y', '0');
  	          alphaRect.setAttribute('fill', '#ffffff');
  	          alphaRect.setAttribute('opacity', '0');
  	          maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
  	          maskGrouper.appendChild(alphaRect);
  	          useElement = createNS('use');
  	          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
  	          maskGrouper.appendChild(useElement);
  	          if (!featureSupport.maskType) {
  	            maskGroup.setAttribute('mask-type', 'luminance');
  	            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
  	            gg = createNS('g');
  	            maskGrouper.appendChild(alphaRect);
  	            gg.appendChild(this.layerElement);
  	            maskGrouper.appendChild(gg);
  	          }
  	          this.globalData.defs.appendChild(maskGroup);
  	        }
  	        this.matteMasks[matteType] = id;
  	      }
  	      return this.matteMasks[matteType];
  	    },
  	    setMatte: function setMatte(id) {
  	      if (!this.matteElement) {
  	        return;
  	      }
  	      this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
  	    }
  	  };

  	  /**
  	   * @file
  	   * Handles AE's layer parenting property.
  	   *
  	   */

  	  function HierarchyElement() {}
  	  HierarchyElement.prototype = {
  	    /**
  	       * @function
  	       * Initializes hierarchy properties
  	       *
  	       */
  	    initHierarchy: function initHierarchy() {
  	      // element's parent list
  	      this.hierarchy = [];
  	      // if element is parent of another layer _isParent will be true
  	      this._isParent = false;
  	      this.checkParenting();
  	    },
  	    /**
  	       * @function
  	       * Sets layer's hierarchy.
  	       * @param {array} hierarch
  	       * layer's parent list
  	       *
  	       */
  	    setHierarchy: function setHierarchy(hierarchy) {
  	      this.hierarchy = hierarchy;
  	    },
  	    /**
  	       * @function
  	       * Sets layer as parent.
  	       *
  	       */
  	    setAsParent: function setAsParent() {
  	      this._isParent = true;
  	    },
  	    /**
  	       * @function
  	       * Searches layer's parenting chain
  	       *
  	       */
  	    checkParenting: function checkParenting() {
  	      if (this.data.parent !== undefined) {
  	        this.comp.buildElementParenting(this, this.data.parent, []);
  	      }
  	    }
  	  };

  	  function RenderableDOMElement() {}
  	  (function () {
  	    var _prototype = {
  	      initElement: function initElement(data, globalData, comp) {
  	        this.initFrame();
  	        this.initBaseData(data, globalData, comp);
  	        this.initTransform(data, globalData, comp);
  	        this.initHierarchy();
  	        this.initRenderable();
  	        this.initRendererElement();
  	        this.createContainerElements();
  	        this.createRenderableComponents();
  	        this.createContent();
  	        this.hide();
  	      },
  	      hide: function hide() {
  	        // console.log('HIDE', this);
  	        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
  	          var elem = this.baseElement || this.layerElement;
  	          elem.style.display = 'none';
  	          this.hidden = true;
  	        }
  	      },
  	      show: function show() {
  	        // console.log('SHOW', this);
  	        if (this.isInRange && !this.isTransparent) {
  	          if (!this.data.hd) {
  	            var elem = this.baseElement || this.layerElement;
  	            elem.style.display = 'block';
  	          }
  	          this.hidden = false;
  	          this._isFirstFrame = true;
  	        }
  	      },
  	      renderFrame: function renderFrame() {
  	        // If it is exported as hidden (data.hd === true) no need to render
  	        // If it is not visible no need to render
  	        if (this.data.hd || this.hidden) {
  	          return;
  	        }
  	        this.renderTransform();
  	        this.renderRenderable();
  	        this.renderLocalTransform();
  	        this.renderElement();
  	        this.renderInnerContent();
  	        if (this._isFirstFrame) {
  	          this._isFirstFrame = false;
  	        }
  	      },
  	      renderInnerContent: function renderInnerContent() {},
  	      prepareFrame: function prepareFrame(num) {
  	        this._mdf = false;
  	        this.prepareRenderableFrame(num);
  	        this.prepareProperties(num, this.isInRange);
  	        this.checkTransparency();
  	      },
  	      destroy: function destroy() {
  	        this.innerElem = null;
  	        this.destroyBaseElement();
  	      }
  	    };
  	    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
  	  })();

  	  function IImageElement(data, globalData, comp) {
  	    this.assetData = globalData.getAssetData(data.refId);
  	    if (this.assetData && this.assetData.sid) {
  	      this.assetData = globalData.slotManager.getProp(this.assetData);
  	    }
  	    this.initElement(data, globalData, comp);
  	    this.sourceRect = {
  	      top: 0,
  	      left: 0,
  	      width: this.assetData.w,
  	      height: this.assetData.h
  	    };
  	  }
  	  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
  	  IImageElement.prototype.createContent = function () {
  	    var assetPath = this.globalData.getAssetsPath(this.assetData);
  	    this.innerElem = createNS('image');
  	    this.innerElem.setAttribute('width', this.assetData.w + 'px');
  	    this.innerElem.setAttribute('height', this.assetData.h + 'px');
  	    this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
  	    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
  	    this.layerElement.appendChild(this.innerElem);
  	  };
  	  IImageElement.prototype.sourceRectAtTime = function () {
  	    return this.sourceRect;
  	  };

  	  function ProcessedElement(element, position) {
  	    this.elem = element;
  	    this.pos = position;
  	  }

  	  function IShapeElement() {}
  	  IShapeElement.prototype = {
  	    addShapeToModifiers: function addShapeToModifiers(data) {
  	      var i;
  	      var len = this.shapeModifiers.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.shapeModifiers[i].addShape(data);
  	      }
  	    },
  	    isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
  	      var i = 0;
  	      var len = this.shapeModifiers.length;
  	      while (i < len) {
  	        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
  	          return true;
  	        }
  	      }
  	      return false;
  	    },
  	    renderModifiers: function renderModifiers() {
  	      if (!this.shapeModifiers.length) {
  	        return;
  	      }
  	      var i;
  	      var len = this.shapes.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.shapes[i].sh.reset();
  	      }
  	      len = this.shapeModifiers.length;
  	      var shouldBreakProcess;
  	      for (i = len - 1; i >= 0; i -= 1) {
  	        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
  	        // workaround to fix cases where a repeater resets the shape so the following processes get called twice
  	        // TODO: find a better solution for this
  	        if (shouldBreakProcess) {
  	          break;
  	        }
  	      }
  	    },
  	    searchProcessedElement: function searchProcessedElement(elem) {
  	      var elements = this.processedElements;
  	      var i = 0;
  	      var len = elements.length;
  	      while (i < len) {
  	        if (elements[i].elem === elem) {
  	          return elements[i].pos;
  	        }
  	        i += 1;
  	      }
  	      return 0;
  	    },
  	    addProcessedElement: function addProcessedElement(elem, pos) {
  	      var elements = this.processedElements;
  	      var i = elements.length;
  	      while (i) {
  	        i -= 1;
  	        if (elements[i].elem === elem) {
  	          elements[i].pos = pos;
  	          return;
  	        }
  	      }
  	      elements.push(new ProcessedElement(elem, pos));
  	    },
  	    prepareFrame: function prepareFrame(num) {
  	      this.prepareRenderableFrame(num);
  	      this.prepareProperties(num, this.isInRange);
  	    }
  	  };

  	  var lineCapEnum = {
  	    1: 'butt',
  	    2: 'round',
  	    3: 'square'
  	  };
  	  var lineJoinEnum = {
  	    1: 'miter',
  	    2: 'round',
  	    3: 'bevel'
  	  };

  	  function SVGShapeData(transformers, level, shape) {
  	    this.caches = [];
  	    this.styles = [];
  	    this.transformers = transformers;
  	    this.lStr = '';
  	    this.sh = shape;
  	    this.lvl = level;
  	    // TODO find if there are some cases where _isAnimated can be false.
  	    // For now, since shapes add up with other shapes. They have to be calculated every time.
  	    // One way of finding out is checking if all styles associated to this shape depend only of this shape
  	    this._isAnimated = !!shape.k;
  	    // TODO: commenting this for now since all shapes are animated
  	    var i = 0;
  	    var len = transformers.length;
  	    while (i < len) {
  	      if (transformers[i].mProps.dynamicProperties.length) {
  	        this._isAnimated = true;
  	        break;
  	      }
  	      i += 1;
  	    }
  	  }
  	  SVGShapeData.prototype.setAsAnimated = function () {
  	    this._isAnimated = true;
  	  };

  	  function SVGStyleData(data, level) {
  	    this.data = data;
  	    this.type = data.ty;
  	    this.d = '';
  	    this.lvl = level;
  	    this._mdf = false;
  	    this.closed = data.hd === true;
  	    this.pElem = createNS('path');
  	    this.msElem = null;
  	  }
  	  SVGStyleData.prototype.reset = function () {
  	    this.d = '';
  	    this._mdf = false;
  	  };

  	  function DashProperty(elem, data, renderer, container) {
  	    this.elem = elem;
  	    this.frameId = -1;
  	    this.dataProps = createSizedArray(data.length);
  	    this.renderer = renderer;
  	    this.k = false;
  	    this.dashStr = '';
  	    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
  	    this.dashoffset = createTypedArray('float32', 1);
  	    this.initDynamicPropertyContainer(container);
  	    var i;
  	    var len = data.length || 0;
  	    var prop;
  	    for (i = 0; i < len; i += 1) {
  	      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
  	      this.k = prop.k || this.k;
  	      this.dataProps[i] = {
  	        n: data[i].n,
  	        p: prop
  	      };
  	    }
  	    if (!this.k) {
  	      this.getValue(true);
  	    }
  	    this._isAnimated = this.k;
  	  }
  	  DashProperty.prototype.getValue = function (forceRender) {
  	    if (this.elem.globalData.frameId === this.frameId && !forceRender) {
  	      return;
  	    }
  	    this.frameId = this.elem.globalData.frameId;
  	    this.iterateDynamicProperties();
  	    this._mdf = this._mdf || forceRender;
  	    if (this._mdf) {
  	      var i = 0;
  	      var len = this.dataProps.length;
  	      if (this.renderer === 'svg') {
  	        this.dashStr = '';
  	      }
  	      for (i = 0; i < len; i += 1) {
  	        if (this.dataProps[i].n !== 'o') {
  	          if (this.renderer === 'svg') {
  	            this.dashStr += ' ' + this.dataProps[i].p.v;
  	          } else {
  	            this.dashArray[i] = this.dataProps[i].p.v;
  	          }
  	        } else {
  	          this.dashoffset[0] = this.dataProps[i].p.v;
  	        }
  	      }
  	    }
  	  };
  	  extendPrototype([DynamicPropertyContainer], DashProperty);

  	  function SVGStrokeStyleData(elem, data, styleOb) {
  	    this.initDynamicPropertyContainer(elem);
  	    this.getValue = this.iterateDynamicProperties;
  	    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  	    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  	    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  	    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  	    this.style = styleOb;
  	    this._isAnimated = !!this._isAnimated;
  	  }
  	  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

  	  function SVGFillStyleData(elem, data, styleOb) {
  	    this.initDynamicPropertyContainer(elem);
  	    this.getValue = this.iterateDynamicProperties;
  	    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  	    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  	    this.style = styleOb;
  	  }
  	  extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

  	  function SVGNoStyleData(elem, data, styleOb) {
  	    this.initDynamicPropertyContainer(elem);
  	    this.getValue = this.iterateDynamicProperties;
  	    this.style = styleOb;
  	  }
  	  extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

  	  function GradientProperty(elem, data, container) {
  	    this.data = data;
  	    this.c = createTypedArray('uint8c', data.p * 4);
  	    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
  	    this.o = createTypedArray('float32', cLength);
  	    this._cmdf = false;
  	    this._omdf = false;
  	    this._collapsable = this.checkCollapsable();
  	    this._hasOpacity = cLength;
  	    this.initDynamicPropertyContainer(container);
  	    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
  	    this.k = this.prop.k;
  	    this.getValue(true);
  	  }
  	  GradientProperty.prototype.comparePoints = function (values, points) {
  	    var i = 0;
  	    var len = this.o.length / 2;
  	    var diff;
  	    while (i < len) {
  	      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
  	      if (diff > 0.01) {
  	        return false;
  	      }
  	      i += 1;
  	    }
  	    return true;
  	  };
  	  GradientProperty.prototype.checkCollapsable = function () {
  	    if (this.o.length / 2 !== this.c.length / 4) {
  	      return false;
  	    }
  	    if (this.data.k.k[0].s) {
  	      var i = 0;
  	      var len = this.data.k.k.length;
  	      while (i < len) {
  	        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
  	          return false;
  	        }
  	        i += 1;
  	      }
  	    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
  	      return false;
  	    }
  	    return true;
  	  };
  	  GradientProperty.prototype.getValue = function (forceRender) {
  	    this.prop.getValue();
  	    this._mdf = false;
  	    this._cmdf = false;
  	    this._omdf = false;
  	    if (this.prop._mdf || forceRender) {
  	      var i;
  	      var len = this.data.p * 4;
  	      var mult;
  	      var val;
  	      for (i = 0; i < len; i += 1) {
  	        mult = i % 4 === 0 ? 100 : 255;
  	        val = Math.round(this.prop.v[i] * mult);
  	        if (this.c[i] !== val) {
  	          this.c[i] = val;
  	          this._cmdf = !forceRender;
  	        }
  	      }
  	      if (this.o.length) {
  	        len = this.prop.v.length;
  	        for (i = this.data.p * 4; i < len; i += 1) {
  	          mult = i % 2 === 0 ? 100 : 1;
  	          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
  	          if (this.o[i - this.data.p * 4] !== val) {
  	            this.o[i - this.data.p * 4] = val;
  	            this._omdf = !forceRender;
  	          }
  	        }
  	      }
  	      this._mdf = !forceRender;
  	    }
  	  };
  	  extendPrototype([DynamicPropertyContainer], GradientProperty);

  	  function SVGGradientFillStyleData(elem, data, styleOb) {
  	    this.initDynamicPropertyContainer(elem);
  	    this.getValue = this.iterateDynamicProperties;
  	    this.initGradientData(elem, data, styleOb);
  	  }
  	  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
  	    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  	    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
  	    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
  	    this.h = PropertyFactory.getProp(elem, data.h || {
  	      k: 0
  	    }, 0, 0.01, this);
  	    this.a = PropertyFactory.getProp(elem, data.a || {
  	      k: 0
  	    }, 0, degToRads, this);
  	    this.g = new GradientProperty(elem, data.g, this);
  	    this.style = styleOb;
  	    this.stops = [];
  	    this.setGradientData(styleOb.pElem, data);
  	    this.setGradientOpacity(data, styleOb);
  	    this._isAnimated = !!this._isAnimated;
  	  };
  	  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
  	    var gradientId = createElementID();
  	    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
  	    gfill.setAttribute('id', gradientId);
  	    gfill.setAttribute('spreadMethod', 'pad');
  	    gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
  	    var stops = [];
  	    var stop;
  	    var j;
  	    var jLen;
  	    jLen = data.g.p * 4;
  	    for (j = 0; j < jLen; j += 4) {
  	      stop = createNS('stop');
  	      gfill.appendChild(stop);
  	      stops.push(stop);
  	    }
  	    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');
  	    this.gf = gfill;
  	    this.cst = stops;
  	  };
  	  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
  	    if (this.g._hasOpacity && !this.g._collapsable) {
  	      var stop;
  	      var j;
  	      var jLen;
  	      var mask = createNS('mask');
  	      var maskElement = createNS('path');
  	      mask.appendChild(maskElement);
  	      var opacityId = createElementID();
  	      var maskId = createElementID();
  	      mask.setAttribute('id', maskId);
  	      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
  	      opFill.setAttribute('id', opacityId);
  	      opFill.setAttribute('spreadMethod', 'pad');
  	      opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
  	      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
  	      var stops = this.stops;
  	      for (j = data.g.p * 4; j < jLen; j += 2) {
  	        stop = createNS('stop');
  	        stop.setAttribute('stop-color', 'rgb(255,255,255)');
  	        opFill.appendChild(stop);
  	        stops.push(stop);
  	      }
  	      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');
  	      if (data.ty === 'gs') {
  	        maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
  	        maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
  	        if (data.lj === 1) {
  	          maskElement.setAttribute('stroke-miterlimit', data.ml);
  	        }
  	      }
  	      this.of = opFill;
  	      this.ms = mask;
  	      this.ost = stops;
  	      this.maskId = maskId;
  	      styleOb.msElem = maskElement;
  	    }
  	  };
  	  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

  	  function SVGGradientStrokeStyleData(elem, data, styleOb) {
  	    this.initDynamicPropertyContainer(elem);
  	    this.getValue = this.iterateDynamicProperties;
  	    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  	    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  	    this.initGradientData(elem, data, styleOb);
  	    this._isAnimated = !!this._isAnimated;
  	  }
  	  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

  	  function ShapeGroupData() {
  	    this.it = [];
  	    this.prevViewData = [];
  	    this.gr = createNS('g');
  	  }

  	  function SVGTransformData(mProps, op, container) {
  	    this.transform = {
  	      mProps: mProps,
  	      op: op,
  	      container: container
  	    };
  	    this.elements = [];
  	    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
  	  }

  	  var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
  	    if (length === 0) {
  	      return '';
  	    }
  	    var _o = pathNodes.o;
  	    var _i = pathNodes.i;
  	    var _v = pathNodes.v;
  	    var i;
  	    var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
  	    for (i = 1; i < length; i += 1) {
  	      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
  	    }
  	    if (closed && length) {
  	      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
  	      shapeString += 'z';
  	    }
  	    return shapeString;
  	  };

  	  var SVGElementsRenderer = function () {
  	    var _identityMatrix = new Matrix();
  	    var _matrixHelper = new Matrix();
  	    var ob = {
  	      createRenderFunction: createRenderFunction
  	    };
  	    function createRenderFunction(data) {
  	      switch (data.ty) {
  	        case 'fl':
  	          return renderFill;
  	        case 'gf':
  	          return renderGradient;
  	        case 'gs':
  	          return renderGradientStroke;
  	        case 'st':
  	          return renderStroke;
  	        case 'sh':
  	        case 'el':
  	        case 'rc':
  	        case 'sr':
  	          return renderPath;
  	        case 'tr':
  	          return renderContentTransform;
  	        case 'no':
  	          return renderNoop;
  	        default:
  	          return null;
  	      }
  	    }
  	    function renderContentTransform(styleData, itemData, isFirstFrame) {
  	      if (isFirstFrame || itemData.transform.op._mdf) {
  	        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
  	      }
  	      if (isFirstFrame || itemData.transform.mProps._mdf) {
  	        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
  	      }
  	    }
  	    function renderNoop() {}
  	    function renderPath(styleData, itemData, isFirstFrame) {
  	      var j;
  	      var jLen;
  	      var pathStringTransformed;
  	      var redraw;
  	      var pathNodes;
  	      var l;
  	      var lLen = itemData.styles.length;
  	      var lvl = itemData.lvl;
  	      var paths;
  	      var mat;
  	      var iterations;
  	      var k;
  	      for (l = 0; l < lLen; l += 1) {
  	        redraw = itemData.sh._mdf || isFirstFrame;
  	        if (itemData.styles[l].lvl < lvl) {
  	          mat = _matrixHelper.reset();
  	          iterations = lvl - itemData.styles[l].lvl;
  	          k = itemData.transformers.length - 1;
  	          while (!redraw && iterations > 0) {
  	            redraw = itemData.transformers[k].mProps._mdf || redraw;
  	            iterations -= 1;
  	            k -= 1;
  	          }
  	          if (redraw) {
  	            iterations = lvl - itemData.styles[l].lvl;
  	            k = itemData.transformers.length - 1;
  	            while (iterations > 0) {
  	              mat.multiply(itemData.transformers[k].mProps.v);
  	              iterations -= 1;
  	              k -= 1;
  	            }
  	          }
  	        } else {
  	          mat = _identityMatrix;
  	        }
  	        paths = itemData.sh.paths;
  	        jLen = paths._length;
  	        if (redraw) {
  	          pathStringTransformed = '';
  	          for (j = 0; j < jLen; j += 1) {
  	            pathNodes = paths.shapes[j];
  	            if (pathNodes && pathNodes._length) {
  	              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
  	            }
  	          }
  	          itemData.caches[l] = pathStringTransformed;
  	        } else {
  	          pathStringTransformed = itemData.caches[l];
  	        }
  	        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
  	        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
  	      }
  	    }
  	    function renderFill(styleData, itemData, isFirstFrame) {
  	      var styleElem = itemData.style;
  	      if (itemData.c._mdf || isFirstFrame) {
  	        styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
  	      }
  	      if (itemData.o._mdf || isFirstFrame) {
  	        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
  	      }
  	    }
  	    function renderGradientStroke(styleData, itemData, isFirstFrame) {
  	      renderGradient(styleData, itemData, isFirstFrame);
  	      renderStroke(styleData, itemData, isFirstFrame);
  	    }
  	    function renderGradient(styleData, itemData, isFirstFrame) {
  	      var gfill = itemData.gf;
  	      var hasOpacity = itemData.g._hasOpacity;
  	      var pt1 = itemData.s.v;
  	      var pt2 = itemData.e.v;
  	      if (itemData.o._mdf || isFirstFrame) {
  	        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
  	        itemData.style.pElem.setAttribute(attr, itemData.o.v);
  	      }
  	      if (itemData.s._mdf || isFirstFrame) {
  	        var attr1 = styleData.t === 1 ? 'x1' : 'cx';
  	        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
  	        gfill.setAttribute(attr1, pt1[0]);
  	        gfill.setAttribute(attr2, pt1[1]);
  	        if (hasOpacity && !itemData.g._collapsable) {
  	          itemData.of.setAttribute(attr1, pt1[0]);
  	          itemData.of.setAttribute(attr2, pt1[1]);
  	        }
  	      }
  	      var stops;
  	      var i;
  	      var len;
  	      var stop;
  	      if (itemData.g._cmdf || isFirstFrame) {
  	        stops = itemData.cst;
  	        var cValues = itemData.g.c;
  	        len = stops.length;
  	        for (i = 0; i < len; i += 1) {
  	          stop = stops[i];
  	          stop.setAttribute('offset', cValues[i * 4] + '%');
  	          stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
  	        }
  	      }
  	      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
  	        var oValues = itemData.g.o;
  	        if (itemData.g._collapsable) {
  	          stops = itemData.cst;
  	        } else {
  	          stops = itemData.ost;
  	        }
  	        len = stops.length;
  	        for (i = 0; i < len; i += 1) {
  	          stop = stops[i];
  	          if (!itemData.g._collapsable) {
  	            stop.setAttribute('offset', oValues[i * 2] + '%');
  	          }
  	          stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
  	        }
  	      }
  	      if (styleData.t === 1) {
  	        if (itemData.e._mdf || isFirstFrame) {
  	          gfill.setAttribute('x2', pt2[0]);
  	          gfill.setAttribute('y2', pt2[1]);
  	          if (hasOpacity && !itemData.g._collapsable) {
  	            itemData.of.setAttribute('x2', pt2[0]);
  	            itemData.of.setAttribute('y2', pt2[1]);
  	          }
  	        }
  	      } else {
  	        var rad;
  	        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
  	          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
  	          gfill.setAttribute('r', rad);
  	          if (hasOpacity && !itemData.g._collapsable) {
  	            itemData.of.setAttribute('r', rad);
  	          }
  	        }
  	        if (itemData.s._mdf || itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
  	          if (!rad) {
  	            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
  	          }
  	          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
  	          var percent = itemData.h.v;
  	          if (percent >= 1) {
  	            percent = 0.99;
  	          } else if (percent <= -1) {
  	            percent = -0.99;
  	          }
  	          var dist = rad * percent;
  	          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
  	          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
  	          gfill.setAttribute('fx', x);
  	          gfill.setAttribute('fy', y);
  	          if (hasOpacity && !itemData.g._collapsable) {
  	            itemData.of.setAttribute('fx', x);
  	            itemData.of.setAttribute('fy', y);
  	          }
  	        }
  	        // gfill.setAttribute('fy','200');
  	      }
  	    }
  	    function renderStroke(styleData, itemData, isFirstFrame) {
  	      var styleElem = itemData.style;
  	      var d = itemData.d;
  	      if (d && (d._mdf || isFirstFrame) && d.dashStr) {
  	        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
  	        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
  	      }
  	      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
  	        styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
  	      }
  	      if (itemData.o._mdf || isFirstFrame) {
  	        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
  	      }
  	      if (itemData.w._mdf || isFirstFrame) {
  	        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
  	        if (styleElem.msElem) {
  	          styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
  	        }
  	      }
  	    }
  	    return ob;
  	  }();

  	  function SVGShapeElement(data, globalData, comp) {
  	    // List of drawable elements
  	    this.shapes = [];
  	    // Full shape data
  	    this.shapesData = data.shapes;
  	    // List of styles that will be applied to shapes
  	    this.stylesList = [];
  	    // List of modifiers that will be applied to shapes
  	    this.shapeModifiers = [];
  	    // List of items in shape tree
  	    this.itemsData = [];
  	    // List of items in previous shape tree
  	    this.processedElements = [];
  	    // List of animated components
  	    this.animatedContents = [];
  	    this.initElement(data, globalData, comp);
  	    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  	    // List of elements that have been created
  	    this.prevViewData = [];
  	    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  	  }
  	  extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
  	  SVGShapeElement.prototype.initSecondaryElement = function () {};
  	  SVGShapeElement.prototype.identityMatrix = new Matrix();
  	  SVGShapeElement.prototype.buildExpressionInterface = function () {};
  	  SVGShapeElement.prototype.createContent = function () {
  	    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  	    this.filterUniqueShapes();
  	  };

  	  /*
  	  This method searches for multiple shapes that affect a single element and one of them is animated
  	  */
  	  SVGShapeElement.prototype.filterUniqueShapes = function () {
  	    var i;
  	    var len = this.shapes.length;
  	    var shape;
  	    var j;
  	    var jLen = this.stylesList.length;
  	    var style;
  	    var tempShapes = [];
  	    var areAnimated = false;
  	    for (j = 0; j < jLen; j += 1) {
  	      style = this.stylesList[j];
  	      areAnimated = false;
  	      tempShapes.length = 0;
  	      for (i = 0; i < len; i += 1) {
  	        shape = this.shapes[i];
  	        if (shape.styles.indexOf(style) !== -1) {
  	          tempShapes.push(shape);
  	          areAnimated = shape._isAnimated || areAnimated;
  	        }
  	      }
  	      if (tempShapes.length > 1 && areAnimated) {
  	        this.setShapesAsAnimated(tempShapes);
  	      }
  	    }
  	  };
  	  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
  	    var i;
  	    var len = shapes.length;
  	    for (i = 0; i < len; i += 1) {
  	      shapes[i].setAsAnimated();
  	    }
  	  };
  	  SVGShapeElement.prototype.createStyleElement = function (data, level) {
  	    // TODO: prevent drawing of hidden styles
  	    var elementData;
  	    var styleOb = new SVGStyleData(data, level);
  	    var pathElement = styleOb.pElem;
  	    if (data.ty === 'st') {
  	      elementData = new SVGStrokeStyleData(this, data, styleOb);
  	    } else if (data.ty === 'fl') {
  	      elementData = new SVGFillStyleData(this, data, styleOb);
  	    } else if (data.ty === 'gf' || data.ty === 'gs') {
  	      var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
  	      elementData = new GradientConstructor(this, data, styleOb);
  	      this.globalData.defs.appendChild(elementData.gf);
  	      if (elementData.maskId) {
  	        this.globalData.defs.appendChild(elementData.ms);
  	        this.globalData.defs.appendChild(elementData.of);
  	        pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');
  	      }
  	    } else if (data.ty === 'no') {
  	      elementData = new SVGNoStyleData(this, data, styleOb);
  	    }
  	    if (data.ty === 'st' || data.ty === 'gs') {
  	      pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
  	      pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
  	      pathElement.setAttribute('fill-opacity', '0');
  	      if (data.lj === 1) {
  	        pathElement.setAttribute('stroke-miterlimit', data.ml);
  	      }
  	    }
  	    if (data.r === 2) {
  	      pathElement.setAttribute('fill-rule', 'evenodd');
  	    }
  	    if (data.ln) {
  	      pathElement.setAttribute('id', data.ln);
  	    }
  	    if (data.cl) {
  	      pathElement.setAttribute('class', data.cl);
  	    }
  	    if (data.bm) {
  	      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
  	    }
  	    this.stylesList.push(styleOb);
  	    this.addToAnimatedContents(data, elementData);
  	    return elementData;
  	  };
  	  SVGShapeElement.prototype.createGroupElement = function (data) {
  	    var elementData = new ShapeGroupData();
  	    if (data.ln) {
  	      elementData.gr.setAttribute('id', data.ln);
  	    }
  	    if (data.cl) {
  	      elementData.gr.setAttribute('class', data.cl);
  	    }
  	    if (data.bm) {
  	      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
  	    }
  	    return elementData;
  	  };
  	  SVGShapeElement.prototype.createTransformElement = function (data, container) {
  	    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
  	    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
  	    this.addToAnimatedContents(data, elementData);
  	    return elementData;
  	  };
  	  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
  	    var ty = 4;
  	    if (data.ty === 'rc') {
  	      ty = 5;
  	    } else if (data.ty === 'el') {
  	      ty = 6;
  	    } else if (data.ty === 'sr') {
  	      ty = 7;
  	    }
  	    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
  	    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
  	    this.shapes.push(elementData);
  	    this.addShapeToModifiers(elementData);
  	    this.addToAnimatedContents(data, elementData);
  	    return elementData;
  	  };
  	  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
  	    var i = 0;
  	    var len = this.animatedContents.length;
  	    while (i < len) {
  	      if (this.animatedContents[i].element === element) {
  	        return;
  	      }
  	      i += 1;
  	    }
  	    this.animatedContents.push({
  	      fn: SVGElementsRenderer.createRenderFunction(data),
  	      element: element,
  	      data: data
  	    });
  	  };
  	  SVGShapeElement.prototype.setElementStyles = function (elementData) {
  	    var arr = elementData.styles;
  	    var j;
  	    var jLen = this.stylesList.length;
  	    for (j = 0; j < jLen; j += 1) {
  	      if (arr.indexOf(this.stylesList[j]) === -1 && !this.stylesList[j].closed) {
  	        arr.push(this.stylesList[j]);
  	      }
  	    }
  	  };
  	  SVGShapeElement.prototype.reloadShapes = function () {
  	    this._isFirstFrame = true;
  	    var i;
  	    var len = this.itemsData.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.prevViewData[i] = this.itemsData[i];
  	    }
  	    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  	    this.filterUniqueShapes();
  	    len = this.dynamicProperties.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.dynamicProperties[i].getValue();
  	    }
  	    this.renderModifiers();
  	  };
  	  SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
  	    var ownTransformers = [].concat(transformers);
  	    var i;
  	    var len = arr.length - 1;
  	    var j;
  	    var jLen;
  	    var ownStyles = [];
  	    var ownModifiers = [];
  	    var currentTransform;
  	    var modifier;
  	    var processedPos;
  	    for (i = len; i >= 0; i -= 1) {
  	      processedPos = this.searchProcessedElement(arr[i]);
  	      if (!processedPos) {
  	        arr[i]._render = render;
  	      } else {
  	        itemsData[i] = prevViewData[processedPos - 1];
  	      }
  	      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createStyleElement(arr[i], level);
  	        } else {
  	          itemsData[i].style.closed = arr[i].hd;
  	        }
  	        if (arr[i]._render) {
  	          if (itemsData[i].style.pElem.parentNode !== container) {
  	            container.appendChild(itemsData[i].style.pElem);
  	          }
  	        }
  	        ownStyles.push(itemsData[i].style);
  	      } else if (arr[i].ty === 'gr') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createGroupElement(arr[i]);
  	        } else {
  	          jLen = itemsData[i].it.length;
  	          for (j = 0; j < jLen; j += 1) {
  	            itemsData[i].prevViewData[j] = itemsData[i].it[j];
  	          }
  	        }
  	        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
  	        if (arr[i]._render) {
  	          if (itemsData[i].gr.parentNode !== container) {
  	            container.appendChild(itemsData[i].gr);
  	          }
  	        }
  	      } else if (arr[i].ty === 'tr') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createTransformElement(arr[i], container);
  	        }
  	        currentTransform = itemsData[i].transform;
  	        ownTransformers.push(currentTransform);
  	      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
  	        }
  	        this.setElementStyles(itemsData[i]);
  	      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
  	        if (!processedPos) {
  	          modifier = ShapeModifiers.getModifier(arr[i].ty);
  	          modifier.init(this, arr[i]);
  	          itemsData[i] = modifier;
  	          this.shapeModifiers.push(modifier);
  	        } else {
  	          modifier = itemsData[i];
  	          modifier.closed = false;
  	        }
  	        ownModifiers.push(modifier);
  	      } else if (arr[i].ty === 'rp') {
  	        if (!processedPos) {
  	          modifier = ShapeModifiers.getModifier(arr[i].ty);
  	          itemsData[i] = modifier;
  	          modifier.init(this, arr, i, itemsData);
  	          this.shapeModifiers.push(modifier);
  	          render = false;
  	        } else {
  	          modifier = itemsData[i];
  	          modifier.closed = true;
  	        }
  	        ownModifiers.push(modifier);
  	      }
  	      this.addProcessedElement(arr[i], i + 1);
  	    }
  	    len = ownStyles.length;
  	    for (i = 0; i < len; i += 1) {
  	      ownStyles[i].closed = true;
  	    }
  	    len = ownModifiers.length;
  	    for (i = 0; i < len; i += 1) {
  	      ownModifiers[i].closed = true;
  	    }
  	  };
  	  SVGShapeElement.prototype.renderInnerContent = function () {
  	    this.renderModifiers();
  	    var i;
  	    var len = this.stylesList.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.stylesList[i].reset();
  	    }
  	    this.renderShape();
  	    for (i = 0; i < len; i += 1) {
  	      if (this.stylesList[i]._mdf || this._isFirstFrame) {
  	        if (this.stylesList[i].msElem) {
  	          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
  	          // Adding M0 0 fixes same mask bug on all browsers
  	          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
  	        }
  	        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
  	      }
  	    }
  	  };
  	  SVGShapeElement.prototype.renderShape = function () {
  	    var i;
  	    var len = this.animatedContents.length;
  	    var animatedContent;
  	    for (i = 0; i < len; i += 1) {
  	      animatedContent = this.animatedContents[i];
  	      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
  	        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
  	      }
  	    }
  	  };
  	  SVGShapeElement.prototype.destroy = function () {
  	    this.destroyBaseElement();
  	    this.shapesData = null;
  	    this.itemsData = null;
  	  };

  	  function LetterProps(o, sw, sc, fc, m, p) {
  	    this.o = o;
  	    this.sw = sw;
  	    this.sc = sc;
  	    this.fc = fc;
  	    this.m = m;
  	    this.p = p;
  	    this._mdf = {
  	      o: true,
  	      sw: !!sw,
  	      sc: !!sc,
  	      fc: !!fc,
  	      m: true,
  	      p: true
  	    };
  	  }
  	  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
  	    this._mdf.o = false;
  	    this._mdf.sw = false;
  	    this._mdf.sc = false;
  	    this._mdf.fc = false;
  	    this._mdf.m = false;
  	    this._mdf.p = false;
  	    var updated = false;
  	    if (this.o !== o) {
  	      this.o = o;
  	      this._mdf.o = true;
  	      updated = true;
  	    }
  	    if (this.sw !== sw) {
  	      this.sw = sw;
  	      this._mdf.sw = true;
  	      updated = true;
  	    }
  	    if (this.sc !== sc) {
  	      this.sc = sc;
  	      this._mdf.sc = true;
  	      updated = true;
  	    }
  	    if (this.fc !== fc) {
  	      this.fc = fc;
  	      this._mdf.fc = true;
  	      updated = true;
  	    }
  	    if (this.m !== m) {
  	      this.m = m;
  	      this._mdf.m = true;
  	      updated = true;
  	    }
  	    if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
  	      this.p = p;
  	      this._mdf.p = true;
  	      updated = true;
  	    }
  	    return updated;
  	  };

  	  function TextProperty(elem, data) {
  	    this._frameId = initialDefaultFrame;
  	    this.pv = '';
  	    this.v = '';
  	    this.kf = false;
  	    this._isFirstFrame = true;
  	    this._mdf = false;
  	    if (data.d && data.d.sid) {
  	      data.d = elem.globalData.slotManager.getProp(data.d);
  	    }
  	    this.data = data;
  	    this.elem = elem;
  	    this.comp = this.elem.comp;
  	    this.keysIndex = 0;
  	    this.canResize = false;
  	    this.minimumFontSize = 1;
  	    this.effectsSequence = [];
  	    this.currentData = {
  	      ascent: 0,
  	      boxWidth: this.defaultBoxWidth,
  	      f: '',
  	      fStyle: '',
  	      fWeight: '',
  	      fc: '',
  	      j: '',
  	      justifyOffset: '',
  	      l: [],
  	      lh: 0,
  	      lineWidths: [],
  	      ls: '',
  	      of: '',
  	      s: '',
  	      sc: '',
  	      sw: 0,
  	      t: 0,
  	      tr: 0,
  	      sz: 0,
  	      ps: null,
  	      fillColorAnim: false,
  	      strokeColorAnim: false,
  	      strokeWidthAnim: false,
  	      yOffset: 0,
  	      finalSize: 0,
  	      finalText: [],
  	      finalLineHeight: 0,
  	      __complete: false
  	    };
  	    this.copyData(this.currentData, this.data.d.k[0].s);
  	    if (!this.searchProperty()) {
  	      this.completeTextData(this.currentData);
  	    }
  	  }
  	  TextProperty.prototype.defaultBoxWidth = [0, 0];
  	  TextProperty.prototype.copyData = function (obj, data) {
  	    for (var s in data) {
  	      if (Object.prototype.hasOwnProperty.call(data, s)) {
  	        obj[s] = data[s];
  	      }
  	    }
  	    return obj;
  	  };
  	  TextProperty.prototype.setCurrentData = function (data) {
  	    if (!data.__complete) {
  	      this.completeTextData(data);
  	    }
  	    this.currentData = data;
  	    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
  	    this._mdf = true;
  	  };
  	  TextProperty.prototype.searchProperty = function () {
  	    return this.searchKeyframes();
  	  };
  	  TextProperty.prototype.searchKeyframes = function () {
  	    this.kf = this.data.d.k.length > 1;
  	    if (this.kf) {
  	      this.addEffect(this.getKeyframeValue.bind(this));
  	    }
  	    return this.kf;
  	  };
  	  TextProperty.prototype.addEffect = function (effectFunction) {
  	    this.effectsSequence.push(effectFunction);
  	    this.elem.addDynamicProperty(this);
  	  };
  	  TextProperty.prototype.getValue = function (_finalValue) {
  	    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
  	      return;
  	    }
  	    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
  	    var currentValue = this.currentData;
  	    var currentIndex = this.keysIndex;
  	    if (this.lock) {
  	      this.setCurrentData(this.currentData);
  	      return;
  	    }
  	    this.lock = true;
  	    this._mdf = false;
  	    var i;
  	    var len = this.effectsSequence.length;
  	    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
  	    for (i = 0; i < len; i += 1) {
  	      // Checking if index changed to prevent creating a new object every time the expression updates.
  	      if (currentIndex !== this.keysIndex) {
  	        finalValue = this.effectsSequence[i](finalValue, finalValue.t);
  	      } else {
  	        finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
  	      }
  	    }
  	    if (currentValue !== finalValue) {
  	      this.setCurrentData(finalValue);
  	    }
  	    this.v = this.currentData;
  	    this.pv = this.v;
  	    this.lock = false;
  	    this.frameId = this.elem.globalData.frameId;
  	  };
  	  TextProperty.prototype.getKeyframeValue = function () {
  	    var textKeys = this.data.d.k;
  	    var frameNum = this.elem.comp.renderedFrame;
  	    var i = 0;
  	    var len = textKeys.length;
  	    while (i <= len - 1) {
  	      if (i === len - 1 || textKeys[i + 1].t > frameNum) {
  	        break;
  	      }
  	      i += 1;
  	    }
  	    if (this.keysIndex !== i) {
  	      this.keysIndex = i;
  	    }
  	    return this.data.d.k[this.keysIndex].s;
  	  };
  	  TextProperty.prototype.buildFinalText = function (text) {
  	    var charactersArray = [];
  	    var i = 0;
  	    var len = text.length;
  	    var charCode;
  	    var secondCharCode;
  	    var shouldCombine = false;
  	    var shouldCombineNext = false;
  	    var currentChars = '';
  	    while (i < len) {
  	      shouldCombine = shouldCombineNext;
  	      shouldCombineNext = false;
  	      charCode = text.charCodeAt(i);
  	      currentChars = text.charAt(i);
  	      if (FontManager.isCombinedCharacter(charCode)) {
  	        shouldCombine = true;
  	        // It's a potential surrogate pair (this is the High surrogate)
  	      } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
  	        if (FontManager.isRegionalFlag(text, i)) {
  	          currentChars = text.substr(i, 14);
  	        } else {
  	          secondCharCode = text.charCodeAt(i + 1);
  	          // It's a surrogate pair (this is the Low surrogate)
  	          if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
  	            if (FontManager.isModifier(charCode, secondCharCode)) {
  	              currentChars = text.substr(i, 2);
  	              shouldCombine = true;
  	            } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {
  	              currentChars = text.substr(i, 4);
  	            } else {
  	              currentChars = text.substr(i, 2);
  	            }
  	          }
  	        }
  	      } else if (charCode > 0xDBFF) {
  	        secondCharCode = text.charCodeAt(i + 1);
  	        if (FontManager.isVariationSelector(charCode)) {
  	          shouldCombine = true;
  	        }
  	      } else if (FontManager.isZeroWidthJoiner(charCode)) {
  	        shouldCombine = true;
  	        shouldCombineNext = true;
  	      }
  	      if (shouldCombine) {
  	        charactersArray[charactersArray.length - 1] += currentChars;
  	        shouldCombine = false;
  	      } else {
  	        charactersArray.push(currentChars);
  	      }
  	      i += currentChars.length;
  	    }
  	    return charactersArray;
  	  };
  	  TextProperty.prototype.completeTextData = function (documentData) {
  	    documentData.__complete = true;
  	    var fontManager = this.elem.globalData.fontManager;
  	    var data = this.data;
  	    var letters = [];
  	    var i;
  	    var len;
  	    var newLineFlag;
  	    var index = 0;
  	    var val;
  	    var anchorGrouping = data.m.g;
  	    var currentSize = 0;
  	    var currentPos = 0;
  	    var currentLine = 0;
  	    var lineWidths = [];
  	    var lineWidth = 0;
  	    var maxLineWidth = 0;
  	    var j;
  	    var jLen;
  	    var fontData = fontManager.getFontByName(documentData.f);
  	    var charData;
  	    var cLength = 0;
  	    var fontProps = getFontProperties(fontData);
  	    documentData.fWeight = fontProps.weight;
  	    documentData.fStyle = fontProps.style;
  	    documentData.finalSize = documentData.s;
  	    documentData.finalText = this.buildFinalText(documentData.t);
  	    len = documentData.finalText.length;
  	    documentData.finalLineHeight = documentData.lh;
  	    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
  	    var charCode;
  	    if (documentData.sz) {
  	      var flag = true;
  	      var boxWidth = documentData.sz[0];
  	      var boxHeight = documentData.sz[1];
  	      var currentHeight;
  	      var finalText;
  	      while (flag) {
  	        finalText = this.buildFinalText(documentData.t);
  	        currentHeight = 0;
  	        lineWidth = 0;
  	        len = finalText.length;
  	        trackingOffset = documentData.tr / 1000 * documentData.finalSize;
  	        var lastSpaceIndex = -1;
  	        for (i = 0; i < len; i += 1) {
  	          charCode = finalText[i].charCodeAt(0);
  	          newLineFlag = false;
  	          if (finalText[i] === ' ') {
  	            lastSpaceIndex = i;
  	          } else if (charCode === 13 || charCode === 3) {
  	            lineWidth = 0;
  	            newLineFlag = true;
  	            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
  	          }
  	          if (fontManager.chars) {
  	            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
  	            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
  	          } else {
  	            // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
  	            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
  	          }
  	          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
  	            if (lastSpaceIndex === -1) {
  	              len += 1;
  	            } else {
  	              i = lastSpaceIndex;
  	            }
  	            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
  	            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
  	            // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
  	            lastSpaceIndex = -1;
  	            lineWidth = 0;
  	          } else {
  	            lineWidth += cLength;
  	            lineWidth += trackingOffset;
  	          }
  	        }
  	        currentHeight += fontData.ascent * documentData.finalSize / 100;
  	        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
  	          documentData.finalSize -= 1;
  	          documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
  	        } else {
  	          documentData.finalText = finalText;
  	          len = documentData.finalText.length;
  	          flag = false;
  	        }
  	      }
  	    }
  	    lineWidth = -trackingOffset;
  	    cLength = 0;
  	    var uncollapsedSpaces = 0;
  	    var currentChar;
  	    for (i = 0; i < len; i += 1) {
  	      newLineFlag = false;
  	      currentChar = documentData.finalText[i];
  	      charCode = currentChar.charCodeAt(0);
  	      if (charCode === 13 || charCode === 3) {
  	        uncollapsedSpaces = 0;
  	        lineWidths.push(lineWidth);
  	        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
  	        lineWidth = -2 * trackingOffset;
  	        val = '';
  	        newLineFlag = true;
  	        currentLine += 1;
  	      } else {
  	        val = currentChar;
  	      }
  	      if (fontManager.chars) {
  	        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
  	        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
  	      } else {
  	        // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
  	        // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
  	        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
  	      }

  	      //
  	      if (currentChar === ' ') {
  	        uncollapsedSpaces += cLength + trackingOffset;
  	      } else {
  	        lineWidth += cLength + trackingOffset + uncollapsedSpaces;
  	        uncollapsedSpaces = 0;
  	      }
  	      letters.push({
  	        l: cLength,
  	        an: cLength,
  	        add: currentSize,
  	        n: newLineFlag,
  	        anIndexes: [],
  	        val: val,
  	        line: currentLine,
  	        animatorJustifyOffset: 0
  	      });
  	      if (anchorGrouping == 2) {
  	        // eslint-disable-line eqeqeq
  	        currentSize += cLength;
  	        if (val === '' || val === ' ' || i === len - 1) {
  	          if (val === '' || val === ' ') {
  	            currentSize -= cLength;
  	          }
  	          while (currentPos <= i) {
  	            letters[currentPos].an = currentSize;
  	            letters[currentPos].ind = index;
  	            letters[currentPos].extra = cLength;
  	            currentPos += 1;
  	          }
  	          index += 1;
  	          currentSize = 0;
  	        }
  	      } else if (anchorGrouping == 3) {
  	        // eslint-disable-line eqeqeq
  	        currentSize += cLength;
  	        if (val === '' || i === len - 1) {
  	          if (val === '') {
  	            currentSize -= cLength;
  	          }
  	          while (currentPos <= i) {
  	            letters[currentPos].an = currentSize;
  	            letters[currentPos].ind = index;
  	            letters[currentPos].extra = cLength;
  	            currentPos += 1;
  	          }
  	          currentSize = 0;
  	          index += 1;
  	        }
  	      } else {
  	        letters[index].ind = index;
  	        letters[index].extra = 0;
  	        index += 1;
  	      }
  	    }
  	    documentData.l = letters;
  	    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
  	    lineWidths.push(lineWidth);
  	    if (documentData.sz) {
  	      documentData.boxWidth = documentData.sz[0];
  	      documentData.justifyOffset = 0;
  	    } else {
  	      documentData.boxWidth = maxLineWidth;
  	      switch (documentData.j) {
  	        case 1:
  	          documentData.justifyOffset = -documentData.boxWidth;
  	          break;
  	        case 2:
  	          documentData.justifyOffset = -documentData.boxWidth / 2;
  	          break;
  	        default:
  	          documentData.justifyOffset = 0;
  	      }
  	    }
  	    documentData.lineWidths = lineWidths;
  	    var animators = data.a;
  	    var animatorData;
  	    var letterData;
  	    jLen = animators.length;
  	    var based;
  	    var ind;
  	    var indexes = [];
  	    for (j = 0; j < jLen; j += 1) {
  	      animatorData = animators[j];
  	      if (animatorData.a.sc) {
  	        documentData.strokeColorAnim = true;
  	      }
  	      if (animatorData.a.sw) {
  	        documentData.strokeWidthAnim = true;
  	      }
  	      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
  	        documentData.fillColorAnim = true;
  	      }
  	      ind = 0;
  	      based = animatorData.s.b;
  	      for (i = 0; i < len; i += 1) {
  	        letterData = letters[i];
  	        letterData.anIndexes[j] = ind;
  	        if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
  	          // eslint-disable-line eqeqeq
  	          if (animatorData.s.rn === 1) {
  	            indexes.push(ind);
  	          }
  	          ind += 1;
  	        }
  	      }
  	      data.a[j].s.totalChars = ind;
  	      var currentInd = -1;
  	      var newInd;
  	      if (animatorData.s.rn === 1) {
  	        for (i = 0; i < len; i += 1) {
  	          letterData = letters[i];
  	          if (currentInd != letterData.anIndexes[j]) {
  	            // eslint-disable-line eqeqeq
  	            currentInd = letterData.anIndexes[j];
  	            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
  	          }
  	          letterData.anIndexes[j] = newInd;
  	        }
  	      }
  	    }
  	    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
  	    documentData.ls = documentData.ls || 0;
  	    documentData.ascent = fontData.ascent * documentData.finalSize / 100;
  	  };
  	  TextProperty.prototype.updateDocumentData = function (newData, index) {
  	    index = index === undefined ? this.keysIndex : index;
  	    var dData = this.copyData({}, this.data.d.k[index].s);
  	    dData = this.copyData(dData, newData);
  	    this.data.d.k[index].s = dData;
  	    this.recalculate(index);
  	    this.setCurrentData(dData);
  	    this.elem.addDynamicProperty(this);
  	  };
  	  TextProperty.prototype.recalculate = function (index) {
  	    var dData = this.data.d.k[index].s;
  	    dData.__complete = false;
  	    this.keysIndex = 0;
  	    this._isFirstFrame = true;
  	    this.getValue(dData);
  	  };
  	  TextProperty.prototype.canResizeFont = function (_canResize) {
  	    this.canResize = _canResize;
  	    this.recalculate(this.keysIndex);
  	    this.elem.addDynamicProperty(this);
  	  };
  	  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
  	    this.minimumFontSize = Math.floor(_fontValue) || 1;
  	    this.recalculate(this.keysIndex);
  	    this.elem.addDynamicProperty(this);
  	  };

  	  var TextSelectorProp = function () {
  	    var max = Math.max;
  	    var min = Math.min;
  	    var floor = Math.floor;
  	    function TextSelectorPropFactory(elem, data) {
  	      this._currentTextLength = -1;
  	      this.k = false;
  	      this.data = data;
  	      this.elem = elem;
  	      this.comp = elem.comp;
  	      this.finalS = 0;
  	      this.finalE = 0;
  	      this.initDynamicPropertyContainer(elem);
  	      this.s = PropertyFactory.getProp(elem, data.s || {
  	        k: 0
  	      }, 0, 0, this);
  	      if ('e' in data) {
  	        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
  	      } else {
  	        this.e = {
  	          v: 100
  	        };
  	      }
  	      this.o = PropertyFactory.getProp(elem, data.o || {
  	        k: 0
  	      }, 0, 0, this);
  	      this.xe = PropertyFactory.getProp(elem, data.xe || {
  	        k: 0
  	      }, 0, 0, this);
  	      this.ne = PropertyFactory.getProp(elem, data.ne || {
  	        k: 0
  	      }, 0, 0, this);
  	      this.sm = PropertyFactory.getProp(elem, data.sm || {
  	        k: 100
  	      }, 0, 0, this);
  	      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
  	      if (!this.dynamicProperties.length) {
  	        this.getValue();
  	      }
  	    }
  	    TextSelectorPropFactory.prototype = {
  	      getMult: function getMult(ind) {
  	        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
  	          this.getValue();
  	        }
  	        var x1 = 0;
  	        var y1 = 0;
  	        var x2 = 1;
  	        var y2 = 1;
  	        if (this.ne.v > 0) {
  	          x1 = this.ne.v / 100.0;
  	        } else {
  	          y1 = -this.ne.v / 100.0;
  	        }
  	        if (this.xe.v > 0) {
  	          x2 = 1.0 - this.xe.v / 100.0;
  	        } else {
  	          y2 = 1.0 + this.xe.v / 100.0;
  	        }
  	        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
  	        var mult = 0;
  	        var s = this.finalS;
  	        var e = this.finalE;
  	        var type = this.data.sh;
  	        if (type === 2) {
  	          if (e === s) {
  	            mult = ind >= e ? 1 : 0;
  	          } else {
  	            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
  	          }
  	          mult = easer(mult);
  	        } else if (type === 3) {
  	          if (e === s) {
  	            mult = ind >= e ? 0 : 1;
  	          } else {
  	            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
  	          }
  	          mult = easer(mult);
  	        } else if (type === 4) {
  	          if (e === s) {
  	            mult = 0;
  	          } else {
  	            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
  	            if (mult < 0.5) {
  	              mult *= 2;
  	            } else {
  	              mult = 1 - 2 * (mult - 0.5);
  	            }
  	          }
  	          mult = easer(mult);
  	        } else if (type === 5) {
  	          if (e === s) {
  	            mult = 0;
  	          } else {
  	            var tot = e - s;
  	            /* ind += 0.5;
  	                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
  	            ind = min(max(0, ind + 0.5 - s), e - s);
  	            var x = -tot / 2 + ind;
  	            var a = tot / 2;
  	            mult = Math.sqrt(1 - x * x / (a * a));
  	          }
  	          mult = easer(mult);
  	        } else if (type === 6) {
  	          if (e === s) {
  	            mult = 0;
  	          } else {
  	            ind = min(max(0, ind + 0.5 - s), e - s);
  	            mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
  	          }
  	          mult = easer(mult);
  	        } else {
  	          if (ind >= floor(s)) {
  	            if (ind - s < 0) {
  	              mult = max(0, min(min(e, 1) - (s - ind), 1));
  	            } else {
  	              mult = max(0, min(e - ind, 1));
  	            }
  	          }
  	          mult = easer(mult);
  	        }
  	        // Smoothness implementation.
  	        // The smoothness represents a reduced range of the original [0; 1] range.
  	        // if smoothness is 25%, the new range will be [0.375; 0.625]
  	        // Steps are:
  	        // - find the lower value of the new range (threshold)
  	        // - if multiplier is smaller than that value, floor it to 0
  	        // - if it is larger,
  	        //     - subtract the threshold
  	        //     - divide it by the smoothness (this will return the range to [0; 1])
  	        // Note: If it doesn't work on some scenarios, consider applying it before the easer.
  	        if (this.sm.v !== 100) {
  	          var smoothness = this.sm.v * 0.01;
  	          if (smoothness === 0) {
  	            smoothness = 0.00000001;
  	          }
  	          var threshold = 0.5 - smoothness * 0.5;
  	          if (mult < threshold) {
  	            mult = 0;
  	          } else {
  	            mult = (mult - threshold) / smoothness;
  	            if (mult > 1) {
  	              mult = 1;
  	            }
  	          }
  	        }
  	        return mult * this.a.v;
  	      },
  	      getValue: function getValue(newCharsFlag) {
  	        this.iterateDynamicProperties();
  	        this._mdf = newCharsFlag || this._mdf;
  	        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
  	        if (newCharsFlag && this.data.r === 2) {
  	          this.e.v = this._currentTextLength;
  	        }
  	        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
  	        var o = this.o.v / divisor;
  	        var s = this.s.v / divisor + o;
  	        var e = this.e.v / divisor + o;
  	        if (s > e) {
  	          var _s = s;
  	          s = e;
  	          e = _s;
  	        }
  	        this.finalS = s;
  	        this.finalE = e;
  	      }
  	    };
  	    extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
  	    function getTextSelectorProp(elem, data, arr) {
  	      return new TextSelectorPropFactory(elem, data);
  	    }
  	    return {
  	      getTextSelectorProp: getTextSelectorProp
  	    };
  	  }();

  	  function TextAnimatorDataProperty(elem, animatorProps, container) {
  	    var defaultData = {
  	      propType: false
  	    };
  	    var getProp = PropertyFactory.getProp;
  	    var textAnimatorAnimatables = animatorProps.a;
  	    this.a = {
  	      r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
  	      rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
  	      ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
  	      sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
  	      sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
  	      s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
  	      a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
  	      o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
  	      p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
  	      sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
  	      sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
  	      fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
  	      fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
  	      fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
  	      fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
  	      t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
  	    };
  	    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
  	    this.s.t = animatorProps.s.t;
  	  }

  	  function TextAnimatorProperty(textData, renderType, elem) {
  	    this._isFirstFrame = true;
  	    this._hasMaskedPath = false;
  	    this._frameId = -1;
  	    this._textData = textData;
  	    this._renderType = renderType;
  	    this._elem = elem;
  	    this._animatorsData = createSizedArray(this._textData.a.length);
  	    this._pathData = {};
  	    this._moreOptions = {
  	      alignment: {}
  	    };
  	    this.renderedLetters = [];
  	    this.lettersChangedFlag = false;
  	    this.initDynamicPropertyContainer(elem);
  	  }
  	  TextAnimatorProperty.prototype.searchProperties = function () {
  	    var i;
  	    var len = this._textData.a.length;
  	    var animatorProps;
  	    var getProp = PropertyFactory.getProp;
  	    for (i = 0; i < len; i += 1) {
  	      animatorProps = this._textData.a[i];
  	      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
  	    }
  	    if (this._textData.p && 'm' in this._textData.p) {
  	      this._pathData = {
  	        a: getProp(this._elem, this._textData.p.a, 0, 0, this),
  	        f: getProp(this._elem, this._textData.p.f, 0, 0, this),
  	        l: getProp(this._elem, this._textData.p.l, 0, 0, this),
  	        r: getProp(this._elem, this._textData.p.r, 0, 0, this),
  	        p: getProp(this._elem, this._textData.p.p, 0, 0, this),
  	        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
  	      };
  	      this._hasMaskedPath = true;
  	    } else {
  	      this._hasMaskedPath = false;
  	    }
  	    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
  	  };
  	  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
  	    this.lettersChangedFlag = lettersChangedFlag;
  	    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
  	      return;
  	    }
  	    this._isFirstFrame = false;
  	    var alignment = this._moreOptions.alignment.v;
  	    var animators = this._animatorsData;
  	    var textData = this._textData;
  	    var matrixHelper = this.mHelper;
  	    var renderType = this._renderType;
  	    var renderedLettersCount = this.renderedLetters.length;
  	    var xPos;
  	    var yPos;
  	    var i;
  	    var len;
  	    var letters = documentData.l;
  	    var pathInfo;
  	    var currentLength;
  	    var currentPoint;
  	    var segmentLength;
  	    var flag;
  	    var pointInd;
  	    var segmentInd;
  	    var prevPoint;
  	    var points;
  	    var segments;
  	    var partialLength;
  	    var totalLength;
  	    var perc;
  	    var tanAngle;
  	    var mask;
  	    if (this._hasMaskedPath) {
  	      mask = this._pathData.m;
  	      if (!this._pathData.n || this._pathData._mdf) {
  	        var paths = mask.v;
  	        if (this._pathData.r.v) {
  	          paths = paths.reverse();
  	        }
  	        // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
  	        pathInfo = {
  	          tLength: 0,
  	          segments: []
  	        };
  	        len = paths._length - 1;
  	        var bezierData;
  	        totalLength = 0;
  	        for (i = 0; i < len; i += 1) {
  	          bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
  	          pathInfo.tLength += bezierData.segmentLength;
  	          pathInfo.segments.push(bezierData);
  	          totalLength += bezierData.segmentLength;
  	        }
  	        i = len;
  	        if (mask.v.c) {
  	          bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
  	          pathInfo.tLength += bezierData.segmentLength;
  	          pathInfo.segments.push(bezierData);
  	          totalLength += bezierData.segmentLength;
  	        }
  	        this._pathData.pi = pathInfo;
  	      }
  	      pathInfo = this._pathData.pi;
  	      currentLength = this._pathData.f.v;
  	      segmentInd = 0;
  	      pointInd = 1;
  	      segmentLength = 0;
  	      flag = true;
  	      segments = pathInfo.segments;
  	      if (currentLength < 0 && mask.v.c) {
  	        if (pathInfo.tLength < Math.abs(currentLength)) {
  	          currentLength = -Math.abs(currentLength) % pathInfo.tLength;
  	        }
  	        segmentInd = segments.length - 1;
  	        points = segments[segmentInd].points;
  	        pointInd = points.length - 1;
  	        while (currentLength < 0) {
  	          currentLength += points[pointInd].partialLength;
  	          pointInd -= 1;
  	          if (pointInd < 0) {
  	            segmentInd -= 1;
  	            points = segments[segmentInd].points;
  	            pointInd = points.length - 1;
  	          }
  	        }
  	      }
  	      points = segments[segmentInd].points;
  	      prevPoint = points[pointInd - 1];
  	      currentPoint = points[pointInd];
  	      partialLength = currentPoint.partialLength;
  	    }
  	    len = letters.length;
  	    xPos = 0;
  	    yPos = 0;
  	    var yOff = documentData.finalSize * 1.2 * 0.714;
  	    var firstLine = true;
  	    var animatorProps;
  	    var animatorSelector;
  	    var j;
  	    var jLen;
  	    var letterValue;
  	    jLen = animators.length;
  	    var mult;
  	    var ind = -1;
  	    var offf;
  	    var xPathPos;
  	    var yPathPos;
  	    var initPathPos = currentLength;
  	    var initSegmentInd = segmentInd;
  	    var initPointInd = pointInd;
  	    var currentLine = -1;
  	    var elemOpacity;
  	    var sc;
  	    var sw;
  	    var fc;
  	    var k;
  	    var letterSw;
  	    var letterSc;
  	    var letterFc;
  	    var letterM = '';
  	    var letterP = this.defaultPropsArray;
  	    var letterO;

  	    //
  	    if (documentData.j === 2 || documentData.j === 1) {
  	      var animatorJustifyOffset = 0;
  	      var animatorFirstCharOffset = 0;
  	      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
  	      var lastIndex = 0;
  	      var isNewLine = true;
  	      for (i = 0; i < len; i += 1) {
  	        if (letters[i].n) {
  	          if (animatorJustifyOffset) {
  	            animatorJustifyOffset += animatorFirstCharOffset;
  	          }
  	          while (lastIndex < i) {
  	            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
  	            lastIndex += 1;
  	          }
  	          animatorJustifyOffset = 0;
  	          isNewLine = true;
  	        } else {
  	          for (j = 0; j < jLen; j += 1) {
  	            animatorProps = animators[j].a;
  	            if (animatorProps.t.propType) {
  	              if (isNewLine && documentData.j === 2) {
  	                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
  	              }
  	              animatorSelector = animators[j].s;
  	              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	              if (mult.length) {
  	                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
  	              } else {
  	                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
  	              }
  	            }
  	          }
  	          isNewLine = false;
  	        }
  	      }
  	      if (animatorJustifyOffset) {
  	        animatorJustifyOffset += animatorFirstCharOffset;
  	      }
  	      while (lastIndex < i) {
  	        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
  	        lastIndex += 1;
  	      }
  	    }
  	    //

  	    for (i = 0; i < len; i += 1) {
  	      matrixHelper.reset();
  	      elemOpacity = 1;
  	      if (letters[i].n) {
  	        xPos = 0;
  	        yPos += documentData.yOffset;
  	        yPos += firstLine ? 1 : 0;
  	        currentLength = initPathPos;
  	        firstLine = false;
  	        if (this._hasMaskedPath) {
  	          segmentInd = initSegmentInd;
  	          pointInd = initPointInd;
  	          points = segments[segmentInd].points;
  	          prevPoint = points[pointInd - 1];
  	          currentPoint = points[pointInd];
  	          partialLength = currentPoint.partialLength;
  	          segmentLength = 0;
  	        }
  	        letterM = '';
  	        letterFc = '';
  	        letterSw = '';
  	        letterO = '';
  	        letterP = this.defaultPropsArray;
  	      } else {
  	        if (this._hasMaskedPath) {
  	          if (currentLine !== letters[i].line) {
  	            switch (documentData.j) {
  	              case 1:
  	                currentLength += totalLength - documentData.lineWidths[letters[i].line];
  	                break;
  	              case 2:
  	                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
  	                break;
  	            }
  	            currentLine = letters[i].line;
  	          }
  	          if (ind !== letters[i].ind) {
  	            if (letters[ind]) {
  	              currentLength += letters[ind].extra;
  	            }
  	            currentLength += letters[i].an / 2;
  	            ind = letters[i].ind;
  	          }
  	          currentLength += alignment[0] * letters[i].an * 0.005;
  	          var animatorOffset = 0;
  	          for (j = 0; j < jLen; j += 1) {
  	            animatorProps = animators[j].a;
  	            if (animatorProps.p.propType) {
  	              animatorSelector = animators[j].s;
  	              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	              if (mult.length) {
  	                animatorOffset += animatorProps.p.v[0] * mult[0];
  	              } else {
  	                animatorOffset += animatorProps.p.v[0] * mult;
  	              }
  	            }
  	            if (animatorProps.a.propType) {
  	              animatorSelector = animators[j].s;
  	              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	              if (mult.length) {
  	                animatorOffset += animatorProps.a.v[0] * mult[0];
  	              } else {
  	                animatorOffset += animatorProps.a.v[0] * mult;
  	              }
  	            }
  	          }
  	          flag = true;
  	          // Force alignment only works with a single line for now
  	          if (this._pathData.a.v) {
  	            currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
  	            currentLength += this._pathData.f.v;
  	          }
  	          while (flag) {
  	            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
  	              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
  	              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
  	              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
  	              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
  	              flag = false;
  	            } else if (points) {
  	              segmentLength += currentPoint.partialLength;
  	              pointInd += 1;
  	              if (pointInd >= points.length) {
  	                pointInd = 0;
  	                segmentInd += 1;
  	                if (!segments[segmentInd]) {
  	                  if (mask.v.c) {
  	                    pointInd = 0;
  	                    segmentInd = 0;
  	                    points = segments[segmentInd].points;
  	                  } else {
  	                    segmentLength -= currentPoint.partialLength;
  	                    points = null;
  	                  }
  	                } else {
  	                  points = segments[segmentInd].points;
  	                }
  	              }
  	              if (points) {
  	                prevPoint = currentPoint;
  	                currentPoint = points[pointInd];
  	                partialLength = currentPoint.partialLength;
  	              }
  	            }
  	          }
  	          offf = letters[i].an / 2 - letters[i].add;
  	          matrixHelper.translate(-offf, 0, 0);
  	        } else {
  	          offf = letters[i].an / 2 - letters[i].add;
  	          matrixHelper.translate(-offf, 0, 0);

  	          // Grouping alignment
  	          matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
  	        }
  	        for (j = 0; j < jLen; j += 1) {
  	          animatorProps = animators[j].a;
  	          if (animatorProps.t.propType) {
  	            animatorSelector = animators[j].s;
  	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	            // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
  	            if (xPos !== 0 || documentData.j !== 0) {
  	              if (this._hasMaskedPath) {
  	                if (mult.length) {
  	                  currentLength += animatorProps.t.v * mult[0];
  	                } else {
  	                  currentLength += animatorProps.t.v * mult;
  	                }
  	              } else if (mult.length) {
  	                xPos += animatorProps.t.v * mult[0];
  	              } else {
  	                xPos += animatorProps.t.v * mult;
  	              }
  	            }
  	          }
  	        }
  	        if (documentData.strokeWidthAnim) {
  	          sw = documentData.sw || 0;
  	        }
  	        if (documentData.strokeColorAnim) {
  	          if (documentData.sc) {
  	            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
  	          } else {
  	            sc = [0, 0, 0];
  	          }
  	        }
  	        if (documentData.fillColorAnim && documentData.fc) {
  	          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
  	        }
  	        for (j = 0; j < jLen; j += 1) {
  	          animatorProps = animators[j].a;
  	          if (animatorProps.a.propType) {
  	            animatorSelector = animators[j].s;
  	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	            if (mult.length) {
  	              matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
  	            } else {
  	              matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
  	            }
  	          }
  	        }
  	        for (j = 0; j < jLen; j += 1) {
  	          animatorProps = animators[j].a;
  	          if (animatorProps.s.propType) {
  	            animatorSelector = animators[j].s;
  	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	            if (mult.length) {
  	              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
  	            } else {
  	              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
  	            }
  	          }
  	        }
  	        for (j = 0; j < jLen; j += 1) {
  	          animatorProps = animators[j].a;
  	          animatorSelector = animators[j].s;
  	          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	          if (animatorProps.sk.propType) {
  	            if (mult.length) {
  	              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
  	            } else {
  	              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
  	            }
  	          }
  	          if (animatorProps.r.propType) {
  	            if (mult.length) {
  	              matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
  	            } else {
  	              matrixHelper.rotateZ(-animatorProps.r.v * mult);
  	            }
  	          }
  	          if (animatorProps.ry.propType) {
  	            if (mult.length) {
  	              matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
  	            } else {
  	              matrixHelper.rotateY(animatorProps.ry.v * mult);
  	            }
  	          }
  	          if (animatorProps.rx.propType) {
  	            if (mult.length) {
  	              matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
  	            } else {
  	              matrixHelper.rotateX(animatorProps.rx.v * mult);
  	            }
  	          }
  	          if (animatorProps.o.propType) {
  	            if (mult.length) {
  	              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
  	            } else {
  	              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
  	            }
  	          }
  	          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
  	            if (mult.length) {
  	              sw += animatorProps.sw.v * mult[0];
  	            } else {
  	              sw += animatorProps.sw.v * mult;
  	            }
  	          }
  	          if (documentData.strokeColorAnim && animatorProps.sc.propType) {
  	            for (k = 0; k < 3; k += 1) {
  	              if (mult.length) {
  	                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
  	              } else {
  	                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
  	              }
  	            }
  	          }
  	          if (documentData.fillColorAnim && documentData.fc) {
  	            if (animatorProps.fc.propType) {
  	              for (k = 0; k < 3; k += 1) {
  	                if (mult.length) {
  	                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
  	                } else {
  	                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
  	                }
  	              }
  	            }
  	            if (animatorProps.fh.propType) {
  	              if (mult.length) {
  	                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
  	              } else {
  	                fc = addHueToRGB(fc, animatorProps.fh.v * mult);
  	              }
  	            }
  	            if (animatorProps.fs.propType) {
  	              if (mult.length) {
  	                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
  	              } else {
  	                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
  	              }
  	            }
  	            if (animatorProps.fb.propType) {
  	              if (mult.length) {
  	                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
  	              } else {
  	                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
  	              }
  	            }
  	          }
  	        }
  	        for (j = 0; j < jLen; j += 1) {
  	          animatorProps = animators[j].a;
  	          if (animatorProps.p.propType) {
  	            animatorSelector = animators[j].s;
  	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
  	            if (this._hasMaskedPath) {
  	              if (mult.length) {
  	                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
  	              } else {
  	                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
  	              }
  	            } else if (mult.length) {
  	              matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
  	            } else {
  	              matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
  	            }
  	          }
  	        }
  	        if (documentData.strokeWidthAnim) {
  	          letterSw = sw < 0 ? 0 : sw;
  	        }
  	        if (documentData.strokeColorAnim) {
  	          letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
  	        }
  	        if (documentData.fillColorAnim && documentData.fc) {
  	          letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
  	        }
  	        if (this._hasMaskedPath) {
  	          matrixHelper.translate(0, -documentData.ls);
  	          matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
  	          if (this._pathData.p.v) {
  	            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
  	            var rot = Math.atan(tanAngle) * 180 / Math.PI;
  	            if (currentPoint.point[0] < prevPoint.point[0]) {
  	              rot += 180;
  	            }
  	            matrixHelper.rotate(-rot * Math.PI / 180);
  	          }
  	          matrixHelper.translate(xPathPos, yPathPos, 0);
  	          currentLength -= alignment[0] * letters[i].an * 0.005;
  	          if (letters[i + 1] && ind !== letters[i + 1].ind) {
  	            currentLength += letters[i].an / 2;
  	            currentLength += documentData.tr * 0.001 * documentData.finalSize;
  	          }
  	        } else {
  	          matrixHelper.translate(xPos, yPos, 0);
  	          if (documentData.ps) {
  	            // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
  	            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
  	          }
  	          switch (documentData.j) {
  	            case 1:
  	              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
  	              break;
  	            case 2:
  	              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
  	              break;
  	          }
  	          matrixHelper.translate(0, -documentData.ls);
  	          matrixHelper.translate(offf, 0, 0);
  	          matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
  	          xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
  	        }
  	        if (renderType === 'html') {
  	          letterM = matrixHelper.toCSS();
  	        } else if (renderType === 'svg') {
  	          letterM = matrixHelper.to2dCSS();
  	        } else {
  	          letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
  	        }
  	        letterO = elemOpacity;
  	      }
  	      if (renderedLettersCount <= i) {
  	        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
  	        this.renderedLetters.push(letterValue);
  	        renderedLettersCount += 1;
  	        this.lettersChangedFlag = true;
  	      } else {
  	        letterValue = this.renderedLetters[i];
  	        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
  	      }
  	    }
  	  };
  	  TextAnimatorProperty.prototype.getValue = function () {
  	    if (this._elem.globalData.frameId === this._frameId) {
  	      return;
  	    }
  	    this._frameId = this._elem.globalData.frameId;
  	    this.iterateDynamicProperties();
  	  };
  	  TextAnimatorProperty.prototype.mHelper = new Matrix();
  	  TextAnimatorProperty.prototype.defaultPropsArray = [];
  	  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

  	  function ITextElement() {}
  	  ITextElement.prototype.initElement = function (data, globalData, comp) {
  	    this.lettersChangedFlag = true;
  	    this.initFrame();
  	    this.initBaseData(data, globalData, comp);
  	    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
  	    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
  	    this.initTransform(data, globalData, comp);
  	    this.initHierarchy();
  	    this.initRenderable();
  	    this.initRendererElement();
  	    this.createContainerElements();
  	    this.createRenderableComponents();
  	    this.createContent();
  	    this.hide();
  	    this.textAnimator.searchProperties(this.dynamicProperties);
  	  };
  	  ITextElement.prototype.prepareFrame = function (num) {
  	    this._mdf = false;
  	    this.prepareRenderableFrame(num);
  	    this.prepareProperties(num, this.isInRange);
  	  };
  	  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
  	    var j;
  	    var jLen = shapes.length;
  	    var pathNodes;
  	    var shapeStr = '';
  	    for (j = 0; j < jLen; j += 1) {
  	      if (shapes[j].ty === 'sh') {
  	        pathNodes = shapes[j].ks.k;
  	        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
  	      }
  	    }
  	    return shapeStr;
  	  };
  	  ITextElement.prototype.updateDocumentData = function (newData, index) {
  	    this.textProperty.updateDocumentData(newData, index);
  	  };
  	  ITextElement.prototype.canResizeFont = function (_canResize) {
  	    this.textProperty.canResizeFont(_canResize);
  	  };
  	  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
  	    this.textProperty.setMinimumFontSize(_fontSize);
  	  };
  	  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
  	    if (documentData.ps) {
  	      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
  	    }
  	    matrixHelper.translate(0, -documentData.ls, 0);
  	    switch (documentData.j) {
  	      case 1:
  	        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
  	        break;
  	      case 2:
  	        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
  	        break;
  	    }
  	    matrixHelper.translate(xPos, yPos, 0);
  	  };
  	  ITextElement.prototype.buildColor = function (colorData) {
  	    return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
  	  };
  	  ITextElement.prototype.emptyProp = new LetterProps();
  	  ITextElement.prototype.destroy = function () {};
  	  ITextElement.prototype.validateText = function () {
  	    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
  	      this.buildNewText();
  	      this.textProperty._isFirstFrame = false;
  	      this.textProperty._mdf = false;
  	    }
  	  };

  	  var emptyShapeData = {
  	    shapes: []
  	  };
  	  function SVGTextLottieElement(data, globalData, comp) {
  	    this.textSpans = [];
  	    this.renderType = 'svg';
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
  	  SVGTextLottieElement.prototype.createContent = function () {
  	    if (this.data.singleShape && !this.globalData.fontManager.chars) {
  	      this.textContainer = createNS('text');
  	    }
  	  };
  	  SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
  	    var i = 0;
  	    var len = textArray.length;
  	    var textContents = [];
  	    var currentTextContent = '';
  	    while (i < len) {
  	      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
  	        textContents.push(currentTextContent);
  	        currentTextContent = '';
  	      } else {
  	        currentTextContent += textArray[i];
  	      }
  	      i += 1;
  	    }
  	    textContents.push(currentTextContent);
  	    return textContents;
  	  };
  	  SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {
  	    // data should probably be cloned to apply scale separately to each instance of a text on different layers
  	    // but since text internal content gets only rendered once and then it's never rerendered,
  	    // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
  	    // Avoiding cloning is preferred since cloning each character shape data is expensive
  	    if (data.shapes && data.shapes.length) {
  	      var shape = data.shapes[0];
  	      if (shape.it) {
  	        var shapeItem = shape.it[shape.it.length - 1];
  	        if (shapeItem.s) {
  	          shapeItem.s.k[0] = scale;
  	          shapeItem.s.k[1] = scale;
  	        }
  	      }
  	    }
  	    return data;
  	  };
  	  SVGTextLottieElement.prototype.buildNewText = function () {
  	    this.addDynamicProperty(this);
  	    var i;
  	    var len;
  	    var documentData = this.textProperty.currentData;
  	    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
  	    if (documentData.fc) {
  	      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
  	    } else {
  	      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
  	    }
  	    if (documentData.sc) {
  	      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
  	      this.layerElement.setAttribute('stroke-width', documentData.sw);
  	    }
  	    this.layerElement.setAttribute('font-size', documentData.finalSize);
  	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  	    if (fontData.fClass) {
  	      this.layerElement.setAttribute('class', fontData.fClass);
  	    } else {
  	      this.layerElement.setAttribute('font-family', fontData.fFamily);
  	      var fWeight = documentData.fWeight;
  	      var fStyle = documentData.fStyle;
  	      this.layerElement.setAttribute('font-style', fStyle);
  	      this.layerElement.setAttribute('font-weight', fWeight);
  	    }
  	    this.layerElement.setAttribute('aria-label', documentData.t);
  	    var letters = documentData.l || [];
  	    var usesGlyphs = !!this.globalData.fontManager.chars;
  	    len = letters.length;
  	    var tSpan;
  	    var matrixHelper = this.mHelper;
  	    var shapeStr = '';
  	    var singleShape = this.data.singleShape;
  	    var xPos = 0;
  	    var yPos = 0;
  	    var firstLine = true;
  	    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  	    if (singleShape && !usesGlyphs && !documentData.sz) {
  	      var tElement = this.textContainer;
  	      var justify = 'start';
  	      switch (documentData.j) {
  	        case 1:
  	          justify = 'end';
  	          break;
  	        case 2:
  	          justify = 'middle';
  	          break;
  	        default:
  	          justify = 'start';
  	          break;
  	      }
  	      tElement.setAttribute('text-anchor', justify);
  	      tElement.setAttribute('letter-spacing', trackingOffset);
  	      var textContent = this.buildTextContents(documentData.finalText);
  	      len = textContent.length;
  	      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
  	      for (i = 0; i < len; i += 1) {
  	        tSpan = this.textSpans[i].span || createNS('tspan');
  	        tSpan.textContent = textContent[i];
  	        tSpan.setAttribute('x', 0);
  	        tSpan.setAttribute('y', yPos);
  	        tSpan.style.display = 'inherit';
  	        tElement.appendChild(tSpan);
  	        if (!this.textSpans[i]) {
  	          this.textSpans[i] = {
  	            span: null,
  	            glyph: null
  	          };
  	        }
  	        this.textSpans[i].span = tSpan;
  	        yPos += documentData.finalLineHeight;
  	      }
  	      this.layerElement.appendChild(tElement);
  	    } else {
  	      var cachedSpansLength = this.textSpans.length;
  	      var charData;
  	      for (i = 0; i < len; i += 1) {
  	        if (!this.textSpans[i]) {
  	          this.textSpans[i] = {
  	            span: null,
  	            childSpan: null,
  	            glyph: null
  	          };
  	        }
  	        if (!usesGlyphs || !singleShape || i === 0) {
  	          tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');
  	          if (cachedSpansLength <= i) {
  	            tSpan.setAttribute('stroke-linecap', 'butt');
  	            tSpan.setAttribute('stroke-linejoin', 'round');
  	            tSpan.setAttribute('stroke-miterlimit', '4');
  	            this.textSpans[i].span = tSpan;
  	            if (usesGlyphs) {
  	              var childSpan = createNS('g');
  	              tSpan.appendChild(childSpan);
  	              this.textSpans[i].childSpan = childSpan;
  	            }
  	            this.textSpans[i].span = tSpan;
  	            this.layerElement.appendChild(tSpan);
  	          }
  	          tSpan.style.display = 'inherit';
  	        }
  	        matrixHelper.reset();
  	        if (singleShape) {
  	          if (letters[i].n) {
  	            xPos = -trackingOffset;
  	            yPos += documentData.yOffset;
  	            yPos += firstLine ? 1 : 0;
  	            firstLine = false;
  	          }
  	          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
  	          xPos += letters[i].l || 0;
  	          // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
  	          xPos += trackingOffset;
  	        }
  	        if (usesGlyphs) {
  	          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
  	          var glyphElement;
  	          // t === 1 means the character has been replaced with an animated shaped
  	          if (charData.t === 1) {
  	            glyphElement = new SVGCompElement(charData.data, this.globalData, this);
  	          } else {
  	            var data = emptyShapeData;
  	            if (charData.data && charData.data.shapes) {
  	              data = this.buildShapeData(charData.data, documentData.finalSize);
  	            }
  	            glyphElement = new SVGShapeElement(data, this.globalData, this);
  	          }
  	          if (this.textSpans[i].glyph) {
  	            var glyph = this.textSpans[i].glyph;
  	            this.textSpans[i].childSpan.removeChild(glyph.layerElement);
  	            glyph.destroy();
  	          }
  	          this.textSpans[i].glyph = glyphElement;
  	          glyphElement._debug = true;
  	          glyphElement.prepareFrame(0);
  	          glyphElement.renderFrame();
  	          this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);
  	          // when using animated shapes, the layer will be scaled instead of replacing the internal scale
  	          // this might have issues with strokes and might need a different solution
  	          if (charData.t === 1) {
  	            this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');
  	          }
  	        } else {
  	          if (singleShape) {
  	            tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
  	          }
  	          tSpan.textContent = letters[i].val;
  	          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
  	        }
  	        //
  	      }
  	      if (singleShape && tSpan) {
  	        tSpan.setAttribute('d', shapeStr);
  	      }
  	    }
  	    while (i < this.textSpans.length) {
  	      this.textSpans[i].span.style.display = 'none';
  	      i += 1;
  	    }
  	    this._sizeChanged = true;
  	  };
  	  SVGTextLottieElement.prototype.sourceRectAtTime = function () {
  	    this.prepareFrame(this.comp.renderedFrame - this.data.st);
  	    this.renderInnerContent();
  	    if (this._sizeChanged) {
  	      this._sizeChanged = false;
  	      var textBox = this.layerElement.getBBox();
  	      this.bbox = {
  	        top: textBox.y,
  	        left: textBox.x,
  	        width: textBox.width,
  	        height: textBox.height
  	      };
  	    }
  	    return this.bbox;
  	  };
  	  SVGTextLottieElement.prototype.getValue = function () {
  	    var i;
  	    var len = this.textSpans.length;
  	    var glyphElement;
  	    this.renderedFrame = this.comp.renderedFrame;
  	    for (i = 0; i < len; i += 1) {
  	      glyphElement = this.textSpans[i].glyph;
  	      if (glyphElement) {
  	        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
  	        if (glyphElement._mdf) {
  	          this._mdf = true;
  	        }
  	      }
  	    }
  	  };
  	  SVGTextLottieElement.prototype.renderInnerContent = function () {
  	    this.validateText();
  	    if (!this.data.singleShape || this._mdf) {
  	      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  	      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
  	        this._sizeChanged = true;
  	        var i;
  	        var len;
  	        var renderedLetters = this.textAnimator.renderedLetters;
  	        var letters = this.textProperty.currentData.l;
  	        len = letters.length;
  	        var renderedLetter;
  	        var textSpan;
  	        var glyphElement;
  	        for (i = 0; i < len; i += 1) {
  	          if (!letters[i].n) {
  	            renderedLetter = renderedLetters[i];
  	            textSpan = this.textSpans[i].span;
  	            glyphElement = this.textSpans[i].glyph;
  	            if (glyphElement) {
  	              glyphElement.renderFrame();
  	            }
  	            if (renderedLetter._mdf.m) {
  	              textSpan.setAttribute('transform', renderedLetter.m);
  	            }
  	            if (renderedLetter._mdf.o) {
  	              textSpan.setAttribute('opacity', renderedLetter.o);
  	            }
  	            if (renderedLetter._mdf.sw) {
  	              textSpan.setAttribute('stroke-width', renderedLetter.sw);
  	            }
  	            if (renderedLetter._mdf.sc) {
  	              textSpan.setAttribute('stroke', renderedLetter.sc);
  	            }
  	            if (renderedLetter._mdf.fc) {
  	              textSpan.setAttribute('fill', renderedLetter.fc);
  	            }
  	          }
  	        }
  	      }
  	    }
  	  };

  	  function ISolidElement(data, globalData, comp) {
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([IImageElement], ISolidElement);
  	  ISolidElement.prototype.createContent = function () {
  	    var rect = createNS('rect');
  	    /// /rect.style.width = this.data.sw;
  	    /// /rect.style.height = this.data.sh;
  	    /// /rect.style.fill = this.data.sc;
  	    rect.setAttribute('width', this.data.sw);
  	    rect.setAttribute('height', this.data.sh);
  	    rect.setAttribute('fill', this.data.sc);
  	    this.layerElement.appendChild(rect);
  	  };

  	  function NullElement(data, globalData, comp) {
  	    this.initFrame();
  	    this.initBaseData(data, globalData, comp);
  	    this.initFrame();
  	    this.initTransform(data, globalData, comp);
  	    this.initHierarchy();
  	  }
  	  NullElement.prototype.prepareFrame = function (num) {
  	    this.prepareProperties(num, true);
  	  };
  	  NullElement.prototype.renderFrame = function () {};
  	  NullElement.prototype.getBaseElement = function () {
  	    return null;
  	  };
  	  NullElement.prototype.destroy = function () {};
  	  NullElement.prototype.sourceRectAtTime = function () {};
  	  NullElement.prototype.hide = function () {};
  	  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

  	  function SVGRendererBase() {}
  	  extendPrototype([BaseRenderer], SVGRendererBase);
  	  SVGRendererBase.prototype.createNull = function (data) {
  	    return new NullElement(data, this.globalData, this);
  	  };
  	  SVGRendererBase.prototype.createShape = function (data) {
  	    return new SVGShapeElement(data, this.globalData, this);
  	  };
  	  SVGRendererBase.prototype.createText = function (data) {
  	    return new SVGTextLottieElement(data, this.globalData, this);
  	  };
  	  SVGRendererBase.prototype.createImage = function (data) {
  	    return new IImageElement(data, this.globalData, this);
  	  };
  	  SVGRendererBase.prototype.createSolid = function (data) {
  	    return new ISolidElement(data, this.globalData, this);
  	  };
  	  SVGRendererBase.prototype.configAnimation = function (animData) {
  	    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  	    this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  	    if (this.renderConfig.viewBoxSize) {
  	      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
  	    } else {
  	      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
  	    }
  	    if (!this.renderConfig.viewBoxOnly) {
  	      this.svgElement.setAttribute('width', animData.w);
  	      this.svgElement.setAttribute('height', animData.h);
  	      this.svgElement.style.width = '100%';
  	      this.svgElement.style.height = '100%';
  	      this.svgElement.style.transform = 'translate3d(0,0,0)';
  	      this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
  	    }
  	    if (this.renderConfig.width) {
  	      this.svgElement.setAttribute('width', this.renderConfig.width);
  	    }
  	    if (this.renderConfig.height) {
  	      this.svgElement.setAttribute('height', this.renderConfig.height);
  	    }
  	    if (this.renderConfig.className) {
  	      this.svgElement.setAttribute('class', this.renderConfig.className);
  	    }
  	    if (this.renderConfig.id) {
  	      this.svgElement.setAttribute('id', this.renderConfig.id);
  	    }
  	    if (this.renderConfig.focusable !== undefined) {
  	      this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
  	    }
  	    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
  	    // this.layerElement.style.transform = 'translate3d(0,0,0)';
  	    // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
  	    this.animationItem.wrapper.appendChild(this.svgElement);
  	    // Mask animation
  	    var defs = this.globalData.defs;
  	    this.setupGlobalData(animData, defs);
  	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  	    this.data = animData;
  	    var maskElement = createNS('clipPath');
  	    var rect = createNS('rect');
  	    rect.setAttribute('width', animData.w);
  	    rect.setAttribute('height', animData.h);
  	    rect.setAttribute('x', 0);
  	    rect.setAttribute('y', 0);
  	    var maskId = createElementID();
  	    maskElement.setAttribute('id', maskId);
  	    maskElement.appendChild(rect);
  	    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');
  	    defs.appendChild(maskElement);
  	    this.layers = animData.layers;
  	    this.elements = createSizedArray(animData.layers.length);
  	  };
  	  SVGRendererBase.prototype.destroy = function () {
  	    if (this.animationItem.wrapper) {
  	      this.animationItem.wrapper.innerText = '';
  	    }
  	    this.layerElement = null;
  	    this.globalData.defs = null;
  	    var i;
  	    var len = this.layers ? this.layers.length : 0;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.elements[i] && this.elements[i].destroy) {
  	        this.elements[i].destroy();
  	      }
  	    }
  	    this.elements.length = 0;
  	    this.destroyed = true;
  	    this.animationItem = null;
  	  };
  	  SVGRendererBase.prototype.updateContainerSize = function () {};
  	  SVGRendererBase.prototype.findIndexByInd = function (ind) {
  	    var i = 0;
  	    var len = this.layers.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.layers[i].ind === ind) {
  	        return i;
  	      }
  	    }
  	    return -1;
  	  };
  	  SVGRendererBase.prototype.buildItem = function (pos) {
  	    var elements = this.elements;
  	    if (elements[pos] || this.layers[pos].ty === 99) {
  	      return;
  	    }
  	    elements[pos] = true;
  	    var element = this.createItem(this.layers[pos]);
  	    elements[pos] = element;
  	    if (getExpressionsPlugin()) {
  	      if (this.layers[pos].ty === 0) {
  	        this.globalData.projectInterface.registerComposition(element);
  	      }
  	      element.initExpressions();
  	    }
  	    this.appendElementInPos(element, pos);
  	    if (this.layers[pos].tt) {
  	      var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
  	      if (elementIndex === -1) {
  	        return;
  	      }
  	      if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
  	        this.buildItem(elementIndex);
  	        this.addPendingElement(element);
  	      } else {
  	        var matteElement = elements[elementIndex];
  	        var matteMask = matteElement.getMatte(this.layers[pos].tt);
  	        element.setMatte(matteMask);
  	      }
  	    }
  	  };
  	  SVGRendererBase.prototype.checkPendingElements = function () {
  	    while (this.pendingElements.length) {
  	      var element = this.pendingElements.pop();
  	      element.checkParenting();
  	      if (element.data.tt) {
  	        var i = 0;
  	        var len = this.elements.length;
  	        while (i < len) {
  	          if (this.elements[i] === element) {
  	            var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
  	            var matteElement = this.elements[elementIndex];
  	            var matteMask = matteElement.getMatte(this.layers[i].tt);
  	            element.setMatte(matteMask);
  	            break;
  	          }
  	          i += 1;
  	        }
  	      }
  	    }
  	  };
  	  SVGRendererBase.prototype.renderFrame = function (num) {
  	    if (this.renderedFrame === num || this.destroyed) {
  	      return;
  	    }
  	    if (num === null) {
  	      num = this.renderedFrame;
  	    } else {
  	      this.renderedFrame = num;
  	    }
  	    // console.log('-------');
  	    // console.log('FRAME ',num);
  	    this.globalData.frameNum = num;
  	    this.globalData.frameId += 1;
  	    this.globalData.projectInterface.currentFrame = num;
  	    this.globalData._mdf = false;
  	    var i;
  	    var len = this.layers.length;
  	    if (!this.completeLayers) {
  	      this.checkLayers(num);
  	    }
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.completeLayers || this.elements[i]) {
  	        this.elements[i].prepareFrame(num - this.layers[i].st);
  	      }
  	    }
  	    if (this.globalData._mdf) {
  	      for (i = 0; i < len; i += 1) {
  	        if (this.completeLayers || this.elements[i]) {
  	          this.elements[i].renderFrame();
  	        }
  	      }
  	    }
  	  };
  	  SVGRendererBase.prototype.appendElementInPos = function (element, pos) {
  	    var newElement = element.getBaseElement();
  	    if (!newElement) {
  	      return;
  	    }
  	    var i = 0;
  	    var nextElement;
  	    while (i < pos) {
  	      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
  	        nextElement = this.elements[i].getBaseElement();
  	      }
  	      i += 1;
  	    }
  	    if (nextElement) {
  	      this.layerElement.insertBefore(newElement, nextElement);
  	    } else {
  	      this.layerElement.appendChild(newElement);
  	    }
  	  };
  	  SVGRendererBase.prototype.hide = function () {
  	    this.layerElement.style.display = 'none';
  	  };
  	  SVGRendererBase.prototype.show = function () {
  	    this.layerElement.style.display = 'block';
  	  };

  	  function ICompElement() {}
  	  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
  	  ICompElement.prototype.initElement = function (data, globalData, comp) {
  	    this.initFrame();
  	    this.initBaseData(data, globalData, comp);
  	    this.initTransform(data, globalData, comp);
  	    this.initRenderable();
  	    this.initHierarchy();
  	    this.initRendererElement();
  	    this.createContainerElements();
  	    this.createRenderableComponents();
  	    if (this.data.xt || !globalData.progressiveLoad) {
  	      this.buildAllItems();
  	    }
  	    this.hide();
  	  };

  	  /* ICompElement.prototype.hide = function(){
  	      if(!this.hidden){
  	          this.hideElement();
  	          var i,len = this.elements.length;
  	          for( i = 0; i < len; i+=1 ){
  	              if(this.elements[i]){
  	                  this.elements[i].hide();
  	              }
  	          }
  	      }
  	  }; */

  	  ICompElement.prototype.prepareFrame = function (num) {
  	    this._mdf = false;
  	    this.prepareRenderableFrame(num);
  	    this.prepareProperties(num, this.isInRange);
  	    if (!this.isInRange && !this.data.xt) {
  	      return;
  	    }
  	    if (!this.tm._placeholder) {
  	      var timeRemapped = this.tm.v;
  	      if (timeRemapped === this.data.op) {
  	        timeRemapped = this.data.op - 1;
  	      }
  	      this.renderedFrame = timeRemapped;
  	    } else {
  	      this.renderedFrame = num / this.data.sr;
  	    }
  	    var i;
  	    var len = this.elements.length;
  	    if (!this.completeLayers) {
  	      this.checkLayers(this.renderedFrame);
  	    }
  	    // This iteration needs to be backwards because of how expressions connect between each other
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.completeLayers || this.elements[i]) {
  	        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
  	        if (this.elements[i]._mdf) {
  	          this._mdf = true;
  	        }
  	      }
  	    }
  	  };
  	  ICompElement.prototype.renderInnerContent = function () {
  	    var i;
  	    var len = this.layers.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.completeLayers || this.elements[i]) {
  	        this.elements[i].renderFrame();
  	      }
  	    }
  	  };
  	  ICompElement.prototype.setElements = function (elems) {
  	    this.elements = elems;
  	  };
  	  ICompElement.prototype.getElements = function () {
  	    return this.elements;
  	  };
  	  ICompElement.prototype.destroyElements = function () {
  	    var i;
  	    var len = this.layers.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.elements[i]) {
  	        this.elements[i].destroy();
  	      }
  	    }
  	  };
  	  ICompElement.prototype.destroy = function () {
  	    this.destroyElements();
  	    this.destroyBaseElement();
  	  };

  	  function SVGCompElement(data, globalData, comp) {
  	    this.layers = data.layers;
  	    this.supports3d = true;
  	    this.completeLayers = false;
  	    this.pendingElements = [];
  	    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  	    this.initElement(data, globalData, comp);
  	    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
  	      _placeholder: true
  	    };
  	  }
  	  extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
  	  SVGCompElement.prototype.createComp = function (data) {
  	    return new SVGCompElement(data, this.globalData, this);
  	  };

  	  function SVGRenderer(animationItem, config) {
  	    this.animationItem = animationItem;
  	    this.layers = null;
  	    this.renderedFrame = -1;
  	    this.svgElement = createNS('svg');
  	    var ariaLabel = '';
  	    if (config && config.title) {
  	      var titleElement = createNS('title');
  	      var titleId = createElementID();
  	      titleElement.setAttribute('id', titleId);
  	      titleElement.textContent = config.title;
  	      this.svgElement.appendChild(titleElement);
  	      ariaLabel += titleId;
  	    }
  	    if (config && config.description) {
  	      var descElement = createNS('desc');
  	      var descId = createElementID();
  	      descElement.setAttribute('id', descId);
  	      descElement.textContent = config.description;
  	      this.svgElement.appendChild(descElement);
  	      ariaLabel += ' ' + descId;
  	    }
  	    if (ariaLabel) {
  	      this.svgElement.setAttribute('aria-labelledby', ariaLabel);
  	    }
  	    var defs = createNS('defs');
  	    this.svgElement.appendChild(defs);
  	    var maskElement = createNS('g');
  	    this.svgElement.appendChild(maskElement);
  	    this.layerElement = maskElement;
  	    this.renderConfig = {
  	      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
  	      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
  	      contentVisibility: config && config.contentVisibility || 'visible',
  	      progressiveLoad: config && config.progressiveLoad || false,
  	      hideOnTransparent: !(config && config.hideOnTransparent === false),
  	      viewBoxOnly: config && config.viewBoxOnly || false,
  	      viewBoxSize: config && config.viewBoxSize || false,
  	      className: config && config.className || '',
  	      id: config && config.id || '',
  	      focusable: config && config.focusable,
  	      filterSize: {
  	        width: config && config.filterSize && config.filterSize.width || '100%',
  	        height: config && config.filterSize && config.filterSize.height || '100%',
  	        x: config && config.filterSize && config.filterSize.x || '0%',
  	        y: config && config.filterSize && config.filterSize.y || '0%'
  	      },
  	      width: config && config.width,
  	      height: config && config.height,
  	      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
  	    };
  	    this.globalData = {
  	      _mdf: false,
  	      frameNum: -1,
  	      defs: defs,
  	      renderConfig: this.renderConfig
  	    };
  	    this.elements = [];
  	    this.pendingElements = [];
  	    this.destroyed = false;
  	    this.rendererType = 'svg';
  	  }
  	  extendPrototype([SVGRendererBase], SVGRenderer);
  	  SVGRenderer.prototype.createComp = function (data) {
  	    return new SVGCompElement(data, this.globalData, this);
  	  };

  	  function ShapeTransformManager() {
  	    this.sequences = {};
  	    this.sequenceList = [];
  	    this.transform_key_count = 0;
  	  }
  	  ShapeTransformManager.prototype = {
  	    addTransformSequence: function addTransformSequence(transforms) {
  	      var i;
  	      var len = transforms.length;
  	      var key = '_';
  	      for (i = 0; i < len; i += 1) {
  	        key += transforms[i].transform.key + '_';
  	      }
  	      var sequence = this.sequences[key];
  	      if (!sequence) {
  	        sequence = {
  	          transforms: [].concat(transforms),
  	          finalTransform: new Matrix(),
  	          _mdf: false
  	        };
  	        this.sequences[key] = sequence;
  	        this.sequenceList.push(sequence);
  	      }
  	      return sequence;
  	    },
  	    processSequence: function processSequence(sequence, isFirstFrame) {
  	      var i = 0;
  	      var len = sequence.transforms.length;
  	      var _mdf = isFirstFrame;
  	      while (i < len && !isFirstFrame) {
  	        if (sequence.transforms[i].transform.mProps._mdf) {
  	          _mdf = true;
  	          break;
  	        }
  	        i += 1;
  	      }
  	      if (_mdf) {
  	        sequence.finalTransform.reset();
  	        for (i = len - 1; i >= 0; i -= 1) {
  	          sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
  	        }
  	      }
  	      sequence._mdf = _mdf;
  	    },
  	    processSequences: function processSequences(isFirstFrame) {
  	      var i;
  	      var len = this.sequenceList.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.processSequence(this.sequenceList[i], isFirstFrame);
  	      }
  	    },
  	    getNewKey: function getNewKey() {
  	      this.transform_key_count += 1;
  	      return '_' + this.transform_key_count;
  	    }
  	  };

  	  var lumaLoader = function lumaLoader() {
  	    var id = '__lottie_element_luma_buffer';
  	    var lumaBuffer = null;
  	    var lumaBufferCtx = null;
  	    var svg = null;

  	    // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
  	    // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
  	    // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
  	    // Naming it solution 2 to mark the extra comment lines.
  	    /*
  	    var svgString = [
  	      '<svg xmlns="http://www.w3.org/2000/svg">',
  	      '<filter id="' + id + '">',
  	      '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
  	      '0.3, 0.3, 0.3, 0, 0, ',
  	      '0.3, 0.3, 0.3, 0, 0, ',
  	      '0.3, 0.3, 0.3, 0, 0, ',
  	      '0.3, 0.3, 0.3, 0, 0',
  	      '"/>',
  	      '</filter>',
  	      '</svg>',
  	    ].join('');
  	    var blob = new Blob([svgString], { type: 'image/svg+xml' });
  	    var url = URL.createObjectURL(blob);
  	    */

  	    function createLumaSvgFilter() {
  	      var _svg = createNS('svg');
  	      var fil = createNS('filter');
  	      var matrix = createNS('feColorMatrix');
  	      fil.setAttribute('id', id);
  	      matrix.setAttribute('type', 'matrix');
  	      matrix.setAttribute('color-interpolation-filters', 'sRGB');
  	      matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');
  	      fil.appendChild(matrix);
  	      _svg.appendChild(fil);
  	      _svg.setAttribute('id', id + '_svg');
  	      if (featureSupport.svgLumaHidden) {
  	        _svg.style.display = 'none';
  	      }
  	      return _svg;
  	    }
  	    function loadLuma() {
  	      if (!lumaBuffer) {
  	        svg = createLumaSvgFilter();
  	        document.body.appendChild(svg);
  	        lumaBuffer = createTag('canvas');
  	        lumaBufferCtx = lumaBuffer.getContext('2d');
  	        // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
  	        lumaBufferCtx.filter = 'url(#' + id + ')';
  	        lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';
  	        lumaBufferCtx.fillRect(0, 0, 1, 1);
  	      }
  	    }
  	    function getLuma(canvas) {
  	      if (!lumaBuffer) {
  	        loadLuma();
  	      }
  	      lumaBuffer.width = canvas.width;
  	      lumaBuffer.height = canvas.height;
  	      // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
  	      lumaBufferCtx.filter = 'url(#' + id + ')';
  	      return lumaBuffer;
  	    }
  	    return {
  	      load: loadLuma,
  	      get: getLuma
  	    };
  	  };
  	  function createCanvas(width, height) {
  	    if (featureSupport.offscreenCanvas) {
  	      return new OffscreenCanvas(width, height);
  	    }
  	    var canvas = createTag('canvas');
  	    canvas.width = width;
  	    canvas.height = height;
  	    return canvas;
  	  }
  	  var assetLoader = function () {
  	    return {
  	      loadLumaCanvas: lumaLoader.load,
  	      getLumaCanvas: lumaLoader.get,
  	      createCanvas: createCanvas
  	    };
  	  }();

  	  var registeredEffects = {};
  	  function CVEffects(elem) {
  	    var i;
  	    var len = elem.data.ef ? elem.data.ef.length : 0;
  	    this.filters = [];
  	    var filterManager;
  	    for (i = 0; i < len; i += 1) {
  	      filterManager = null;
  	      var type = elem.data.ef[i].ty;
  	      if (registeredEffects[type]) {
  	        var Effect = registeredEffects[type].effect;
  	        filterManager = new Effect(elem.effectsManager.effectElements[i], elem);
  	      }
  	      if (filterManager) {
  	        this.filters.push(filterManager);
  	      }
  	    }
  	    if (this.filters.length) {
  	      elem.addRenderableComponent(this);
  	    }
  	  }
  	  CVEffects.prototype.renderFrame = function (_isFirstFrame) {
  	    var i;
  	    var len = this.filters.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.filters[i].renderFrame(_isFirstFrame);
  	    }
  	  };
  	  CVEffects.prototype.getEffects = function (type) {
  	    var i;
  	    var len = this.filters.length;
  	    var effects = [];
  	    for (i = 0; i < len; i += 1) {
  	      if (this.filters[i].type === type) {
  	        effects.push(this.filters[i]);
  	      }
  	    }
  	    return effects;
  	  };
  	  function registerEffect(id, effect) {
  	    registeredEffects[id] = {
  	      effect: effect
  	    };
  	  }

  	  function CVMaskElement(data, element) {
  	    this.data = data;
  	    this.element = element;
  	    this.masksProperties = this.data.masksProperties || [];
  	    this.viewData = createSizedArray(this.masksProperties.length);
  	    var i;
  	    var len = this.masksProperties.length;
  	    var hasMasks = false;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.masksProperties[i].mode !== 'n') {
  	        hasMasks = true;
  	      }
  	      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
  	    }
  	    this.hasMasks = hasMasks;
  	    if (hasMasks) {
  	      this.element.addRenderableComponent(this);
  	    }
  	  }
  	  CVMaskElement.prototype.renderFrame = function () {
  	    if (!this.hasMasks) {
  	      return;
  	    }
  	    var transform = this.element.finalTransform.mat;
  	    var ctx = this.element.canvasContext;
  	    var i;
  	    var len = this.masksProperties.length;
  	    var pt;
  	    var pts;
  	    var data;
  	    ctx.beginPath();
  	    for (i = 0; i < len; i += 1) {
  	      if (this.masksProperties[i].mode !== 'n') {
  	        if (this.masksProperties[i].inv) {
  	          ctx.moveTo(0, 0);
  	          ctx.lineTo(this.element.globalData.compSize.w, 0);
  	          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
  	          ctx.lineTo(0, this.element.globalData.compSize.h);
  	          ctx.lineTo(0, 0);
  	        }
  	        data = this.viewData[i].v;
  	        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
  	        ctx.moveTo(pt[0], pt[1]);
  	        var j;
  	        var jLen = data._length;
  	        for (j = 1; j < jLen; j += 1) {
  	          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
  	          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
  	        }
  	        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
  	        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
  	      }
  	    }
  	    this.element.globalData.renderer.save(true);
  	    ctx.clip();
  	  };
  	  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
  	  CVMaskElement.prototype.destroy = function () {
  	    this.element = null;
  	  };

  	  function CVBaseElement() {}
  	  var operationsMap = {
  	    1: 'source-in',
  	    2: 'source-out',
  	    3: 'source-in',
  	    4: 'source-out'
  	  };
  	  CVBaseElement.prototype = {
  	    createElements: function createElements() {},
  	    initRendererElement: function initRendererElement() {},
  	    createContainerElements: function createContainerElements() {
  	      // If the layer is masked we will use two buffers to store each different states of the drawing
  	      // This solution is not ideal for several reason. But unfortunately, because of the recursive
  	      // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
  	      // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
  	      // It might be challenging because the layer most likely is transformed in some way
  	      if (this.data.tt >= 1) {
  	        this.buffers = [];
  	        var canvasContext = this.globalData.canvasContext;
  	        var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
  	        this.buffers.push(bufferCanvas);
  	        var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
  	        this.buffers.push(bufferCanvas2);
  	        if (this.data.tt >= 3 && !document._isProxy) {
  	          assetLoader.loadLumaCanvas();
  	        }
  	      }
  	      this.canvasContext = this.globalData.canvasContext;
  	      this.transformCanvas = this.globalData.transformCanvas;
  	      this.renderableEffectsManager = new CVEffects(this);
  	      this.searchEffectTransforms();
  	    },
  	    createContent: function createContent() {},
  	    setBlendMode: function setBlendMode() {
  	      var globalData = this.globalData;
  	      if (globalData.blendMode !== this.data.bm) {
  	        globalData.blendMode = this.data.bm;
  	        var blendModeValue = getBlendMode(this.data.bm);
  	        globalData.canvasContext.globalCompositeOperation = blendModeValue;
  	      }
  	    },
  	    createRenderableComponents: function createRenderableComponents() {
  	      this.maskManager = new CVMaskElement(this.data, this);
  	      this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
  	    },
  	    hideElement: function hideElement() {
  	      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
  	        this.hidden = true;
  	      }
  	    },
  	    showElement: function showElement() {
  	      if (this.isInRange && !this.isTransparent) {
  	        this.hidden = false;
  	        this._isFirstFrame = true;
  	        this.maskManager._isFirstFrame = true;
  	      }
  	    },
  	    clearCanvas: function clearCanvas(canvasContext) {
  	      canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
  	    },
  	    prepareLayer: function prepareLayer() {
  	      if (this.data.tt >= 1) {
  	        var buffer = this.buffers[0];
  	        var bufferCtx = buffer.getContext('2d');
  	        this.clearCanvas(bufferCtx);
  	        // on the first buffer we store the current state of the global drawing
  	        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
  	        // The next four lines are to clear the canvas
  	        // TODO: Check if there is a way to clear the canvas without resetting the transform
  	        this.currentTransform = this.canvasContext.getTransform();
  	        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
  	        this.clearCanvas(this.canvasContext);
  	        this.canvasContext.setTransform(this.currentTransform);
  	      }
  	    },
  	    exitLayer: function exitLayer() {
  	      if (this.data.tt >= 1) {
  	        var buffer = this.buffers[1];
  	        // On the second buffer we store the current state of the global drawing
  	        // that only contains the content of this layer
  	        // (if it is a composition, it also includes the nested layers)
  	        var bufferCtx = buffer.getContext('2d');
  	        this.clearCanvas(bufferCtx);
  	        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
  	        // We clear the canvas again
  	        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
  	        this.clearCanvas(this.canvasContext);
  	        this.canvasContext.setTransform(this.currentTransform);
  	        // We draw the mask
  	        var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);
  	        mask.renderFrame(true);
  	        // We draw the second buffer (that contains the content of this layer)
  	        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);

  	        // If the mask is a Luma matte, we need to do two extra painting operations
  	        // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error
  	        if (this.data.tt >= 3 && !document._isProxy) {
  	          // We copy the painted mask to a buffer that has a color matrix filter applied to it
  	          // that applies the rgb values to the alpha channel
  	          var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
  	          var lumaBufferCtx = lumaBuffer.getContext('2d');
  	          lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
  	          this.clearCanvas(this.canvasContext);
  	          // we repaint the context with the mask applied to it
  	          this.canvasContext.drawImage(lumaBuffer, 0, 0);
  	        }
  	        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
  	        this.canvasContext.drawImage(buffer, 0, 0);
  	        // We finally draw the first buffer (that contains the content of the global drawing)
  	        // We use destination-over to draw the global drawing below the current layer
  	        this.canvasContext.globalCompositeOperation = 'destination-over';
  	        this.canvasContext.drawImage(this.buffers[0], 0, 0);
  	        this.canvasContext.setTransform(this.currentTransform);
  	        // We reset the globalCompositeOperation to source-over, the standard type of operation
  	        this.canvasContext.globalCompositeOperation = 'source-over';
  	      }
  	    },
  	    renderFrame: function renderFrame(forceRender) {
  	      if (this.hidden || this.data.hd) {
  	        return;
  	      }
  	      if (this.data.td === 1 && !forceRender) {
  	        return;
  	      }
  	      this.renderTransform();
  	      this.renderRenderable();
  	      this.renderLocalTransform();
  	      this.setBlendMode();
  	      var forceRealStack = this.data.ty === 0;
  	      this.prepareLayer();
  	      this.globalData.renderer.save(forceRealStack);
  	      this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
  	      this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
  	      this.renderInnerContent();
  	      this.globalData.renderer.restore(forceRealStack);
  	      this.exitLayer();
  	      if (this.maskManager.hasMasks) {
  	        this.globalData.renderer.restore(true);
  	      }
  	      if (this._isFirstFrame) {
  	        this._isFirstFrame = false;
  	      }
  	    },
  	    destroy: function destroy() {
  	      this.canvasContext = null;
  	      this.data = null;
  	      this.globalData = null;
  	      this.maskManager.destroy();
  	    },
  	    mHelper: new Matrix()
  	  };
  	  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
  	  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

  	  function CVShapeData(element, data, styles, transformsManager) {
  	    this.styledShapes = [];
  	    this.tr = [0, 0, 0, 0, 0, 0];
  	    var ty = 4;
  	    if (data.ty === 'rc') {
  	      ty = 5;
  	    } else if (data.ty === 'el') {
  	      ty = 6;
  	    } else if (data.ty === 'sr') {
  	      ty = 7;
  	    }
  	    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
  	    var i;
  	    var len = styles.length;
  	    var styledShape;
  	    for (i = 0; i < len; i += 1) {
  	      if (!styles[i].closed) {
  	        styledShape = {
  	          transforms: transformsManager.addTransformSequence(styles[i].transforms),
  	          trNodes: []
  	        };
  	        this.styledShapes.push(styledShape);
  	        styles[i].elements.push(styledShape);
  	      }
  	    }
  	  }
  	  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

  	  function CVShapeElement(data, globalData, comp) {
  	    this.shapes = [];
  	    this.shapesData = data.shapes;
  	    this.stylesList = [];
  	    this.itemsData = [];
  	    this.prevViewData = [];
  	    this.shapeModifiers = [];
  	    this.processedElements = [];
  	    this.transformsManager = new ShapeTransformManager();
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
  	  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
  	  CVShapeElement.prototype.transformHelper = {
  	    opacity: 1,
  	    _opMdf: false
  	  };
  	  CVShapeElement.prototype.dashResetter = [];
  	  CVShapeElement.prototype.createContent = function () {
  	    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
  	  };
  	  CVShapeElement.prototype.createStyleElement = function (data, transforms) {
  	    var styleElem = {
  	      data: data,
  	      type: data.ty,
  	      preTransforms: this.transformsManager.addTransformSequence(transforms),
  	      transforms: [],
  	      elements: [],
  	      closed: data.hd === true
  	    };
  	    var elementData = {};
  	    if (data.ty === 'fl' || data.ty === 'st') {
  	      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
  	      if (!elementData.c.k) {
  	        styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
  	      }
  	    } else if (data.ty === 'gf' || data.ty === 'gs') {
  	      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
  	      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
  	      elementData.h = PropertyFactory.getProp(this, data.h || {
  	        k: 0
  	      }, 0, 0.01, this);
  	      elementData.a = PropertyFactory.getProp(this, data.a || {
  	        k: 0
  	      }, 0, degToRads, this);
  	      elementData.g = new GradientProperty(this, data.g, this);
  	    }
  	    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
  	    if (data.ty === 'st' || data.ty === 'gs') {
  	      styleElem.lc = lineCapEnum[data.lc || 2];
  	      styleElem.lj = lineJoinEnum[data.lj || 2];
  	      if (data.lj == 1) {
  	        // eslint-disable-line eqeqeq
  	        styleElem.ml = data.ml;
  	      }
  	      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
  	      if (!elementData.w.k) {
  	        styleElem.wi = elementData.w.v;
  	      }
  	      if (data.d) {
  	        var d = new DashProperty(this, data.d, 'canvas', this);
  	        elementData.d = d;
  	        if (!elementData.d.k) {
  	          styleElem.da = elementData.d.dashArray;
  	          styleElem["do"] = elementData.d.dashoffset[0];
  	        }
  	      }
  	    } else {
  	      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
  	    }
  	    this.stylesList.push(styleElem);
  	    elementData.style = styleElem;
  	    return elementData;
  	  };
  	  CVShapeElement.prototype.createGroupElement = function () {
  	    var elementData = {
  	      it: [],
  	      prevViewData: []
  	    };
  	    return elementData;
  	  };
  	  CVShapeElement.prototype.createTransformElement = function (data) {
  	    var elementData = {
  	      transform: {
  	        opacity: 1,
  	        _opMdf: false,
  	        key: this.transformsManager.getNewKey(),
  	        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
  	        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
  	      }
  	    };
  	    return elementData;
  	  };
  	  CVShapeElement.prototype.createShapeElement = function (data) {
  	    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
  	    this.shapes.push(elementData);
  	    this.addShapeToModifiers(elementData);
  	    return elementData;
  	  };
  	  CVShapeElement.prototype.reloadShapes = function () {
  	    this._isFirstFrame = true;
  	    var i;
  	    var len = this.itemsData.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.prevViewData[i] = this.itemsData[i];
  	    }
  	    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
  	    len = this.dynamicProperties.length;
  	    for (i = 0; i < len; i += 1) {
  	      this.dynamicProperties[i].getValue();
  	    }
  	    this.renderModifiers();
  	    this.transformsManager.processSequences(this._isFirstFrame);
  	  };
  	  CVShapeElement.prototype.addTransformToStyleList = function (transform) {
  	    var i;
  	    var len = this.stylesList.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (!this.stylesList[i].closed) {
  	        this.stylesList[i].transforms.push(transform);
  	      }
  	    }
  	  };
  	  CVShapeElement.prototype.removeTransformFromStyleList = function () {
  	    var i;
  	    var len = this.stylesList.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (!this.stylesList[i].closed) {
  	        this.stylesList[i].transforms.pop();
  	      }
  	    }
  	  };
  	  CVShapeElement.prototype.closeStyles = function (styles) {
  	    var i;
  	    var len = styles.length;
  	    for (i = 0; i < len; i += 1) {
  	      styles[i].closed = true;
  	    }
  	  };
  	  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
  	    var i;
  	    var len = arr.length - 1;
  	    var j;
  	    var jLen;
  	    var ownStyles = [];
  	    var ownModifiers = [];
  	    var processedPos;
  	    var modifier;
  	    var currentTransform;
  	    var ownTransforms = [].concat(transforms);
  	    for (i = len; i >= 0; i -= 1) {
  	      processedPos = this.searchProcessedElement(arr[i]);
  	      if (!processedPos) {
  	        arr[i]._shouldRender = shouldRender;
  	      } else {
  	        itemsData[i] = prevViewData[processedPos - 1];
  	      }
  	      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
  	        } else {
  	          itemsData[i].style.closed = false;
  	        }
  	        ownStyles.push(itemsData[i].style);
  	      } else if (arr[i].ty === 'gr') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createGroupElement(arr[i]);
  	        } else {
  	          jLen = itemsData[i].it.length;
  	          for (j = 0; j < jLen; j += 1) {
  	            itemsData[i].prevViewData[j] = itemsData[i].it[j];
  	          }
  	        }
  	        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
  	      } else if (arr[i].ty === 'tr') {
  	        if (!processedPos) {
  	          currentTransform = this.createTransformElement(arr[i]);
  	          itemsData[i] = currentTransform;
  	        }
  	        ownTransforms.push(itemsData[i]);
  	        this.addTransformToStyleList(itemsData[i]);
  	      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
  	        if (!processedPos) {
  	          itemsData[i] = this.createShapeElement(arr[i]);
  	        }
  	      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
  	        if (!processedPos) {
  	          modifier = ShapeModifiers.getModifier(arr[i].ty);
  	          modifier.init(this, arr[i]);
  	          itemsData[i] = modifier;
  	          this.shapeModifiers.push(modifier);
  	        } else {
  	          modifier = itemsData[i];
  	          modifier.closed = false;
  	        }
  	        ownModifiers.push(modifier);
  	      } else if (arr[i].ty === 'rp') {
  	        if (!processedPos) {
  	          modifier = ShapeModifiers.getModifier(arr[i].ty);
  	          itemsData[i] = modifier;
  	          modifier.init(this, arr, i, itemsData);
  	          this.shapeModifiers.push(modifier);
  	          shouldRender = false;
  	        } else {
  	          modifier = itemsData[i];
  	          modifier.closed = true;
  	        }
  	        ownModifiers.push(modifier);
  	      }
  	      this.addProcessedElement(arr[i], i + 1);
  	    }
  	    this.removeTransformFromStyleList();
  	    this.closeStyles(ownStyles);
  	    len = ownModifiers.length;
  	    for (i = 0; i < len; i += 1) {
  	      ownModifiers[i].closed = true;
  	    }
  	  };
  	  CVShapeElement.prototype.renderInnerContent = function () {
  	    this.transformHelper.opacity = 1;
  	    this.transformHelper._opMdf = false;
  	    this.renderModifiers();
  	    this.transformsManager.processSequences(this._isFirstFrame);
  	    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
  	  };
  	  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
  	    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
  	      groupTransform.opacity = parentTransform.opacity;
  	      groupTransform.opacity *= groupTransform.op.v;
  	      groupTransform._opMdf = true;
  	    }
  	  };
  	  CVShapeElement.prototype.drawLayer = function () {
  	    var i;
  	    var len = this.stylesList.length;
  	    var j;
  	    var jLen;
  	    var k;
  	    var kLen;
  	    var elems;
  	    var nodes;
  	    var renderer = this.globalData.renderer;
  	    var ctx = this.globalData.canvasContext;
  	    var type;
  	    var currentStyle;
  	    for (i = 0; i < len; i += 1) {
  	      currentStyle = this.stylesList[i];
  	      type = currentStyle.type;

  	      // Skipping style when
  	      // Stroke width equals 0
  	      // style should not be rendered (extra unused repeaters)
  	      // current opacity equals 0
  	      // global opacity equals 0
  	      if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
  	        renderer.save();
  	        elems = currentStyle.elements;
  	        if (type === 'st' || type === 'gs') {
  	          renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd);
  	          // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
  	          renderer.ctxLineWidth(currentStyle.wi);
  	          // ctx.lineWidth = currentStyle.wi;
  	          renderer.ctxLineCap(currentStyle.lc);
  	          // ctx.lineCap = currentStyle.lc;
  	          renderer.ctxLineJoin(currentStyle.lj);
  	          // ctx.lineJoin = currentStyle.lj;
  	          renderer.ctxMiterLimit(currentStyle.ml || 0);
  	          // ctx.miterLimit = currentStyle.ml || 0;
  	        } else {
  	          renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd);
  	          // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
  	        }
  	        renderer.ctxOpacity(currentStyle.coOp);
  	        if (type !== 'st' && type !== 'gs') {
  	          ctx.beginPath();
  	        }
  	        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
  	        jLen = elems.length;
  	        for (j = 0; j < jLen; j += 1) {
  	          if (type === 'st' || type === 'gs') {
  	            ctx.beginPath();
  	            if (currentStyle.da) {
  	              ctx.setLineDash(currentStyle.da);
  	              ctx.lineDashOffset = currentStyle["do"];
  	            }
  	          }
  	          nodes = elems[j].trNodes;
  	          kLen = nodes.length;
  	          for (k = 0; k < kLen; k += 1) {
  	            if (nodes[k].t === 'm') {
  	              ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
  	            } else if (nodes[k].t === 'c') {
  	              ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
  	            } else {
  	              ctx.closePath();
  	            }
  	          }
  	          if (type === 'st' || type === 'gs') {
  	            // ctx.stroke();
  	            renderer.ctxStroke();
  	            if (currentStyle.da) {
  	              ctx.setLineDash(this.dashResetter);
  	            }
  	          }
  	        }
  	        if (type !== 'st' && type !== 'gs') {
  	          // ctx.fill(currentStyle.r);
  	          this.globalData.renderer.ctxFill(currentStyle.r);
  	        }
  	        renderer.restore();
  	      }
  	    }
  	  };
  	  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
  	    var i;
  	    var len = items.length - 1;
  	    var groupTransform;
  	    groupTransform = parentTransform;
  	    for (i = len; i >= 0; i -= 1) {
  	      if (items[i].ty === 'tr') {
  	        groupTransform = data[i].transform;
  	        this.renderShapeTransform(parentTransform, groupTransform);
  	      } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
  	        this.renderPath(items[i], data[i]);
  	      } else if (items[i].ty === 'fl') {
  	        this.renderFill(items[i], data[i], groupTransform);
  	      } else if (items[i].ty === 'st') {
  	        this.renderStroke(items[i], data[i], groupTransform);
  	      } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
  	        this.renderGradientFill(items[i], data[i], groupTransform);
  	      } else if (items[i].ty === 'gr') {
  	        this.renderShape(groupTransform, items[i].it, data[i].it);
  	      } else if (items[i].ty === 'tm') ;
  	    }
  	    if (isMain) {
  	      this.drawLayer();
  	    }
  	  };
  	  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
  	    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
  	      var shapeNodes = styledShape.trNodes;
  	      var paths = shape.paths;
  	      var i;
  	      var len;
  	      var j;
  	      var jLen = paths._length;
  	      shapeNodes.length = 0;
  	      var groupTransformMat = styledShape.transforms.finalTransform;
  	      for (j = 0; j < jLen; j += 1) {
  	        var pathNodes = paths.shapes[j];
  	        if (pathNodes && pathNodes.v) {
  	          len = pathNodes._length;
  	          for (i = 1; i < len; i += 1) {
  	            if (i === 1) {
  	              shapeNodes.push({
  	                t: 'm',
  	                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
  	              });
  	            }
  	            shapeNodes.push({
  	              t: 'c',
  	              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
  	            });
  	          }
  	          if (len === 1) {
  	            shapeNodes.push({
  	              t: 'm',
  	              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
  	            });
  	          }
  	          if (pathNodes.c && len) {
  	            shapeNodes.push({
  	              t: 'c',
  	              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
  	            });
  	            shapeNodes.push({
  	              t: 'z'
  	            });
  	          }
  	        }
  	      }
  	      styledShape.trNodes = shapeNodes;
  	    }
  	  };
  	  CVShapeElement.prototype.renderPath = function (pathData, itemData) {
  	    if (pathData.hd !== true && pathData._shouldRender) {
  	      var i;
  	      var len = itemData.styledShapes.length;
  	      for (i = 0; i < len; i += 1) {
  	        this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
  	      }
  	    }
  	  };
  	  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
  	    var styleElem = itemData.style;
  	    if (itemData.c._mdf || this._isFirstFrame) {
  	      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
  	    }
  	    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
  	      styleElem.coOp = itemData.o.v * groupTransform.opacity;
  	    }
  	  };
  	  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
  	    var styleElem = itemData.style;
  	    var grd;
  	    if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
  	      var ctx = this.globalData.canvasContext;
  	      var pt1 = itemData.s.v;
  	      var pt2 = itemData.e.v;
  	      if (styleData.t === 1) {
  	        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
  	      } else {
  	        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
  	        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
  	        var percent = itemData.h.v;
  	        if (percent >= 1) {
  	          percent = 0.99;
  	        } else if (percent <= -1) {
  	          percent = -0.99;
  	        }
  	        var dist = rad * percent;
  	        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
  	        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
  	        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
  	      }
  	      var i;
  	      var len = styleData.g.p;
  	      var cValues = itemData.g.c;
  	      var opacity = 1;
  	      for (i = 0; i < len; i += 1) {
  	        if (itemData.g._hasOpacity && itemData.g._collapsable) {
  	          opacity = itemData.g.o[i * 2 + 1];
  	        }
  	        grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
  	      }
  	      styleElem.grd = grd;
  	    }
  	    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  	  };
  	  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
  	    var styleElem = itemData.style;
  	    var d = itemData.d;
  	    if (d && (d._mdf || this._isFirstFrame)) {
  	      styleElem.da = d.dashArray;
  	      styleElem["do"] = d.dashoffset[0];
  	    }
  	    if (itemData.c._mdf || this._isFirstFrame) {
  	      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
  	    }
  	    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
  	      styleElem.coOp = itemData.o.v * groupTransform.opacity;
  	    }
  	    if (itemData.w._mdf || this._isFirstFrame) {
  	      styleElem.wi = itemData.w.v;
  	    }
  	  };
  	  CVShapeElement.prototype.destroy = function () {
  	    this.shapesData = null;
  	    this.globalData = null;
  	    this.canvasContext = null;
  	    this.stylesList.length = 0;
  	    this.itemsData.length = 0;
  	  };

  	  function CVTextElement(data, globalData, comp) {
  	    this.textSpans = [];
  	    this.yOffset = 0;
  	    this.fillColorAnim = false;
  	    this.strokeColorAnim = false;
  	    this.strokeWidthAnim = false;
  	    this.stroke = false;
  	    this.fill = false;
  	    this.justifyOffset = 0;
  	    this.currentRender = null;
  	    this.renderType = 'canvas';
  	    this.values = {
  	      fill: 'rgba(0,0,0,0)',
  	      stroke: 'rgba(0,0,0,0)',
  	      sWidth: 0,
  	      fValue: ''
  	    };
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
  	  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');
  	  CVTextElement.prototype.buildNewText = function () {
  	    var documentData = this.textProperty.currentData;
  	    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
  	    var hasFill = false;
  	    if (documentData.fc) {
  	      hasFill = true;
  	      this.values.fill = this.buildColor(documentData.fc);
  	    } else {
  	      this.values.fill = 'rgba(0,0,0,0)';
  	    }
  	    this.fill = hasFill;
  	    var hasStroke = false;
  	    if (documentData.sc) {
  	      hasStroke = true;
  	      this.values.stroke = this.buildColor(documentData.sc);
  	      this.values.sWidth = documentData.sw;
  	    }
  	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  	    var i;
  	    var len;
  	    var letters = documentData.l;
  	    var matrixHelper = this.mHelper;
  	    this.stroke = hasStroke;
  	    this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
  	    len = documentData.finalText.length;
  	    // this.tHelper.font = this.values.fValue;
  	    var charData;
  	    var shapeData;
  	    var k;
  	    var kLen;
  	    var shapes;
  	    var j;
  	    var jLen;
  	    var pathNodes;
  	    var commands;
  	    var pathArr;
  	    var singleShape = this.data.singleShape;
  	    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  	    var xPos = 0;
  	    var yPos = 0;
  	    var firstLine = true;
  	    var cnt = 0;
  	    for (i = 0; i < len; i += 1) {
  	      charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
  	      shapeData = charData && charData.data || {};
  	      matrixHelper.reset();
  	      if (singleShape && letters[i].n) {
  	        xPos = -trackingOffset;
  	        yPos += documentData.yOffset;
  	        yPos += firstLine ? 1 : 0;
  	        firstLine = false;
  	      }
  	      shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
  	      jLen = shapes.length;
  	      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
  	      if (singleShape) {
  	        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
  	      }
  	      commands = createSizedArray(jLen - 1);
  	      var commandsCounter = 0;
  	      for (j = 0; j < jLen; j += 1) {
  	        if (shapes[j].ty === 'sh') {
  	          kLen = shapes[j].ks.k.i.length;
  	          pathNodes = shapes[j].ks.k;
  	          pathArr = [];
  	          for (k = 1; k < kLen; k += 1) {
  	            if (k === 1) {
  	              pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
  	            }
  	            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
  	          }
  	          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
  	          commands[commandsCounter] = pathArr;
  	          commandsCounter += 1;
  	        }
  	      }
  	      if (singleShape) {
  	        xPos += letters[i].l;
  	        xPos += trackingOffset;
  	      }
  	      if (this.textSpans[cnt]) {
  	        this.textSpans[cnt].elem = commands;
  	      } else {
  	        this.textSpans[cnt] = {
  	          elem: commands
  	        };
  	      }
  	      cnt += 1;
  	    }
  	  };
  	  CVTextElement.prototype.renderInnerContent = function () {
  	    this.validateText();
  	    var ctx = this.canvasContext;
  	    ctx.font = this.values.fValue;
  	    this.globalData.renderer.ctxLineCap('butt');
  	    // ctx.lineCap = 'butt';
  	    this.globalData.renderer.ctxLineJoin('miter');
  	    // ctx.lineJoin = 'miter';
  	    this.globalData.renderer.ctxMiterLimit(4);
  	    // ctx.miterLimit = 4;

  	    if (!this.data.singleShape) {
  	      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  	    }
  	    var i;
  	    var len;
  	    var j;
  	    var jLen;
  	    var k;
  	    var kLen;
  	    var renderedLetters = this.textAnimator.renderedLetters;
  	    var letters = this.textProperty.currentData.l;
  	    len = letters.length;
  	    var renderedLetter;
  	    var lastFill = null;
  	    var lastStroke = null;
  	    var lastStrokeW = null;
  	    var commands;
  	    var pathArr;
  	    var renderer = this.globalData.renderer;
  	    for (i = 0; i < len; i += 1) {
  	      if (!letters[i].n) {
  	        renderedLetter = renderedLetters[i];
  	        if (renderedLetter) {
  	          renderer.save();
  	          renderer.ctxTransform(renderedLetter.p);
  	          renderer.ctxOpacity(renderedLetter.o);
  	        }
  	        if (this.fill) {
  	          if (renderedLetter && renderedLetter.fc) {
  	            if (lastFill !== renderedLetter.fc) {
  	              renderer.ctxFillStyle(renderedLetter.fc);
  	              lastFill = renderedLetter.fc;
  	              // ctx.fillStyle = renderedLetter.fc;
  	            }
  	          } else if (lastFill !== this.values.fill) {
  	            lastFill = this.values.fill;
  	            renderer.ctxFillStyle(this.values.fill);
  	            // ctx.fillStyle = this.values.fill;
  	          }
  	          commands = this.textSpans[i].elem;
  	          jLen = commands.length;
  	          this.globalData.canvasContext.beginPath();
  	          for (j = 0; j < jLen; j += 1) {
  	            pathArr = commands[j];
  	            kLen = pathArr.length;
  	            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
  	            for (k = 2; k < kLen; k += 6) {
  	              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
  	            }
  	          }
  	          this.globalData.canvasContext.closePath();
  	          renderer.ctxFill();
  	          // this.globalData.canvasContext.fill();
  	          /// ctx.fillText(this.textSpans[i].val,0,0);
  	        }
  	        if (this.stroke) {
  	          if (renderedLetter && renderedLetter.sw) {
  	            if (lastStrokeW !== renderedLetter.sw) {
  	              lastStrokeW = renderedLetter.sw;
  	              renderer.ctxLineWidth(renderedLetter.sw);
  	              // ctx.lineWidth = renderedLetter.sw;
  	            }
  	          } else if (lastStrokeW !== this.values.sWidth) {
  	            lastStrokeW = this.values.sWidth;
  	            renderer.ctxLineWidth(this.values.sWidth);
  	            // ctx.lineWidth = this.values.sWidth;
  	          }
  	          if (renderedLetter && renderedLetter.sc) {
  	            if (lastStroke !== renderedLetter.sc) {
  	              lastStroke = renderedLetter.sc;
  	              renderer.ctxStrokeStyle(renderedLetter.sc);
  	              // ctx.strokeStyle = renderedLetter.sc;
  	            }
  	          } else if (lastStroke !== this.values.stroke) {
  	            lastStroke = this.values.stroke;
  	            renderer.ctxStrokeStyle(this.values.stroke);
  	            // ctx.strokeStyle = this.values.stroke;
  	          }
  	          commands = this.textSpans[i].elem;
  	          jLen = commands.length;
  	          this.globalData.canvasContext.beginPath();
  	          for (j = 0; j < jLen; j += 1) {
  	            pathArr = commands[j];
  	            kLen = pathArr.length;
  	            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
  	            for (k = 2; k < kLen; k += 6) {
  	              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
  	            }
  	          }
  	          this.globalData.canvasContext.closePath();
  	          renderer.ctxStroke();
  	          // this.globalData.canvasContext.stroke();
  	          /// ctx.strokeText(letters[i].val,0,0);
  	        }
  	        if (renderedLetter) {
  	          this.globalData.renderer.restore();
  	        }
  	      }
  	    }
  	  };

  	  function CVImageElement(data, globalData, comp) {
  	    this.assetData = globalData.getAssetData(data.refId);
  	    this.img = globalData.imageLoader.getAsset(this.assetData);
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
  	  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
  	  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
  	  CVImageElement.prototype.createContent = function () {
  	    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
  	      var canvas = createTag('canvas');
  	      canvas.width = this.assetData.w;
  	      canvas.height = this.assetData.h;
  	      var ctx = canvas.getContext('2d');
  	      var imgW = this.img.width;
  	      var imgH = this.img.height;
  	      var imgRel = imgW / imgH;
  	      var canvasRel = this.assetData.w / this.assetData.h;
  	      var widthCrop;
  	      var heightCrop;
  	      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
  	      if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
  	        heightCrop = imgH;
  	        widthCrop = heightCrop * canvasRel;
  	      } else {
  	        widthCrop = imgW;
  	        heightCrop = widthCrop / canvasRel;
  	      }
  	      ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
  	      this.img = canvas;
  	    }
  	  };
  	  CVImageElement.prototype.renderInnerContent = function () {
  	    this.canvasContext.drawImage(this.img, 0, 0);
  	  };
  	  CVImageElement.prototype.destroy = function () {
  	    this.img = null;
  	  };

  	  function CVSolidElement(data, globalData, comp) {
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
  	  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
  	  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
  	  CVSolidElement.prototype.renderInnerContent = function () {
  	    // var ctx = this.canvasContext;
  	    this.globalData.renderer.ctxFillStyle(this.data.sc);
  	    // ctx.fillStyle = this.data.sc;
  	    this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
  	    // ctx.fillRect(0, 0, this.data.sw, this.data.sh);
  	    //
  	  };

  	  function CanvasRendererBase() {}
  	  extendPrototype([BaseRenderer], CanvasRendererBase);
  	  CanvasRendererBase.prototype.createShape = function (data) {
  	    return new CVShapeElement(data, this.globalData, this);
  	  };
  	  CanvasRendererBase.prototype.createText = function (data) {
  	    return new CVTextElement(data, this.globalData, this);
  	  };
  	  CanvasRendererBase.prototype.createImage = function (data) {
  	    return new CVImageElement(data, this.globalData, this);
  	  };
  	  CanvasRendererBase.prototype.createSolid = function (data) {
  	    return new CVSolidElement(data, this.globalData, this);
  	  };
  	  CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
  	  CanvasRendererBase.prototype.ctxTransform = function (props) {
  	    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
  	      return;
  	    }
  	    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
  	  };
  	  CanvasRendererBase.prototype.ctxOpacity = function (op) {
  	    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
  	  };
  	  CanvasRendererBase.prototype.ctxFillStyle = function (value) {
  	    this.canvasContext.fillStyle = value;
  	  };
  	  CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {
  	    this.canvasContext.strokeStyle = value;
  	  };
  	  CanvasRendererBase.prototype.ctxLineWidth = function (value) {
  	    this.canvasContext.lineWidth = value;
  	  };
  	  CanvasRendererBase.prototype.ctxLineCap = function (value) {
  	    this.canvasContext.lineCap = value;
  	  };
  	  CanvasRendererBase.prototype.ctxLineJoin = function (value) {
  	    this.canvasContext.lineJoin = value;
  	  };
  	  CanvasRendererBase.prototype.ctxMiterLimit = function (value) {
  	    this.canvasContext.miterLimit = value;
  	  };
  	  CanvasRendererBase.prototype.ctxFill = function (rule) {
  	    this.canvasContext.fill(rule);
  	  };
  	  CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {
  	    this.canvasContext.fillRect(x, y, w, h);
  	  };
  	  CanvasRendererBase.prototype.ctxStroke = function () {
  	    this.canvasContext.stroke();
  	  };
  	  CanvasRendererBase.prototype.reset = function () {
  	    if (!this.renderConfig.clearCanvas) {
  	      this.canvasContext.restore();
  	      return;
  	    }
  	    this.contextData.reset();
  	  };
  	  CanvasRendererBase.prototype.save = function () {
  	    this.canvasContext.save();
  	  };
  	  CanvasRendererBase.prototype.restore = function (actionFlag) {
  	    if (!this.renderConfig.clearCanvas) {
  	      this.canvasContext.restore();
  	      return;
  	    }
  	    if (actionFlag) {
  	      this.globalData.blendMode = 'source-over';
  	    }
  	    this.contextData.restore(actionFlag);
  	  };
  	  CanvasRendererBase.prototype.configAnimation = function (animData) {
  	    if (this.animationItem.wrapper) {
  	      this.animationItem.container = createTag('canvas');
  	      var containerStyle = this.animationItem.container.style;
  	      containerStyle.width = '100%';
  	      containerStyle.height = '100%';
  	      var origin = '0px 0px 0px';
  	      containerStyle.transformOrigin = origin;
  	      containerStyle.mozTransformOrigin = origin;
  	      containerStyle.webkitTransformOrigin = origin;
  	      containerStyle['-webkit-transform'] = origin;
  	      containerStyle.contentVisibility = this.renderConfig.contentVisibility;
  	      this.animationItem.wrapper.appendChild(this.animationItem.container);
  	      this.canvasContext = this.animationItem.container.getContext('2d');
  	      if (this.renderConfig.className) {
  	        this.animationItem.container.setAttribute('class', this.renderConfig.className);
  	      }
  	      if (this.renderConfig.id) {
  	        this.animationItem.container.setAttribute('id', this.renderConfig.id);
  	      }
  	    } else {
  	      this.canvasContext = this.renderConfig.context;
  	    }
  	    this.contextData.setContext(this.canvasContext);
  	    this.data = animData;
  	    this.layers = animData.layers;
  	    this.transformCanvas = {
  	      w: animData.w,
  	      h: animData.h,
  	      sx: 0,
  	      sy: 0,
  	      tx: 0,
  	      ty: 0
  	    };
  	    this.setupGlobalData(animData, document.body);
  	    this.globalData.canvasContext = this.canvasContext;
  	    this.globalData.renderer = this;
  	    this.globalData.isDashed = false;
  	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  	    this.globalData.transformCanvas = this.transformCanvas;
  	    this.elements = createSizedArray(animData.layers.length);
  	    this.updateContainerSize();
  	  };
  	  CanvasRendererBase.prototype.updateContainerSize = function (width, height) {
  	    this.reset();
  	    var elementWidth;
  	    var elementHeight;
  	    if (width) {
  	      elementWidth = width;
  	      elementHeight = height;
  	      this.canvasContext.canvas.width = elementWidth;
  	      this.canvasContext.canvas.height = elementHeight;
  	    } else {
  	      if (this.animationItem.wrapper && this.animationItem.container) {
  	        elementWidth = this.animationItem.wrapper.offsetWidth;
  	        elementHeight = this.animationItem.wrapper.offsetHeight;
  	      } else {
  	        elementWidth = this.canvasContext.canvas.width;
  	        elementHeight = this.canvasContext.canvas.height;
  	      }
  	      this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
  	      this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
  	    }
  	    var elementRel;
  	    var animationRel;
  	    if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
  	      var par = this.renderConfig.preserveAspectRatio.split(' ');
  	      var fillType = par[1] || 'meet';
  	      var pos = par[0] || 'xMidYMid';
  	      var xPos = pos.substr(0, 4);
  	      var yPos = pos.substr(4);
  	      elementRel = elementWidth / elementHeight;
  	      animationRel = this.transformCanvas.w / this.transformCanvas.h;
  	      if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
  	        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
  	        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
  	      } else {
  	        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
  	        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
  	      }
  	      if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
  	        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
  	      } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
  	        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
  	      } else {
  	        this.transformCanvas.tx = 0;
  	      }
  	      if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
  	        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
  	      } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
  	        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
  	      } else {
  	        this.transformCanvas.ty = 0;
  	      }
  	    } else if (this.renderConfig.preserveAspectRatio === 'none') {
  	      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
  	      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
  	      this.transformCanvas.tx = 0;
  	      this.transformCanvas.ty = 0;
  	    } else {
  	      this.transformCanvas.sx = this.renderConfig.dpr;
  	      this.transformCanvas.sy = this.renderConfig.dpr;
  	      this.transformCanvas.tx = 0;
  	      this.transformCanvas.ty = 0;
  	    }
  	    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
  	    /* var i, len = this.elements.length;
  	      for(i=0;i<len;i+=1){
  	          if(this.elements[i] && this.elements[i].data.ty === 0){
  	              this.elements[i].resize(this.globalData.transformCanvas);
  	          }
  	      } */
  	    this.ctxTransform(this.transformCanvas.props);
  	    this.canvasContext.beginPath();
  	    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
  	    this.canvasContext.closePath();
  	    this.canvasContext.clip();
  	    this.renderFrame(this.renderedFrame, true);
  	  };
  	  CanvasRendererBase.prototype.destroy = function () {
  	    if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
  	      this.animationItem.wrapper.innerText = '';
  	    }
  	    var i;
  	    var len = this.layers ? this.layers.length : 0;
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.elements[i] && this.elements[i].destroy) {
  	        this.elements[i].destroy();
  	      }
  	    }
  	    this.elements.length = 0;
  	    this.globalData.canvasContext = null;
  	    this.animationItem.container = null;
  	    this.destroyed = true;
  	  };
  	  CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
  	    if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
  	      return;
  	    }
  	    this.renderedFrame = num;
  	    this.globalData.frameNum = num - this.animationItem._isFirstFrame;
  	    this.globalData.frameId += 1;
  	    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
  	    this.globalData.projectInterface.currentFrame = num;

  	    // console.log('--------');
  	    // console.log('NEW: ',num);
  	    var i;
  	    var len = this.layers.length;
  	    if (!this.completeLayers) {
  	      this.checkLayers(num);
  	    }
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.completeLayers || this.elements[i]) {
  	        this.elements[i].prepareFrame(num - this.layers[i].st);
  	      }
  	    }
  	    if (this.globalData._mdf) {
  	      if (this.renderConfig.clearCanvas === true) {
  	        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
  	      } else {
  	        this.save();
  	      }
  	      for (i = len - 1; i >= 0; i -= 1) {
  	        if (this.completeLayers || this.elements[i]) {
  	          this.elements[i].renderFrame();
  	        }
  	      }
  	      if (this.renderConfig.clearCanvas !== true) {
  	        this.restore();
  	      }
  	    }
  	  };
  	  CanvasRendererBase.prototype.buildItem = function (pos) {
  	    var elements = this.elements;
  	    if (elements[pos] || this.layers[pos].ty === 99) {
  	      return;
  	    }
  	    var element = this.createItem(this.layers[pos], this, this.globalData);
  	    elements[pos] = element;
  	    element.initExpressions();
  	    /* if(this.layers[pos].ty === 0){
  	          element.resize(this.globalData.transformCanvas);
  	      } */
  	  };
  	  CanvasRendererBase.prototype.checkPendingElements = function () {
  	    while (this.pendingElements.length) {
  	      var element = this.pendingElements.pop();
  	      element.checkParenting();
  	    }
  	  };
  	  CanvasRendererBase.prototype.hide = function () {
  	    this.animationItem.container.style.display = 'none';
  	  };
  	  CanvasRendererBase.prototype.show = function () {
  	    this.animationItem.container.style.display = 'block';
  	  };

  	  function CanvasContext() {
  	    this.opacity = -1;
  	    this.transform = createTypedArray('float32', 16);
  	    this.fillStyle = '';
  	    this.strokeStyle = '';
  	    this.lineWidth = '';
  	    this.lineCap = '';
  	    this.lineJoin = '';
  	    this.miterLimit = '';
  	    this.id = Math.random();
  	  }
  	  function CVContextData() {
  	    this.stack = [];
  	    this.cArrPos = 0;
  	    this.cTr = new Matrix();
  	    var i;
  	    var len = 15;
  	    for (i = 0; i < len; i += 1) {
  	      var canvasContext = new CanvasContext();
  	      this.stack[i] = canvasContext;
  	    }
  	    this._length = len;
  	    this.nativeContext = null;
  	    this.transformMat = new Matrix();
  	    this.currentOpacity = 1;
  	    //
  	    this.currentFillStyle = '';
  	    this.appliedFillStyle = '';
  	    //
  	    this.currentStrokeStyle = '';
  	    this.appliedStrokeStyle = '';
  	    //
  	    this.currentLineWidth = '';
  	    this.appliedLineWidth = '';
  	    //
  	    this.currentLineCap = '';
  	    this.appliedLineCap = '';
  	    //
  	    this.currentLineJoin = '';
  	    this.appliedLineJoin = '';
  	    //
  	    this.appliedMiterLimit = '';
  	    this.currentMiterLimit = '';
  	  }
  	  CVContextData.prototype.duplicate = function () {
  	    var newLength = this._length * 2;
  	    var i = 0;
  	    for (i = this._length; i < newLength; i += 1) {
  	      this.stack[i] = new CanvasContext();
  	    }
  	    this._length = newLength;
  	  };
  	  CVContextData.prototype.reset = function () {
  	    this.cArrPos = 0;
  	    this.cTr.reset();
  	    this.stack[this.cArrPos].opacity = 1;
  	  };
  	  CVContextData.prototype.restore = function (forceRestore) {
  	    this.cArrPos -= 1;
  	    var currentContext = this.stack[this.cArrPos];
  	    var transform = currentContext.transform;
  	    var i;
  	    var arr = this.cTr.props;
  	    for (i = 0; i < 16; i += 1) {
  	      arr[i] = transform[i];
  	    }
  	    if (forceRestore) {
  	      this.nativeContext.restore();
  	      var prevStack = this.stack[this.cArrPos + 1];
  	      this.appliedFillStyle = prevStack.fillStyle;
  	      this.appliedStrokeStyle = prevStack.strokeStyle;
  	      this.appliedLineWidth = prevStack.lineWidth;
  	      this.appliedLineCap = prevStack.lineCap;
  	      this.appliedLineJoin = prevStack.lineJoin;
  	      this.appliedMiterLimit = prevStack.miterLimit;
  	    }
  	    this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);
  	    if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
  	      this.nativeContext.globalAlpha = currentContext.opacity;
  	      this.currentOpacity = currentContext.opacity;
  	    }
  	    this.currentFillStyle = currentContext.fillStyle;
  	    this.currentStrokeStyle = currentContext.strokeStyle;
  	    this.currentLineWidth = currentContext.lineWidth;
  	    this.currentLineCap = currentContext.lineCap;
  	    this.currentLineJoin = currentContext.lineJoin;
  	    this.currentMiterLimit = currentContext.miterLimit;
  	  };
  	  CVContextData.prototype.save = function (saveOnNativeFlag) {
  	    if (saveOnNativeFlag) {
  	      this.nativeContext.save();
  	    }
  	    var props = this.cTr.props;
  	    if (this._length <= this.cArrPos) {
  	      this.duplicate();
  	    }
  	    var currentStack = this.stack[this.cArrPos];
  	    var i;
  	    for (i = 0; i < 16; i += 1) {
  	      currentStack.transform[i] = props[i];
  	    }
  	    this.cArrPos += 1;
  	    var newStack = this.stack[this.cArrPos];
  	    newStack.opacity = currentStack.opacity;
  	    newStack.fillStyle = currentStack.fillStyle;
  	    newStack.strokeStyle = currentStack.strokeStyle;
  	    newStack.lineWidth = currentStack.lineWidth;
  	    newStack.lineCap = currentStack.lineCap;
  	    newStack.lineJoin = currentStack.lineJoin;
  	    newStack.miterLimit = currentStack.miterLimit;
  	  };
  	  CVContextData.prototype.setOpacity = function (value) {
  	    this.stack[this.cArrPos].opacity = value;
  	  };
  	  CVContextData.prototype.setContext = function (value) {
  	    this.nativeContext = value;
  	  };
  	  CVContextData.prototype.fillStyle = function (value) {
  	    if (this.stack[this.cArrPos].fillStyle !== value) {
  	      this.currentFillStyle = value;
  	      this.stack[this.cArrPos].fillStyle = value;
  	    }
  	  };
  	  CVContextData.prototype.strokeStyle = function (value) {
  	    if (this.stack[this.cArrPos].strokeStyle !== value) {
  	      this.currentStrokeStyle = value;
  	      this.stack[this.cArrPos].strokeStyle = value;
  	    }
  	  };
  	  CVContextData.prototype.lineWidth = function (value) {
  	    if (this.stack[this.cArrPos].lineWidth !== value) {
  	      this.currentLineWidth = value;
  	      this.stack[this.cArrPos].lineWidth = value;
  	    }
  	  };
  	  CVContextData.prototype.lineCap = function (value) {
  	    if (this.stack[this.cArrPos].lineCap !== value) {
  	      this.currentLineCap = value;
  	      this.stack[this.cArrPos].lineCap = value;
  	    }
  	  };
  	  CVContextData.prototype.lineJoin = function (value) {
  	    if (this.stack[this.cArrPos].lineJoin !== value) {
  	      this.currentLineJoin = value;
  	      this.stack[this.cArrPos].lineJoin = value;
  	    }
  	  };
  	  CVContextData.prototype.miterLimit = function (value) {
  	    if (this.stack[this.cArrPos].miterLimit !== value) {
  	      this.currentMiterLimit = value;
  	      this.stack[this.cArrPos].miterLimit = value;
  	    }
  	  };
  	  CVContextData.prototype.transform = function (props) {
  	    this.transformMat.cloneFromProps(props);
  	    // Taking the last transform value from the stored stack of transforms
  	    var currentTransform = this.cTr;
  	    // Applying the last transform value after the new transform to respect the order of transformations
  	    this.transformMat.multiply(currentTransform);
  	    // Storing the new transformed value in the stored transform
  	    currentTransform.cloneFromProps(this.transformMat.props);
  	    var trProps = currentTransform.props;
  	    // Applying the new transform to the canvas
  	    this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
  	  };
  	  CVContextData.prototype.opacity = function (op) {
  	    var currentOpacity = this.stack[this.cArrPos].opacity;
  	    currentOpacity *= op < 0 ? 0 : op;
  	    if (this.stack[this.cArrPos].opacity !== currentOpacity) {
  	      if (this.currentOpacity !== op) {
  	        this.nativeContext.globalAlpha = op;
  	        this.currentOpacity = op;
  	      }
  	      this.stack[this.cArrPos].opacity = currentOpacity;
  	    }
  	  };
  	  CVContextData.prototype.fill = function (rule) {
  	    if (this.appliedFillStyle !== this.currentFillStyle) {
  	      this.appliedFillStyle = this.currentFillStyle;
  	      this.nativeContext.fillStyle = this.appliedFillStyle;
  	    }
  	    this.nativeContext.fill(rule);
  	  };
  	  CVContextData.prototype.fillRect = function (x, y, w, h) {
  	    if (this.appliedFillStyle !== this.currentFillStyle) {
  	      this.appliedFillStyle = this.currentFillStyle;
  	      this.nativeContext.fillStyle = this.appliedFillStyle;
  	    }
  	    this.nativeContext.fillRect(x, y, w, h);
  	  };
  	  CVContextData.prototype.stroke = function () {
  	    if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
  	      this.appliedStrokeStyle = this.currentStrokeStyle;
  	      this.nativeContext.strokeStyle = this.appliedStrokeStyle;
  	    }
  	    if (this.appliedLineWidth !== this.currentLineWidth) {
  	      this.appliedLineWidth = this.currentLineWidth;
  	      this.nativeContext.lineWidth = this.appliedLineWidth;
  	    }
  	    if (this.appliedLineCap !== this.currentLineCap) {
  	      this.appliedLineCap = this.currentLineCap;
  	      this.nativeContext.lineCap = this.appliedLineCap;
  	    }
  	    if (this.appliedLineJoin !== this.currentLineJoin) {
  	      this.appliedLineJoin = this.currentLineJoin;
  	      this.nativeContext.lineJoin = this.appliedLineJoin;
  	    }
  	    if (this.appliedMiterLimit !== this.currentMiterLimit) {
  	      this.appliedMiterLimit = this.currentMiterLimit;
  	      this.nativeContext.miterLimit = this.appliedMiterLimit;
  	    }
  	    this.nativeContext.stroke();
  	  };

  	  function CVCompElement(data, globalData, comp) {
  	    this.completeLayers = false;
  	    this.layers = data.layers;
  	    this.pendingElements = [];
  	    this.elements = createSizedArray(this.layers.length);
  	    this.initElement(data, globalData, comp);
  	    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
  	      _placeholder: true
  	    };
  	  }
  	  extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
  	  CVCompElement.prototype.renderInnerContent = function () {
  	    var ctx = this.canvasContext;
  	    ctx.beginPath();
  	    ctx.moveTo(0, 0);
  	    ctx.lineTo(this.data.w, 0);
  	    ctx.lineTo(this.data.w, this.data.h);
  	    ctx.lineTo(0, this.data.h);
  	    ctx.lineTo(0, 0);
  	    ctx.clip();
  	    var i;
  	    var len = this.layers.length;
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.completeLayers || this.elements[i]) {
  	        this.elements[i].renderFrame();
  	      }
  	    }
  	  };
  	  CVCompElement.prototype.destroy = function () {
  	    var i;
  	    var len = this.layers.length;
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      if (this.elements[i]) {
  	        this.elements[i].destroy();
  	      }
  	    }
  	    this.layers = null;
  	    this.elements = null;
  	  };
  	  CVCompElement.prototype.createComp = function (data) {
  	    return new CVCompElement(data, this.globalData, this);
  	  };

  	  function CanvasRenderer(animationItem, config) {
  	    this.animationItem = animationItem;
  	    this.renderConfig = {
  	      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
  	      context: config && config.context || null,
  	      progressiveLoad: config && config.progressiveLoad || false,
  	      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
  	      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
  	      contentVisibility: config && config.contentVisibility || 'visible',
  	      className: config && config.className || '',
  	      id: config && config.id || '',
  	      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
  	    };
  	    this.renderConfig.dpr = config && config.dpr || 1;
  	    if (this.animationItem.wrapper) {
  	      this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
  	    }
  	    this.renderedFrame = -1;
  	    this.globalData = {
  	      frameNum: -1,
  	      _mdf: false,
  	      renderConfig: this.renderConfig,
  	      currentGlobalAlpha: -1
  	    };
  	    this.contextData = new CVContextData();
  	    this.elements = [];
  	    this.pendingElements = [];
  	    this.transformMat = new Matrix();
  	    this.completeLayers = false;
  	    this.rendererType = 'canvas';
  	    if (this.renderConfig.clearCanvas) {
  	      this.ctxTransform = this.contextData.transform.bind(this.contextData);
  	      this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
  	      this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
  	      this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
  	      this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
  	      this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
  	      this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
  	      this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
  	      this.ctxFill = this.contextData.fill.bind(this.contextData);
  	      this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
  	      this.ctxStroke = this.contextData.stroke.bind(this.contextData);
  	      this.save = this.contextData.save.bind(this.contextData);
  	    }
  	  }
  	  extendPrototype([CanvasRendererBase], CanvasRenderer);
  	  CanvasRenderer.prototype.createComp = function (data) {
  	    return new CVCompElement(data, this.globalData, this);
  	  };

  	  function HBaseElement() {}
  	  HBaseElement.prototype = {
  	    checkBlendMode: function checkBlendMode() {},
  	    initRendererElement: function initRendererElement() {
  	      this.baseElement = createTag(this.data.tg || 'div');
  	      if (this.data.hasMask) {
  	        this.svgElement = createNS('svg');
  	        this.layerElement = createNS('g');
  	        this.maskedElement = this.layerElement;
  	        this.svgElement.appendChild(this.layerElement);
  	        this.baseElement.appendChild(this.svgElement);
  	      } else {
  	        this.layerElement = this.baseElement;
  	      }
  	      styleDiv(this.baseElement);
  	    },
  	    createContainerElements: function createContainerElements() {
  	      this.renderableEffectsManager = new CVEffects(this);
  	      this.transformedElement = this.baseElement;
  	      this.maskedElement = this.layerElement;
  	      if (this.data.ln) {
  	        this.layerElement.setAttribute('id', this.data.ln);
  	      }
  	      if (this.data.cl) {
  	        this.layerElement.setAttribute('class', this.data.cl);
  	      }
  	      if (this.data.bm !== 0) {
  	        this.setBlendMode();
  	      }
  	    },
  	    renderElement: function renderElement() {
  	      var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
  	      if (this.finalTransform._matMdf) {
  	        var matrixValue = this.finalTransform.mat.toCSS();
  	        transformedElementStyle.transform = matrixValue;
  	        transformedElementStyle.webkitTransform = matrixValue;
  	      }
  	      if (this.finalTransform._opMdf) {
  	        transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
  	      }
  	    },
  	    renderFrame: function renderFrame() {
  	      // If it is exported as hidden (data.hd === true) no need to render
  	      // If it is not visible no need to render
  	      if (this.data.hd || this.hidden) {
  	        return;
  	      }
  	      this.renderTransform();
  	      this.renderRenderable();
  	      this.renderElement();
  	      this.renderInnerContent();
  	      if (this._isFirstFrame) {
  	        this._isFirstFrame = false;
  	      }
  	    },
  	    destroy: function destroy() {
  	      this.layerElement = null;
  	      this.transformedElement = null;
  	      if (this.matteElement) {
  	        this.matteElement = null;
  	      }
  	      if (this.maskManager) {
  	        this.maskManager.destroy();
  	        this.maskManager = null;
  	      }
  	    },
  	    createRenderableComponents: function createRenderableComponents() {
  	      this.maskManager = new MaskElement(this.data, this, this.globalData);
  	    },
  	    addEffects: function addEffects() {},
  	    setMatte: function setMatte() {}
  	  };
  	  HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
  	  HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
  	  HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;

  	  function HSolidElement(data, globalData, comp) {
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
  	  HSolidElement.prototype.createContent = function () {
  	    var rect;
  	    if (this.data.hasMask) {
  	      rect = createNS('rect');
  	      rect.setAttribute('width', this.data.sw);
  	      rect.setAttribute('height', this.data.sh);
  	      rect.setAttribute('fill', this.data.sc);
  	      this.svgElement.setAttribute('width', this.data.sw);
  	      this.svgElement.setAttribute('height', this.data.sh);
  	    } else {
  	      rect = createTag('div');
  	      rect.style.width = this.data.sw + 'px';
  	      rect.style.height = this.data.sh + 'px';
  	      rect.style.backgroundColor = this.data.sc;
  	    }
  	    this.layerElement.appendChild(rect);
  	  };

  	  function HShapeElement(data, globalData, comp) {
  	    // List of drawable elements
  	    this.shapes = [];
  	    // Full shape data
  	    this.shapesData = data.shapes;
  	    // List of styles that will be applied to shapes
  	    this.stylesList = [];
  	    // List of modifiers that will be applied to shapes
  	    this.shapeModifiers = [];
  	    // List of items in shape tree
  	    this.itemsData = [];
  	    // List of items in previous shape tree
  	    this.processedElements = [];
  	    // List of animated components
  	    this.animatedContents = [];
  	    this.shapesContainer = createNS('g');
  	    this.initElement(data, globalData, comp);
  	    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  	    // List of elements that have been created
  	    this.prevViewData = [];
  	    this.currentBBox = {
  	      x: 999999,
  	      y: -999999,
  	      h: 0,
  	      w: 0
  	    };
  	  }
  	  extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
  	  HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
  	  HShapeElement.prototype.createContent = function () {
  	    var cont;
  	    this.baseElement.style.fontSize = 0;
  	    if (this.data.hasMask) {
  	      this.layerElement.appendChild(this.shapesContainer);
  	      cont = this.svgElement;
  	    } else {
  	      cont = createNS('svg');
  	      var size = this.comp.data ? this.comp.data : this.globalData.compSize;
  	      cont.setAttribute('width', size.w);
  	      cont.setAttribute('height', size.h);
  	      cont.appendChild(this.shapesContainer);
  	      this.layerElement.appendChild(cont);
  	    }
  	    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
  	    this.filterUniqueShapes();
  	    this.shapeCont = cont;
  	  };
  	  HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
  	    var i;
  	    var len = transformers.length;
  	    for (i = 0; i < len; i += 1) {
  	      point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
  	    }
  	    return point;
  	  };
  	  HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
  	    var shape = item.sh.v;
  	    var transformers = item.transformers;
  	    var i;
  	    var len = shape._length;
  	    var vPoint;
  	    var oPoint;
  	    var nextIPoint;
  	    var nextVPoint;
  	    if (len <= 1) {
  	      return;
  	    }
  	    for (i = 0; i < len - 1; i += 1) {
  	      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
  	      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
  	      nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
  	      nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
  	      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  	    }
  	    if (shape.c) {
  	      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
  	      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
  	      nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
  	      nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
  	      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  	    }
  	  };
  	  HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
  	    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
  	    var bounds = this.shapeBoundingBox;
  	    boundingBox.x = bmMin(bounds.left, boundingBox.x);
  	    boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
  	    boundingBox.y = bmMin(bounds.top, boundingBox.y);
  	    boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
  	  };
  	  HShapeElement.prototype.shapeBoundingBox = {
  	    left: 0,
  	    right: 0,
  	    top: 0,
  	    bottom: 0
  	  };
  	  HShapeElement.prototype.tempBoundingBox = {
  	    x: 0,
  	    xMax: 0,
  	    y: 0,
  	    yMax: 0,
  	    width: 0,
  	    height: 0
  	  };
  	  HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
  	    var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
  	    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
  	      // eslint-disable-line no-plusplus
  	      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
  	      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
  	      c = 3 * p1[i] - 3 * p0[i];
  	      b |= 0; // eslint-disable-line no-bitwise
  	      a |= 0; // eslint-disable-line no-bitwise
  	      c |= 0; // eslint-disable-line no-bitwise

  	      if (a === 0 && b === 0) ; else if (a === 0) {
  	        t = -c / b;
  	        if (t > 0 && t < 1) {
  	          bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
  	        }
  	      } else {
  	        b2ac = b * b - 4 * c * a;
  	        if (b2ac >= 0) {
  	          t1 = (-b + bmSqrt(b2ac)) / (2 * a);
  	          if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
  	          t2 = (-b - bmSqrt(b2ac)) / (2 * a);
  	          if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
  	        }
  	      }
  	    }
  	    this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
  	    this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
  	    this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
  	    this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
  	  };
  	  HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
  	    return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
  	  };
  	  HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
  	    var i;
  	    var len = itemsData.length;
  	    for (i = 0; i < len; i += 1) {
  	      if (itemsData[i] && itemsData[i].sh) {
  	        this.calculateShapeBoundingBox(itemsData[i], boundingBox);
  	      } else if (itemsData[i] && itemsData[i].it) {
  	        this.calculateBoundingBox(itemsData[i].it, boundingBox);
  	      } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
  	        this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
  	      }
  	    }
  	  };
  	  HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {
  	    var width = 0;
  	    if (widthProperty.keyframes) {
  	      for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
  	        var kfw = widthProperty.keyframes[i].s;
  	        if (kfw > width) {
  	          width = kfw;
  	        }
  	      }
  	      width *= widthProperty.mult;
  	    } else {
  	      width = widthProperty.v * widthProperty.mult;
  	    }
  	    boundingBox.x -= width;
  	    boundingBox.xMax += width;
  	    boundingBox.y -= width;
  	    boundingBox.yMax += width;
  	  };
  	  HShapeElement.prototype.currentBoxContains = function (box) {
  	    return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
  	  };
  	  HShapeElement.prototype.renderInnerContent = function () {
  	    this._renderShapeFrame();
  	    if (!this.hidden && (this._isFirstFrame || this._mdf)) {
  	      var tempBoundingBox = this.tempBoundingBox;
  	      var max = 999999;
  	      tempBoundingBox.x = max;
  	      tempBoundingBox.xMax = -max;
  	      tempBoundingBox.y = max;
  	      tempBoundingBox.yMax = -max;
  	      this.calculateBoundingBox(this.itemsData, tempBoundingBox);
  	      tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
  	      tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
  	      // var tempBoundingBox = this.shapeCont.getBBox();
  	      if (this.currentBoxContains(tempBoundingBox)) {
  	        return;
  	      }
  	      var changed = false;
  	      if (this.currentBBox.w !== tempBoundingBox.width) {
  	        this.currentBBox.w = tempBoundingBox.width;
  	        this.shapeCont.setAttribute('width', tempBoundingBox.width);
  	        changed = true;
  	      }
  	      if (this.currentBBox.h !== tempBoundingBox.height) {
  	        this.currentBBox.h = tempBoundingBox.height;
  	        this.shapeCont.setAttribute('height', tempBoundingBox.height);
  	        changed = true;
  	      }
  	      if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
  	        this.currentBBox.w = tempBoundingBox.width;
  	        this.currentBBox.h = tempBoundingBox.height;
  	        this.currentBBox.x = tempBoundingBox.x;
  	        this.currentBBox.y = tempBoundingBox.y;
  	        this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
  	        var shapeStyle = this.shapeCont.style;
  	        var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
  	        shapeStyle.transform = shapeTransform;
  	        shapeStyle.webkitTransform = shapeTransform;
  	      }
  	    }
  	  };

  	  function HTextElement(data, globalData, comp) {
  	    this.textSpans = [];
  	    this.textPaths = [];
  	    this.currentBBox = {
  	      x: 999999,
  	      y: -999999,
  	      h: 0,
  	      w: 0
  	    };
  	    this.renderType = 'svg';
  	    this.isMasked = false;
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
  	  HTextElement.prototype.createContent = function () {
  	    this.isMasked = this.checkMasks();
  	    if (this.isMasked) {
  	      this.renderType = 'svg';
  	      this.compW = this.comp.data.w;
  	      this.compH = this.comp.data.h;
  	      this.svgElement.setAttribute('width', this.compW);
  	      this.svgElement.setAttribute('height', this.compH);
  	      var g = createNS('g');
  	      this.maskedElement.appendChild(g);
  	      this.innerElem = g;
  	    } else {
  	      this.renderType = 'html';
  	      this.innerElem = this.layerElement;
  	    }
  	    this.checkParenting();
  	  };
  	  HTextElement.prototype.buildNewText = function () {
  	    var documentData = this.textProperty.currentData;
  	    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
  	    var innerElemStyle = this.innerElem.style;
  	    var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
  	    innerElemStyle.fill = textColor;
  	    innerElemStyle.color = textColor;
  	    if (documentData.sc) {
  	      innerElemStyle.stroke = this.buildColor(documentData.sc);
  	      innerElemStyle.strokeWidth = documentData.sw + 'px';
  	    }
  	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  	    if (!this.globalData.fontManager.chars) {
  	      innerElemStyle.fontSize = documentData.finalSize + 'px';
  	      innerElemStyle.lineHeight = documentData.finalSize + 'px';
  	      if (fontData.fClass) {
  	        this.innerElem.className = fontData.fClass;
  	      } else {
  	        innerElemStyle.fontFamily = fontData.fFamily;
  	        var fWeight = documentData.fWeight;
  	        var fStyle = documentData.fStyle;
  	        innerElemStyle.fontStyle = fStyle;
  	        innerElemStyle.fontWeight = fWeight;
  	      }
  	    }
  	    var i;
  	    var len;
  	    var letters = documentData.l;
  	    len = letters.length;
  	    var tSpan;
  	    var tParent;
  	    var tCont;
  	    var matrixHelper = this.mHelper;
  	    var shapes;
  	    var shapeStr = '';
  	    var cnt = 0;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.globalData.fontManager.chars) {
  	        if (!this.textPaths[cnt]) {
  	          tSpan = createNS('path');
  	          tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
  	          tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
  	          tSpan.setAttribute('stroke-miterlimit', '4');
  	        } else {
  	          tSpan = this.textPaths[cnt];
  	        }
  	        if (!this.isMasked) {
  	          if (this.textSpans[cnt]) {
  	            tParent = this.textSpans[cnt];
  	            tCont = tParent.children[0];
  	          } else {
  	            tParent = createTag('div');
  	            tParent.style.lineHeight = 0;
  	            tCont = createNS('svg');
  	            tCont.appendChild(tSpan);
  	            styleDiv(tParent);
  	          }
  	        }
  	      } else if (!this.isMasked) {
  	        if (this.textSpans[cnt]) {
  	          tParent = this.textSpans[cnt];
  	          tSpan = this.textPaths[cnt];
  	        } else {
  	          tParent = createTag('span');
  	          styleDiv(tParent);
  	          tSpan = createTag('span');
  	          styleDiv(tSpan);
  	          tParent.appendChild(tSpan);
  	        }
  	      } else {
  	        tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
  	      }
  	      // tSpan.setAttribute('visibility', 'hidden');
  	      if (this.globalData.fontManager.chars) {
  	        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
  	        var shapeData;
  	        if (charData) {
  	          shapeData = charData.data;
  	        } else {
  	          shapeData = null;
  	        }
  	        matrixHelper.reset();
  	        if (shapeData && shapeData.shapes && shapeData.shapes.length) {
  	          shapes = shapeData.shapes[0].it;
  	          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
  	          shapeStr = this.createPathShape(matrixHelper, shapes);
  	          tSpan.setAttribute('d', shapeStr);
  	        }
  	        if (!this.isMasked) {
  	          this.innerElem.appendChild(tParent);
  	          if (shapeData && shapeData.shapes) {
  	            // document.body.appendChild is needed to get exact measure of shape
  	            document.body.appendChild(tCont);
  	            var boundingBox = tCont.getBBox();
  	            tCont.setAttribute('width', boundingBox.width + 2);
  	            tCont.setAttribute('height', boundingBox.height + 2);
  	            tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
  	            var tContStyle = tCont.style;
  	            var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
  	            tContStyle.transform = tContTranslation;
  	            tContStyle.webkitTransform = tContTranslation;
  	            letters[i].yOffset = boundingBox.y - 1;
  	          } else {
  	            tCont.setAttribute('width', 1);
  	            tCont.setAttribute('height', 1);
  	          }
  	          tParent.appendChild(tCont);
  	        } else {
  	          this.innerElem.appendChild(tSpan);
  	        }
  	      } else {
  	        tSpan.textContent = letters[i].val;
  	        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
  	        if (!this.isMasked) {
  	          this.innerElem.appendChild(tParent);
  	          //
  	          var tStyle = tSpan.style;
  	          var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
  	          tStyle.transform = tSpanTranslation;
  	          tStyle.webkitTransform = tSpanTranslation;
  	        } else {
  	          this.innerElem.appendChild(tSpan);
  	        }
  	      }
  	      //
  	      if (!this.isMasked) {
  	        this.textSpans[cnt] = tParent;
  	      } else {
  	        this.textSpans[cnt] = tSpan;
  	      }
  	      this.textSpans[cnt].style.display = 'block';
  	      this.textPaths[cnt] = tSpan;
  	      cnt += 1;
  	    }
  	    while (cnt < this.textSpans.length) {
  	      this.textSpans[cnt].style.display = 'none';
  	      cnt += 1;
  	    }
  	  };
  	  HTextElement.prototype.renderInnerContent = function () {
  	    this.validateText();
  	    var svgStyle;
  	    if (this.data.singleShape) {
  	      if (!this._isFirstFrame && !this.lettersChangedFlag) {
  	        return;
  	      }
  	      if (this.isMasked && this.finalTransform._matMdf) {
  	        // Todo Benchmark if using this is better than getBBox
  	        this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
  	        svgStyle = this.svgElement.style;
  	        var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
  	        svgStyle.transform = translation;
  	        svgStyle.webkitTransform = translation;
  	      }
  	    }
  	    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  	    if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
  	      return;
  	    }
  	    var i;
  	    var len;
  	    var count = 0;
  	    var renderedLetters = this.textAnimator.renderedLetters;
  	    var letters = this.textProperty.currentData.l;
  	    len = letters.length;
  	    var renderedLetter;
  	    var textSpan;
  	    var textPath;
  	    for (i = 0; i < len; i += 1) {
  	      if (letters[i].n) {
  	        count += 1;
  	      } else {
  	        textSpan = this.textSpans[i];
  	        textPath = this.textPaths[i];
  	        renderedLetter = renderedLetters[count];
  	        count += 1;
  	        if (renderedLetter._mdf.m) {
  	          if (!this.isMasked) {
  	            textSpan.style.webkitTransform = renderedLetter.m;
  	            textSpan.style.transform = renderedLetter.m;
  	          } else {
  	            textSpan.setAttribute('transform', renderedLetter.m);
  	          }
  	        }
  	        /// /textSpan.setAttribute('opacity',renderedLetter.o);
  	        textSpan.style.opacity = renderedLetter.o;
  	        if (renderedLetter.sw && renderedLetter._mdf.sw) {
  	          textPath.setAttribute('stroke-width', renderedLetter.sw);
  	        }
  	        if (renderedLetter.sc && renderedLetter._mdf.sc) {
  	          textPath.setAttribute('stroke', renderedLetter.sc);
  	        }
  	        if (renderedLetter.fc && renderedLetter._mdf.fc) {
  	          textPath.setAttribute('fill', renderedLetter.fc);
  	          textPath.style.color = renderedLetter.fc;
  	        }
  	      }
  	    }
  	    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
  	      var boundingBox = this.innerElem.getBBox();
  	      if (this.currentBBox.w !== boundingBox.width) {
  	        this.currentBBox.w = boundingBox.width;
  	        this.svgElement.setAttribute('width', boundingBox.width);
  	      }
  	      if (this.currentBBox.h !== boundingBox.height) {
  	        this.currentBBox.h = boundingBox.height;
  	        this.svgElement.setAttribute('height', boundingBox.height);
  	      }
  	      var margin = 1;
  	      if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
  	        this.currentBBox.w = boundingBox.width + margin * 2;
  	        this.currentBBox.h = boundingBox.height + margin * 2;
  	        this.currentBBox.x = boundingBox.x - margin;
  	        this.currentBBox.y = boundingBox.y - margin;
  	        this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
  	        svgStyle = this.svgElement.style;
  	        var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
  	        svgStyle.transform = svgTransform;
  	        svgStyle.webkitTransform = svgTransform;
  	      }
  	    }
  	  };

  	  function HCameraElement(data, globalData, comp) {
  	    this.initFrame();
  	    this.initBaseData(data, globalData, comp);
  	    this.initHierarchy();
  	    var getProp = PropertyFactory.getProp;
  	    this.pe = getProp(this, data.pe, 0, 0, this);
  	    if (data.ks.p.s) {
  	      this.px = getProp(this, data.ks.p.x, 1, 0, this);
  	      this.py = getProp(this, data.ks.p.y, 1, 0, this);
  	      this.pz = getProp(this, data.ks.p.z, 1, 0, this);
  	    } else {
  	      this.p = getProp(this, data.ks.p, 1, 0, this);
  	    }
  	    if (data.ks.a) {
  	      this.a = getProp(this, data.ks.a, 1, 0, this);
  	    }
  	    if (data.ks.or.k.length && data.ks.or.k[0].to) {
  	      var i;
  	      var len = data.ks.or.k.length;
  	      for (i = 0; i < len; i += 1) {
  	        data.ks.or.k[i].to = null;
  	        data.ks.or.k[i].ti = null;
  	      }
  	    }
  	    this.or = getProp(this, data.ks.or, 1, degToRads, this);
  	    this.or.sh = true;
  	    this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
  	    this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
  	    this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
  	    this.mat = new Matrix();
  	    this._prevMat = new Matrix();
  	    this._isFirstFrame = true;

  	    // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
  	    this.finalTransform = {
  	      mProp: this
  	    };
  	  }
  	  extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
  	  HCameraElement.prototype.setup = function () {
  	    var i;
  	    var len = this.comp.threeDElements.length;
  	    var comp;
  	    var perspectiveStyle;
  	    var containerStyle;
  	    for (i = 0; i < len; i += 1) {
  	      // [perspectiveElem,container]
  	      comp = this.comp.threeDElements[i];
  	      if (comp.type === '3d') {
  	        perspectiveStyle = comp.perspectiveElem.style;
  	        containerStyle = comp.container.style;
  	        var perspective = this.pe.v + 'px';
  	        var origin = '0px 0px 0px';
  	        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
  	        perspectiveStyle.perspective = perspective;
  	        perspectiveStyle.webkitPerspective = perspective;
  	        containerStyle.transformOrigin = origin;
  	        containerStyle.mozTransformOrigin = origin;
  	        containerStyle.webkitTransformOrigin = origin;
  	        perspectiveStyle.transform = matrix;
  	        perspectiveStyle.webkitTransform = matrix;
  	      }
  	    }
  	  };
  	  HCameraElement.prototype.createElements = function () {};
  	  HCameraElement.prototype.hide = function () {};
  	  HCameraElement.prototype.renderFrame = function () {
  	    var _mdf = this._isFirstFrame;
  	    var i;
  	    var len;
  	    if (this.hierarchy) {
  	      len = this.hierarchy.length;
  	      for (i = 0; i < len; i += 1) {
  	        _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
  	      }
  	    }
  	    if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
  	      this.mat.reset();
  	      if (this.hierarchy) {
  	        len = this.hierarchy.length - 1;
  	        for (i = len; i >= 0; i -= 1) {
  	          var mTransf = this.hierarchy[i].finalTransform.mProp;
  	          this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
  	          this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
  	          this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
  	          this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
  	          this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
  	        }
  	      }
  	      if (this.p) {
  	        this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
  	      } else {
  	        this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
  	      }
  	      if (this.a) {
  	        var diffVector;
  	        if (this.p) {
  	          diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
  	        } else {
  	          diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
  	        }
  	        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
  	        // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
  	        var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
  	        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
  	        var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
  	        var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
  	        this.mat.rotateY(mRotationY).rotateX(-mRotationX);
  	      }
  	      this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
  	      this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
  	      this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
  	      this.mat.translate(0, 0, this.pe.v);
  	      var hasMatrixChanged = !this._prevMat.equals(this.mat);
  	      if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
  	        len = this.comp.threeDElements.length;
  	        var comp;
  	        var perspectiveStyle;
  	        var containerStyle;
  	        for (i = 0; i < len; i += 1) {
  	          comp = this.comp.threeDElements[i];
  	          if (comp.type === '3d') {
  	            if (hasMatrixChanged) {
  	              var matValue = this.mat.toCSS();
  	              containerStyle = comp.container.style;
  	              containerStyle.transform = matValue;
  	              containerStyle.webkitTransform = matValue;
  	            }
  	            if (this.pe._mdf) {
  	              perspectiveStyle = comp.perspectiveElem.style;
  	              perspectiveStyle.perspective = this.pe.v + 'px';
  	              perspectiveStyle.webkitPerspective = this.pe.v + 'px';
  	            }
  	          }
  	        }
  	        this.mat.clone(this._prevMat);
  	      }
  	    }
  	    this._isFirstFrame = false;
  	  };
  	  HCameraElement.prototype.prepareFrame = function (num) {
  	    this.prepareProperties(num, true);
  	  };
  	  HCameraElement.prototype.destroy = function () {};
  	  HCameraElement.prototype.getBaseElement = function () {
  	    return null;
  	  };

  	  function HImageElement(data, globalData, comp) {
  	    this.assetData = globalData.getAssetData(data.refId);
  	    this.initElement(data, globalData, comp);
  	  }
  	  extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
  	  HImageElement.prototype.createContent = function () {
  	    var assetPath = this.globalData.getAssetsPath(this.assetData);
  	    var img = new Image();
  	    if (this.data.hasMask) {
  	      this.imageElem = createNS('image');
  	      this.imageElem.setAttribute('width', this.assetData.w + 'px');
  	      this.imageElem.setAttribute('height', this.assetData.h + 'px');
  	      this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
  	      this.layerElement.appendChild(this.imageElem);
  	      this.baseElement.setAttribute('width', this.assetData.w);
  	      this.baseElement.setAttribute('height', this.assetData.h);
  	    } else {
  	      this.layerElement.appendChild(img);
  	    }
  	    img.crossOrigin = 'anonymous';
  	    img.src = assetPath;
  	    if (this.data.ln) {
  	      this.baseElement.setAttribute('id', this.data.ln);
  	    }
  	  };

  	  function HybridRendererBase(animationItem, config) {
  	    this.animationItem = animationItem;
  	    this.layers = null;
  	    this.renderedFrame = -1;
  	    this.renderConfig = {
  	      className: config && config.className || '',
  	      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
  	      hideOnTransparent: !(config && config.hideOnTransparent === false),
  	      filterSize: {
  	        width: config && config.filterSize && config.filterSize.width || '400%',
  	        height: config && config.filterSize && config.filterSize.height || '400%',
  	        x: config && config.filterSize && config.filterSize.x || '-100%',
  	        y: config && config.filterSize && config.filterSize.y || '-100%'
  	      }
  	    };
  	    this.globalData = {
  	      _mdf: false,
  	      frameNum: -1,
  	      renderConfig: this.renderConfig
  	    };
  	    this.pendingElements = [];
  	    this.elements = [];
  	    this.threeDElements = [];
  	    this.destroyed = false;
  	    this.camera = null;
  	    this.supports3d = true;
  	    this.rendererType = 'html';
  	  }
  	  extendPrototype([BaseRenderer], HybridRendererBase);
  	  HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
  	  HybridRendererBase.prototype.checkPendingElements = function () {
  	    while (this.pendingElements.length) {
  	      var element = this.pendingElements.pop();
  	      element.checkParenting();
  	    }
  	  };
  	  HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
  	    var newDOMElement = element.getBaseElement();
  	    if (!newDOMElement) {
  	      return;
  	    }
  	    var layer = this.layers[pos];
  	    if (!layer.ddd || !this.supports3d) {
  	      if (this.threeDElements) {
  	        this.addTo3dContainer(newDOMElement, pos);
  	      } else {
  	        var i = 0;
  	        var nextDOMElement;
  	        var nextLayer;
  	        var tmpDOMElement;
  	        while (i < pos) {
  	          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
  	            nextLayer = this.elements[i];
  	            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
  	            nextDOMElement = tmpDOMElement || nextDOMElement;
  	          }
  	          i += 1;
  	        }
  	        if (nextDOMElement) {
  	          if (!layer.ddd || !this.supports3d) {
  	            this.layerElement.insertBefore(newDOMElement, nextDOMElement);
  	          }
  	        } else if (!layer.ddd || !this.supports3d) {
  	          this.layerElement.appendChild(newDOMElement);
  	        }
  	      }
  	    } else {
  	      this.addTo3dContainer(newDOMElement, pos);
  	    }
  	  };
  	  HybridRendererBase.prototype.createShape = function (data) {
  	    if (!this.supports3d) {
  	      return new SVGShapeElement(data, this.globalData, this);
  	    }
  	    return new HShapeElement(data, this.globalData, this);
  	  };
  	  HybridRendererBase.prototype.createText = function (data) {
  	    if (!this.supports3d) {
  	      return new SVGTextLottieElement(data, this.globalData, this);
  	    }
  	    return new HTextElement(data, this.globalData, this);
  	  };
  	  HybridRendererBase.prototype.createCamera = function (data) {
  	    this.camera = new HCameraElement(data, this.globalData, this);
  	    return this.camera;
  	  };
  	  HybridRendererBase.prototype.createImage = function (data) {
  	    if (!this.supports3d) {
  	      return new IImageElement(data, this.globalData, this);
  	    }
  	    return new HImageElement(data, this.globalData, this);
  	  };
  	  HybridRendererBase.prototype.createSolid = function (data) {
  	    if (!this.supports3d) {
  	      return new ISolidElement(data, this.globalData, this);
  	    }
  	    return new HSolidElement(data, this.globalData, this);
  	  };
  	  HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
  	  HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
  	    var i = 0;
  	    var len = this.threeDElements.length;
  	    while (i < len) {
  	      if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
  	        return this.threeDElements[i].perspectiveElem;
  	      }
  	      i += 1;
  	    }
  	    return null;
  	  };
  	  HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
  	    var perspectiveElem = createTag('div');
  	    var style;
  	    var containerStyle;
  	    styleDiv(perspectiveElem);
  	    var container = createTag('div');
  	    styleDiv(container);
  	    if (type === '3d') {
  	      style = perspectiveElem.style;
  	      style.width = this.globalData.compSize.w + 'px';
  	      style.height = this.globalData.compSize.h + 'px';
  	      var center = '50% 50%';
  	      style.webkitTransformOrigin = center;
  	      style.mozTransformOrigin = center;
  	      style.transformOrigin = center;
  	      containerStyle = container.style;
  	      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
  	      containerStyle.transform = matrix;
  	      containerStyle.webkitTransform = matrix;
  	    }
  	    perspectiveElem.appendChild(container);
  	    // this.resizerElem.appendChild(perspectiveElem);
  	    var threeDContainerData = {
  	      container: container,
  	      perspectiveElem: perspectiveElem,
  	      startPos: pos,
  	      endPos: pos,
  	      type: type
  	    };
  	    this.threeDElements.push(threeDContainerData);
  	    return threeDContainerData;
  	  };
  	  HybridRendererBase.prototype.build3dContainers = function () {
  	    var i;
  	    var len = this.layers.length;
  	    var lastThreeDContainerData;
  	    var currentContainer = '';
  	    for (i = 0; i < len; i += 1) {
  	      if (this.layers[i].ddd && this.layers[i].ty !== 3) {
  	        if (currentContainer !== '3d') {
  	          currentContainer = '3d';
  	          lastThreeDContainerData = this.createThreeDContainer(i, '3d');
  	        }
  	        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
  	      } else {
  	        if (currentContainer !== '2d') {
  	          currentContainer = '2d';
  	          lastThreeDContainerData = this.createThreeDContainer(i, '2d');
  	        }
  	        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
  	      }
  	    }
  	    len = this.threeDElements.length;
  	    for (i = len - 1; i >= 0; i -= 1) {
  	      this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
  	    }
  	  };
  	  HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
  	    var i = 0;
  	    var len = this.threeDElements.length;
  	    while (i < len) {
  	      if (pos <= this.threeDElements[i].endPos) {
  	        var j = this.threeDElements[i].startPos;
  	        var nextElement;
  	        while (j < pos) {
  	          if (this.elements[j] && this.elements[j].getBaseElement) {
  	            nextElement = this.elements[j].getBaseElement();
  	          }
  	          j += 1;
  	        }
  	        if (nextElement) {
  	          this.threeDElements[i].container.insertBefore(elem, nextElement);
  	        } else {
  	          this.threeDElements[i].container.appendChild(elem);
  	        }
  	        break;
  	      }
  	      i += 1;
  	    }
  	  };
  	  HybridRendererBase.prototype.configAnimation = function (animData) {
  	    var resizerElem = createTag('div');
  	    var wrapper = this.animationItem.wrapper;
  	    var style = resizerElem.style;
  	    style.width = animData.w + 'px';
  	    style.height = animData.h + 'px';
  	    this.resizerElem = resizerElem;
  	    styleDiv(resizerElem);
  	    style.transformStyle = 'flat';
  	    style.mozTransformStyle = 'flat';
  	    style.webkitTransformStyle = 'flat';
  	    if (this.renderConfig.className) {
  	      resizerElem.setAttribute('class', this.renderConfig.className);
  	    }
  	    wrapper.appendChild(resizerElem);
  	    style.overflow = 'hidden';
  	    var svg = createNS('svg');
  	    svg.setAttribute('width', '1');
  	    svg.setAttribute('height', '1');
  	    styleDiv(svg);
  	    this.resizerElem.appendChild(svg);
  	    var defs = createNS('defs');
  	    svg.appendChild(defs);
  	    this.data = animData;
  	    // Mask animation
  	    this.setupGlobalData(animData, svg);
  	    this.globalData.defs = defs;
  	    this.layers = animData.layers;
  	    this.layerElement = this.resizerElem;
  	    this.build3dContainers();
  	    this.updateContainerSize();
  	  };
  	  HybridRendererBase.prototype.destroy = function () {
  	    if (this.animationItem.wrapper) {
  	      this.animationItem.wrapper.innerText = '';
  	    }
  	    this.animationItem.container = null;
  	    this.globalData.defs = null;
  	    var i;
  	    var len = this.layers ? this.layers.length : 0;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.elements[i] && this.elements[i].destroy) {
  	        this.elements[i].destroy();
  	      }
  	    }
  	    this.elements.length = 0;
  	    this.destroyed = true;
  	    this.animationItem = null;
  	  };
  	  HybridRendererBase.prototype.updateContainerSize = function () {
  	    var elementWidth = this.animationItem.wrapper.offsetWidth;
  	    var elementHeight = this.animationItem.wrapper.offsetHeight;
  	    var elementRel = elementWidth / elementHeight;
  	    var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
  	    var sx;
  	    var sy;
  	    var tx;
  	    var ty;
  	    if (animationRel > elementRel) {
  	      sx = elementWidth / this.globalData.compSize.w;
  	      sy = elementWidth / this.globalData.compSize.w;
  	      tx = 0;
  	      ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
  	    } else {
  	      sx = elementHeight / this.globalData.compSize.h;
  	      sy = elementHeight / this.globalData.compSize.h;
  	      tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
  	      ty = 0;
  	    }
  	    var style = this.resizerElem.style;
  	    style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
  	    style.transform = style.webkitTransform;
  	  };
  	  HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
  	  HybridRendererBase.prototype.hide = function () {
  	    this.resizerElem.style.display = 'none';
  	  };
  	  HybridRendererBase.prototype.show = function () {
  	    this.resizerElem.style.display = 'block';
  	  };
  	  HybridRendererBase.prototype.initItems = function () {
  	    this.buildAllItems();
  	    if (this.camera) {
  	      this.camera.setup();
  	    } else {
  	      var cWidth = this.globalData.compSize.w;
  	      var cHeight = this.globalData.compSize.h;
  	      var i;
  	      var len = this.threeDElements.length;
  	      for (i = 0; i < len; i += 1) {
  	        var style = this.threeDElements[i].perspectiveElem.style;
  	        style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
  	        style.perspective = style.webkitPerspective;
  	      }
  	    }
  	  };
  	  HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
  	    var i;
  	    var len = assets.length;
  	    var floatingContainer = createTag('div');
  	    for (i = 0; i < len; i += 1) {
  	      if (assets[i].xt) {
  	        var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
  	        comp.initExpressions();
  	        this.globalData.projectInterface.registerComposition(comp);
  	      }
  	    }
  	  };

  	  function HCompElement(data, globalData, comp) {
  	    this.layers = data.layers;
  	    this.supports3d = !data.hasMask;
  	    this.completeLayers = false;
  	    this.pendingElements = [];
  	    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  	    this.initElement(data, globalData, comp);
  	    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
  	      _placeholder: true
  	    };
  	  }
  	  extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
  	  HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
  	  HCompElement.prototype.createContainerElements = function () {
  	    this._createBaseContainerElements();
  	    // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
  	    if (this.data.hasMask) {
  	      this.svgElement.setAttribute('width', this.data.w);
  	      this.svgElement.setAttribute('height', this.data.h);
  	      this.transformedElement = this.baseElement;
  	    } else {
  	      this.transformedElement = this.layerElement;
  	    }
  	  };
  	  HCompElement.prototype.addTo3dContainer = function (elem, pos) {
  	    var j = 0;
  	    var nextElement;
  	    while (j < pos) {
  	      if (this.elements[j] && this.elements[j].getBaseElement) {
  	        nextElement = this.elements[j].getBaseElement();
  	      }
  	      j += 1;
  	    }
  	    if (nextElement) {
  	      this.layerElement.insertBefore(elem, nextElement);
  	    } else {
  	      this.layerElement.appendChild(elem);
  	    }
  	  };
  	  HCompElement.prototype.createComp = function (data) {
  	    if (!this.supports3d) {
  	      return new SVGCompElement(data, this.globalData, this);
  	    }
  	    return new HCompElement(data, this.globalData, this);
  	  };

  	  function HybridRenderer(animationItem, config) {
  	    this.animationItem = animationItem;
  	    this.layers = null;
  	    this.renderedFrame = -1;
  	    this.renderConfig = {
  	      className: config && config.className || '',
  	      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
  	      hideOnTransparent: !(config && config.hideOnTransparent === false),
  	      filterSize: {
  	        width: config && config.filterSize && config.filterSize.width || '400%',
  	        height: config && config.filterSize && config.filterSize.height || '400%',
  	        x: config && config.filterSize && config.filterSize.x || '-100%',
  	        y: config && config.filterSize && config.filterSize.y || '-100%'
  	      },
  	      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
  	    };
  	    this.globalData = {
  	      _mdf: false,
  	      frameNum: -1,
  	      renderConfig: this.renderConfig
  	    };
  	    this.pendingElements = [];
  	    this.elements = [];
  	    this.threeDElements = [];
  	    this.destroyed = false;
  	    this.camera = null;
  	    this.supports3d = true;
  	    this.rendererType = 'html';
  	  }
  	  extendPrototype([HybridRendererBase], HybridRenderer);
  	  HybridRenderer.prototype.createComp = function (data) {
  	    if (!this.supports3d) {
  	      return new SVGCompElement(data, this.globalData, this);
  	    }
  	    return new HCompElement(data, this.globalData, this);
  	  };

  	  var CompExpressionInterface = function () {
  	    return function (comp) {
  	      function _thisLayerFunction(name) {
  	        var i = 0;
  	        var len = comp.layers.length;
  	        while (i < len) {
  	          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
  	            return comp.elements[i].layerInterface;
  	          }
  	          i += 1;
  	        }
  	        return null;
  	        // return {active:false};
  	      }
  	      Object.defineProperty(_thisLayerFunction, '_name', {
  	        value: comp.data.nm
  	      });
  	      _thisLayerFunction.layer = _thisLayerFunction;
  	      _thisLayerFunction.pixelAspect = 1;
  	      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
  	      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
  	      _thisLayerFunction.pixelAspect = 1;
  	      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
  	      _thisLayerFunction.displayStartTime = 0;
  	      _thisLayerFunction.numLayers = comp.layers.length;
  	      return _thisLayerFunction;
  	    };
  	  }();

  	  function _typeof$2(o) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$2(o); }
  	  /* eslint-disable */
  	  /*
  	   Copyright 2014 David Bau.

  	   Permission is hereby granted, free of charge, to any person obtaining
  	   a copy of this software and associated documentation files (the
  	   "Software"), to deal in the Software without restriction, including
  	   without limitation the rights to use, copy, modify, merge, publish,
  	   distribute, sublicense, and/or sell copies of the Software, and to
  	   permit persons to whom the Software is furnished to do so, subject to
  	   the following conditions:

  	   The above copyright notice and this permission notice shall be
  	   included in all copies or substantial portions of the Software.

  	   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  	   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  	   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  	   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  	   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  	   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  	   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  	   */

  	  function seedRandom(pool, math) {
  	    //
  	    // The following constants are related to IEEE 754 limits.
  	    //
  	    var global = this,
  	      width = 256,
  	      // each RC4 output is 0 <= x < 256
  	      chunks = 6,
  	      // at least six RC4 outputs for each double
  	      digits = 52,
  	      // there are 52 significant digits in a double
  	      rngname = 'random',
  	      // rngname: name for Math.random and Math.seedrandom
  	      startdenom = math.pow(width, chunks),
  	      significance = math.pow(2, digits),
  	      overflow = significance * 2,
  	      mask = width - 1,
  	      nodecrypto; // node.js crypto module, initialized at the bottom.

  	    //
  	    // seedrandom()
  	    // This is the seedrandom function described above.
  	    //
  	    function seedrandom(seed, options, callback) {
  	      var key = [];
  	      options = options === true ? {
  	        entropy: true
  	      } : options || {};

  	      // Flatten the seed string or build one from local entropy if needed.
  	      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key);

  	      // Use the seed to initialize an ARC4 generator.
  	      var arc4 = new ARC4(key);

  	      // This function returns a random double in [0, 1) that contains
  	      // randomness in every bit of the mantissa of the IEEE 754 value.
  	      var prng = function prng() {
  	        var n = arc4.g(chunks),
  	          // Start with a numerator n < 2 ^ 48
  	          d = startdenom,
  	          //   and denominator d = 2 ^ 48.
  	          x = 0; //   and no 'extra last byte'.
  	        while (n < significance) {
  	          // Fill up all significant digits by
  	          n = (n + x) * width; //   shifting numerator and
  	          d *= width; //   denominator and generating a
  	          x = arc4.g(1); //   new least-significant-byte.
  	        }
  	        while (n >= overflow) {
  	          // To avoid rounding up, before adding
  	          n /= 2; //   last byte, shift everything
  	          d /= 2; //   right using integer math until
  	          x >>>= 1; //   we have exactly the desired bits.
  	        }
  	        return (n + x) / d; // Form the number within [0, 1).
  	      };
  	      prng.int32 = function () {
  	        return arc4.g(4) | 0;
  	      };
  	      prng.quick = function () {
  	        return arc4.g(4) / 0x100000000;
  	      };
  	      prng["double"] = prng;

  	      // Mix the randomness into accumulated entropy.
  	      mixkey(tostring(arc4.S), pool);

  	      // Calling convention: what to return as a function of prng, seed, is_math.
  	      return (options.pass || callback || function (prng, seed, is_math_call, state) {
  	        if (state) {
  	          // Load the arc4 state from the given state if it has an S array.
  	          if (state.S) {
  	            copy(state, arc4);
  	          }
  	          // Only provide the .state method if requested via options.state.
  	          prng.state = function () {
  	            return copy(arc4, {});
  	          };
  	        }

  	        // If called as a method of Math (Math.seedrandom()), mutate
  	        // Math.random because that is how seedrandom.js has worked since v1.0.
  	        if (is_math_call) {
  	          math[rngname] = prng;
  	          return seed;
  	        }

  	        // Otherwise, it is a newer calling convention, so return the
  	        // prng directly.
  	        else return prng;
  	      })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
  	    }
  	    math['seed' + rngname] = seedrandom;

  	    //
  	    // ARC4
  	    //
  	    // An ARC4 implementation.  The constructor takes a key in the form of
  	    // an array of at most (width) integers that should be 0 <= x < (width).
  	    //
  	    // The g(count) method returns a pseudorandom integer that concatenates
  	    // the next (count) outputs from ARC4.  Its return value is a number x
  	    // that is in the range 0 <= x < (width ^ count).
  	    //
  	    function ARC4(key) {
  	      var t,
  	        keylen = key.length,
  	        me = this,
  	        i = 0,
  	        j = me.i = me.j = 0,
  	        s = me.S = [];

  	      // The empty key [] is treated as [0].
  	      if (!keylen) {
  	        key = [keylen++];
  	      }

  	      // Set up S using the standard key scheduling algorithm.
  	      while (i < width) {
  	        s[i] = i++;
  	      }
  	      for (i = 0; i < width; i++) {
  	        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
  	        s[j] = t;
  	      }

  	      // The "g" method returns the next (count) outputs as one number.
  	      me.g = function (count) {
  	        // Using instance members instead of closure state nearly doubles speed.
  	        var t,
  	          r = 0,
  	          i = me.i,
  	          j = me.j,
  	          s = me.S;
  	        while (count--) {
  	          t = s[i = mask & i + 1];
  	          r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
  	        }
  	        me.i = i;
  	        me.j = j;
  	        return r;
  	        // For robust unpredictability, the function call below automatically
  	        // discards an initial batch of values.  This is called RC4-drop[256].
  	        // See http://google.com/search?q=rsa+fluhrer+response&btnI
  	      };
  	    }

  	    //
  	    // copy()
  	    // Copies internal state of ARC4 to or from a plain object.
  	    //
  	    function copy(f, t) {
  	      t.i = f.i;
  	      t.j = f.j;
  	      t.S = f.S.slice();
  	      return t;
  	    }

  	    //
  	    // flatten()
  	    // Converts an object tree to nested arrays of strings.
  	    //
  	    function flatten(obj, depth) {
  	      var result = [],
  	        typ = _typeof$2(obj),
  	        prop;
  	      if (depth && typ == 'object') {
  	        for (prop in obj) {
  	          try {
  	            result.push(flatten(obj[prop], depth - 1));
  	          } catch (e) {}
  	        }
  	      }
  	      return result.length ? result : typ == 'string' ? obj : obj + '\0';
  	    }

  	    //
  	    // mixkey()
  	    // Mixes a string seed into a key that is an array of integers, and
  	    // returns a shortened string seed that is equivalent to the result key.
  	    //
  	    function mixkey(seed, key) {
  	      var stringseed = seed + '',
  	        smear,
  	        j = 0;
  	      while (j < stringseed.length) {
  	        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
  	      }
  	      return tostring(key);
  	    }

  	    //
  	    // autoseed()
  	    // Returns an object for autoseeding, using window.crypto and Node crypto
  	    // module if available.
  	    //
  	    function autoseed() {
  	      try {
  	        if (nodecrypto) ;
  	        var out = new Uint8Array(width);
  	        (global.crypto || global.msCrypto).getRandomValues(out);
  	        return tostring(out);
  	      } catch (e) {
  	        var browser = global.navigator,
  	          plugins = browser && browser.plugins;
  	        return [+new Date(), global, plugins, global.screen, tostring(pool)];
  	      }
  	    }

  	    //
  	    // tostring()
  	    // Converts an array of charcodes to a string
  	    //
  	    function tostring(a) {
  	      return String.fromCharCode.apply(0, a);
  	    }

  	    //
  	    // When seedrandom.js is loaded, we immediately mix a few bits
  	    // from the built-in RNG into the entropy pool.  Because we do
  	    // not want to interfere with deterministic PRNG state later,
  	    // seedrandom will not call math.random on its own again after
  	    // initialization.
  	    //
  	    mixkey(math.random(), pool);

  	    //
  	    // Nodejs and AMD support: export the implementation as a module using
  	    // either convention.
  	    //

  	    // End anonymous scope, and pass initial values.
  	  }
  	  function initialize$2(BMMath) {
  	    seedRandom([], BMMath);
  	  }

  	  var propTypes = {
  	    SHAPE: 'shape'
  	  };

  	  function _typeof$1(o) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$1(o); }
  	  var ExpressionManager = function () {

  	    var ob = {};
  	    var Math = BMMath;
  	    var window = null;
  	    var document = null;
  	    var XMLHttpRequest = null;
  	    var fetch = null;
  	    var frames = null;
  	    var _lottieGlobal = {};
  	    initialize$2(BMMath);
  	    function resetFrame() {
  	      _lottieGlobal = {};
  	    }
  	    function $bm_isInstanceOfArray(arr) {
  	      return arr.constructor === Array || arr.constructor === Float32Array;
  	    }
  	    function isNumerable(tOfV, v) {
  	      return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';
  	    }
  	    function $bm_neg(a) {
  	      var tOfA = _typeof$1(a);
  	      if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {
  	        return -a;
  	      }
  	      if ($bm_isInstanceOfArray(a)) {
  	        var i;
  	        var lenA = a.length;
  	        var retArr = [];
  	        for (i = 0; i < lenA; i += 1) {
  	          retArr[i] = -a[i];
  	        }
  	        return retArr;
  	      }
  	      if (a.propType) {
  	        return a.v;
  	      }
  	      return -a;
  	    }
  	    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
  	    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
  	    var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;
  	    function sum(a, b) {
  	      var tOfA = _typeof$1(a);
  	      var tOfB = _typeof$1(b);
  	      if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {
  	        return a + b;
  	      }
  	      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
  	        a = a.slice(0);
  	        a[0] += b;
  	        return a;
  	      }
  	      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
  	        b = b.slice(0);
  	        b[0] = a + b[0];
  	        return b;
  	      }
  	      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
  	        var i = 0;
  	        var lenA = a.length;
  	        var lenB = b.length;
  	        var retArr = [];
  	        while (i < lenA || i < lenB) {
  	          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
  	            retArr[i] = a[i] + b[i];
  	          } else {
  	            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
  	          }
  	          i += 1;
  	        }
  	        return retArr;
  	      }
  	      return 0;
  	    }
  	    var add = sum;
  	    function sub(a, b) {
  	      var tOfA = _typeof$1(a);
  	      var tOfB = _typeof$1(b);
  	      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
  	        if (tOfA === 'string') {
  	          a = parseInt(a, 10);
  	        }
  	        if (tOfB === 'string') {
  	          b = parseInt(b, 10);
  	        }
  	        return a - b;
  	      }
  	      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
  	        a = a.slice(0);
  	        a[0] -= b;
  	        return a;
  	      }
  	      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
  	        b = b.slice(0);
  	        b[0] = a - b[0];
  	        return b;
  	      }
  	      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
  	        var i = 0;
  	        var lenA = a.length;
  	        var lenB = b.length;
  	        var retArr = [];
  	        while (i < lenA || i < lenB) {
  	          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
  	            retArr[i] = a[i] - b[i];
  	          } else {
  	            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
  	          }
  	          i += 1;
  	        }
  	        return retArr;
  	      }
  	      return 0;
  	    }
  	    function mul(a, b) {
  	      var tOfA = _typeof$1(a);
  	      var tOfB = _typeof$1(b);
  	      var arr;
  	      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
  	        return a * b;
  	      }
  	      var i;
  	      var len;
  	      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
  	        len = a.length;
  	        arr = createTypedArray('float32', len);
  	        for (i = 0; i < len; i += 1) {
  	          arr[i] = a[i] * b;
  	        }
  	        return arr;
  	      }
  	      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
  	        len = b.length;
  	        arr = createTypedArray('float32', len);
  	        for (i = 0; i < len; i += 1) {
  	          arr[i] = a * b[i];
  	        }
  	        return arr;
  	      }
  	      return 0;
  	    }
  	    function div(a, b) {
  	      var tOfA = _typeof$1(a);
  	      var tOfB = _typeof$1(b);
  	      var arr;
  	      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
  	        return a / b;
  	      }
  	      var i;
  	      var len;
  	      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
  	        len = a.length;
  	        arr = createTypedArray('float32', len);
  	        for (i = 0; i < len; i += 1) {
  	          arr[i] = a[i] / b;
  	        }
  	        return arr;
  	      }
  	      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
  	        len = b.length;
  	        arr = createTypedArray('float32', len);
  	        for (i = 0; i < len; i += 1) {
  	          arr[i] = a / b[i];
  	        }
  	        return arr;
  	      }
  	      return 0;
  	    }
  	    function mod(a, b) {
  	      if (typeof a === 'string') {
  	        a = parseInt(a, 10);
  	      }
  	      if (typeof b === 'string') {
  	        b = parseInt(b, 10);
  	      }
  	      return a % b;
  	    }
  	    var $bm_sum = sum;
  	    var $bm_sub = sub;
  	    var $bm_mul = mul;
  	    var $bm_div = div;
  	    var $bm_mod = mod;
  	    function clamp(num, min, max) {
  	      if (min > max) {
  	        var mm = max;
  	        max = min;
  	        min = mm;
  	      }
  	      return Math.min(Math.max(num, min), max);
  	    }
  	    function radiansToDegrees(val) {
  	      return val / degToRads;
  	    }
  	    var radians_to_degrees = radiansToDegrees;
  	    function degreesToRadians(val) {
  	      return val * degToRads;
  	    }
  	    var degrees_to_radians = radiansToDegrees;
  	    var helperLengthArray = [0, 0, 0, 0, 0, 0];
  	    function length(arr1, arr2) {
  	      if (typeof arr1 === 'number' || arr1 instanceof Number) {
  	        arr2 = arr2 || 0;
  	        return Math.abs(arr1 - arr2);
  	      }
  	      if (!arr2) {
  	        arr2 = helperLengthArray;
  	      }
  	      var i;
  	      var len = Math.min(arr1.length, arr2.length);
  	      var addedLength = 0;
  	      for (i = 0; i < len; i += 1) {
  	        addedLength += Math.pow(arr2[i] - arr1[i], 2);
  	      }
  	      return Math.sqrt(addedLength);
  	    }
  	    function normalize(vec) {
  	      return div(vec, length(vec));
  	    }
  	    function rgbToHsl(val) {
  	      var r = val[0];
  	      var g = val[1];
  	      var b = val[2];
  	      var max = Math.max(r, g, b);
  	      var min = Math.min(r, g, b);
  	      var h;
  	      var s;
  	      var l = (max + min) / 2;
  	      if (max === min) {
  	        h = 0; // achromatic
  	        s = 0; // achromatic
  	      } else {
  	        var d = max - min;
  	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
  	        switch (max) {
  	          case r:
  	            h = (g - b) / d + (g < b ? 6 : 0);
  	            break;
  	          case g:
  	            h = (b - r) / d + 2;
  	            break;
  	          case b:
  	            h = (r - g) / d + 4;
  	            break;
  	        }
  	        h /= 6;
  	      }
  	      return [h, s, l, val[3]];
  	    }
  	    function hue2rgb(p, q, t) {
  	      if (t < 0) t += 1;
  	      if (t > 1) t -= 1;
  	      if (t < 1 / 6) return p + (q - p) * 6 * t;
  	      if (t < 1 / 2) return q;
  	      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  	      return p;
  	    }
  	    function hslToRgb(val) {
  	      var h = val[0];
  	      var s = val[1];
  	      var l = val[2];
  	      var r;
  	      var g;
  	      var b;
  	      if (s === 0) {
  	        r = l; // achromatic
  	        b = l; // achromatic
  	        g = l; // achromatic
  	      } else {
  	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  	        var p = 2 * l - q;
  	        r = hue2rgb(p, q, h + 1 / 3);
  	        g = hue2rgb(p, q, h);
  	        b = hue2rgb(p, q, h - 1 / 3);
  	      }
  	      return [r, g, b, val[3]];
  	    }
  	    function linear(t, tMin, tMax, value1, value2) {
  	      if (value1 === undefined || value2 === undefined) {
  	        value1 = tMin;
  	        value2 = tMax;
  	        tMin = 0;
  	        tMax = 1;
  	      }
  	      if (tMax < tMin) {
  	        var _tMin = tMax;
  	        tMax = tMin;
  	        tMin = _tMin;
  	      }
  	      if (t <= tMin) {
  	        return value1;
  	      }
  	      if (t >= tMax) {
  	        return value2;
  	      }
  	      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
  	      if (!value1.length) {
  	        return value1 + (value2 - value1) * perc;
  	      }
  	      var i;
  	      var len = value1.length;
  	      var arr = createTypedArray('float32', len);
  	      for (i = 0; i < len; i += 1) {
  	        arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
  	      }
  	      return arr;
  	    }
  	    function random(min, max) {
  	      if (max === undefined) {
  	        if (min === undefined) {
  	          min = 0;
  	          max = 1;
  	        } else {
  	          max = min;
  	          min = undefined;
  	        }
  	      }
  	      if (max.length) {
  	        var i;
  	        var len = max.length;
  	        if (!min) {
  	          min = createTypedArray('float32', len);
  	        }
  	        var arr = createTypedArray('float32', len);
  	        var rnd = BMMath.random();
  	        for (i = 0; i < len; i += 1) {
  	          arr[i] = min[i] + rnd * (max[i] - min[i]);
  	        }
  	        return arr;
  	      }
  	      if (min === undefined) {
  	        min = 0;
  	      }
  	      var rndm = BMMath.random();
  	      return min + rndm * (max - min);
  	    }
  	    function createPath(points, inTangents, outTangents, closed) {
  	      var i;
  	      var len = points.length;
  	      var path = shapePool.newElement();
  	      path.setPathData(!!closed, len);
  	      var arrPlaceholder = [0, 0];
  	      var inVertexPoint;
  	      var outVertexPoint;
  	      for (i = 0; i < len; i += 1) {
  	        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
  	        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
  	        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
  	      }
  	      return path;
  	    }
  	    function initiateExpression(elem, data, property) {
  	      // Bail out if we don't want expressions
  	      function noOp(_value) {
  	        return _value;
  	      }
  	      if (!elem.globalData.renderConfig.runExpressions) {
  	        return noOp;
  	      }
  	      var val = data.x;
  	      var needsVelocity = /velocity(?![\w\d])/.test(val);
  	      var _needsRandom = val.indexOf('random') !== -1;
  	      var elemType = elem.data.ty;
  	      var transform;
  	      var $bm_transform;
  	      var content;
  	      var effect;
  	      var thisProperty = property;
  	      thisProperty._name = elem.data.nm;
  	      thisProperty.valueAtTime = thisProperty.getValueAtTime;
  	      Object.defineProperty(thisProperty, 'value', {
  	        get: function get() {
  	          return thisProperty.v;
  	        }
  	      });
  	      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
  	      elem.comp.displayStartTime = 0;
  	      var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
  	      var outPoint = elem.data.op / elem.comp.globalData.frameRate;
  	      var width = elem.data.sw ? elem.data.sw : 0;
  	      var height = elem.data.sh ? elem.data.sh : 0;
  	      var name = elem.data.nm;
  	      var loopIn;
  	      var loop_in;
  	      var loopOut;
  	      var loop_out;
  	      var smooth;
  	      var toWorld;
  	      var fromWorld;
  	      var fromComp;
  	      var toComp;
  	      var fromCompToSurface;
  	      var position;
  	      var rotation;
  	      var anchorPoint;
  	      var scale;
  	      var thisLayer;
  	      var thisComp;
  	      var mask;
  	      var valueAtTime;
  	      var velocityAtTime;
  	      var scoped_bm_rt;
  	      // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
  	      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
  	      var numKeys = property.kf ? data.k.length : 0;
  	      var active = !this.data || this.data.hd !== true;
  	      var wiggle = function wiggle(freq, amp) {
  	        var iWiggle;
  	        var j;
  	        var lenWiggle = this.pv.length ? this.pv.length : 1;
  	        var addedAmps = createTypedArray('float32', lenWiggle);
  	        freq = 5;
  	        var iterations = Math.floor(time * freq);
  	        iWiggle = 0;
  	        j = 0;
  	        while (iWiggle < iterations) {
  	          // var rnd = BMMath.random();
  	          for (j = 0; j < lenWiggle; j += 1) {
  	            addedAmps[j] += -amp + amp * 2 * BMMath.random();
  	            // addedAmps[j] += -amp + amp*2*rnd;
  	          }
  	          iWiggle += 1;
  	        }
  	        // var rnd2 = BMMath.random();
  	        var periods = time * freq;
  	        var perc = periods - Math.floor(periods);
  	        var arr = createTypedArray('float32', lenWiggle);
  	        if (lenWiggle > 1) {
  	          for (j = 0; j < lenWiggle; j += 1) {
  	            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
  	            // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
  	            // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
  	          }
  	          return arr;
  	        }
  	        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
  	      }.bind(this);
  	      if (thisProperty.loopIn) {
  	        loopIn = thisProperty.loopIn.bind(thisProperty);
  	        loop_in = loopIn;
  	      }
  	      if (thisProperty.loopOut) {
  	        loopOut = thisProperty.loopOut.bind(thisProperty);
  	        loop_out = loopOut;
  	      }
  	      if (thisProperty.smooth) {
  	        smooth = thisProperty.smooth.bind(thisProperty);
  	      }
  	      function loopInDuration(type, duration) {
  	        return loopIn(type, duration, true);
  	      }
  	      function loopOutDuration(type, duration) {
  	        return loopOut(type, duration, true);
  	      }
  	      if (this.getValueAtTime) {
  	        valueAtTime = this.getValueAtTime.bind(this);
  	      }
  	      if (this.getVelocityAtTime) {
  	        velocityAtTime = this.getVelocityAtTime.bind(this);
  	      }
  	      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
  	      function lookAt(elem1, elem2) {
  	        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
  	        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
  	        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
  	        return [yaw, pitch, 0];
  	      }
  	      function easeOut(t, tMin, tMax, val1, val2) {
  	        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
  	      }
  	      function easeIn(t, tMin, tMax, val1, val2) {
  	        return applyEase(easeInBez, t, tMin, tMax, val1, val2);
  	      }
  	      function ease(t, tMin, tMax, val1, val2) {
  	        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
  	      }
  	      function applyEase(fn, t, tMin, tMax, val1, val2) {
  	        if (val1 === undefined) {
  	          val1 = tMin;
  	          val2 = tMax;
  	        } else {
  	          t = (t - tMin) / (tMax - tMin);
  	        }
  	        if (t > 1) {
  	          t = 1;
  	        } else if (t < 0) {
  	          t = 0;
  	        }
  	        var mult = fn(t);
  	        if ($bm_isInstanceOfArray(val1)) {
  	          var iKey;
  	          var lenKey = val1.length;
  	          var arr = createTypedArray('float32', lenKey);
  	          for (iKey = 0; iKey < lenKey; iKey += 1) {
  	            arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
  	          }
  	          return arr;
  	        }
  	        return (val2 - val1) * mult + val1;
  	      }
  	      function nearestKey(time) {
  	        var iKey;
  	        var lenKey = data.k.length;
  	        var index;
  	        var keyTime;
  	        if (!data.k.length || typeof data.k[0] === 'number') {
  	          index = 0;
  	          keyTime = 0;
  	        } else {
  	          index = -1;
  	          time *= elem.comp.globalData.frameRate;
  	          if (time < data.k[0].t) {
  	            index = 1;
  	            keyTime = data.k[0].t;
  	          } else {
  	            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
  	              if (time === data.k[iKey].t) {
  	                index = iKey + 1;
  	                keyTime = data.k[iKey].t;
  	                break;
  	              } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
  	                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
  	                  index = iKey + 2;
  	                  keyTime = data.k[iKey + 1].t;
  	                } else {
  	                  index = iKey + 1;
  	                  keyTime = data.k[iKey].t;
  	                }
  	                break;
  	              }
  	            }
  	            if (index === -1) {
  	              index = iKey + 1;
  	              keyTime = data.k[iKey].t;
  	            }
  	          }
  	        }
  	        var obKey = {};
  	        obKey.index = index;
  	        obKey.time = keyTime / elem.comp.globalData.frameRate;
  	        return obKey;
  	      }
  	      function key(ind) {
  	        var obKey;
  	        var iKey;
  	        var lenKey;
  	        if (!data.k.length || typeof data.k[0] === 'number') {
  	          throw new Error('The property has no keyframe at index ' + ind);
  	        }
  	        ind -= 1;
  	        obKey = {
  	          time: data.k[ind].t / elem.comp.globalData.frameRate,
  	          value: []
  	        };
  	        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;
  	        lenKey = arr.length;
  	        for (iKey = 0; iKey < lenKey; iKey += 1) {
  	          obKey[iKey] = arr[iKey];
  	          obKey.value[iKey] = arr[iKey];
  	        }
  	        return obKey;
  	      }
  	      function framesToTime(fr, fps) {
  	        if (!fps) {
  	          fps = elem.comp.globalData.frameRate;
  	        }
  	        return fr / fps;
  	      }
  	      function timeToFrames(t, fps) {
  	        if (!t && t !== 0) {
  	          t = time;
  	        }
  	        if (!fps) {
  	          fps = elem.comp.globalData.frameRate;
  	        }
  	        return t * fps;
  	      }
  	      function seedRandom(seed) {
  	        BMMath.seedrandom(randSeed + seed);
  	      }
  	      function sourceRectAtTime() {
  	        return elem.sourceRectAtTime();
  	      }
  	      function substring(init, end) {
  	        if (typeof value === 'string') {
  	          if (end === undefined) {
  	            return value.substring(init);
  	          }
  	          return value.substring(init, end);
  	        }
  	        return '';
  	      }
  	      function substr(init, end) {
  	        if (typeof value === 'string') {
  	          if (end === undefined) {
  	            return value.substr(init);
  	          }
  	          return value.substr(init, end);
  	        }
  	        return '';
  	      }
  	      function posterizeTime(framesPerSecond) {
  	        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
  	        value = valueAtTime(time);
  	      }
  	      var time;
  	      var velocity;
  	      var value;
  	      var text;
  	      var textIndex;
  	      var textTotal;
  	      var selectorValue;
  	      var index = elem.data.ind;
  	      var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
  	      var parent;
  	      var randSeed = Math.floor(Math.random() * 1000000);
  	      var globalData = elem.globalData;
  	      function executeExpression(_value) {
  	        // globalData.pushExpression();
  	        value = _value;
  	        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
  	          return value;
  	        }
  	        if (this.propType === 'textSelector') {
  	          textIndex = this.textIndex;
  	          textTotal = this.textTotal;
  	          selectorValue = this.selectorValue;
  	        }
  	        if (!thisLayer) {
  	          text = elem.layerInterface.text;
  	          thisLayer = elem.layerInterface;
  	          thisComp = elem.comp.compInterface;
  	          toWorld = thisLayer.toWorld.bind(thisLayer);
  	          fromWorld = thisLayer.fromWorld.bind(thisLayer);
  	          fromComp = thisLayer.fromComp.bind(thisLayer);
  	          toComp = thisLayer.toComp.bind(thisLayer);
  	          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
  	          fromCompToSurface = fromComp;
  	        }
  	        if (!transform) {
  	          transform = elem.layerInterface('ADBE Transform Group');
  	          $bm_transform = transform;
  	          if (transform) {
  	            anchorPoint = transform.anchorPoint;
  	            /* position = transform.position;
  	                      rotation = transform.rotation;
  	                      scale = transform.scale; */
  	          }
  	        }
  	        if (elemType === 4 && !content) {
  	          content = thisLayer('ADBE Root Vectors Group');
  	        }
  	        if (!effect) {
  	          effect = thisLayer(4);
  	        }
  	        hasParent = !!(elem.hierarchy && elem.hierarchy.length);
  	        if (hasParent && !parent) {
  	          parent = elem.hierarchy[0].layerInterface;
  	        }
  	        time = this.comp.renderedFrame / this.comp.globalData.frameRate;
  	        if (_needsRandom) {
  	          seedRandom(randSeed + time);
  	        }
  	        if (needsVelocity) {
  	          velocity = velocityAtTime(time);
  	        }
  	        expression_function();
  	        this.frameExpressionId = elem.globalData.frameId;

  	        // TODO: Check if it's possible to return on ShapeInterface the .v value
  	        // Changed this to a ternary operation because Rollup failed compiling it correctly
  	        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
  	        return scoped_bm_rt;
  	      }
  	      // Bundlers will see these as dead code and unless we reference them
  	      executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
  	      return executeExpression;
  	    }
  	    ob.initiateExpression = initiateExpression;
  	    ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
  	    ob.resetFrame = resetFrame;
  	    return ob;
  	  }();

  	  var Expressions = function () {
  	    var ob = {};
  	    ob.initExpressions = initExpressions;
  	    ob.resetFrame = ExpressionManager.resetFrame;
  	    function initExpressions(animation) {
  	      var stackCount = 0;
  	      var registers = [];
  	      function pushExpression() {
  	        stackCount += 1;
  	      }
  	      function popExpression() {
  	        stackCount -= 1;
  	        if (stackCount === 0) {
  	          releaseInstances();
  	        }
  	      }
  	      function registerExpressionProperty(expression) {
  	        if (registers.indexOf(expression) === -1) {
  	          registers.push(expression);
  	        }
  	      }
  	      function releaseInstances() {
  	        var i;
  	        var len = registers.length;
  	        for (i = 0; i < len; i += 1) {
  	          registers[i].release();
  	        }
  	        registers.length = 0;
  	      }
  	      animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
  	      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
  	      animation.renderer.globalData.pushExpression = pushExpression;
  	      animation.renderer.globalData.popExpression = popExpression;
  	      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
  	    }
  	    return ob;
  	  }();

  	  var MaskManagerInterface = function () {
  	    function MaskInterface(mask, data) {
  	      this._mask = mask;
  	      this._data = data;
  	    }
  	    Object.defineProperty(MaskInterface.prototype, 'maskPath', {
  	      get: function get() {
  	        if (this._mask.prop.k) {
  	          this._mask.prop.getValue();
  	        }
  	        return this._mask.prop;
  	      }
  	    });
  	    Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
  	      get: function get() {
  	        if (this._mask.op.k) {
  	          this._mask.op.getValue();
  	        }
  	        return this._mask.op.v * 100;
  	      }
  	    });
  	    var MaskManager = function MaskManager(maskManager) {
  	      var _masksInterfaces = createSizedArray(maskManager.viewData.length);
  	      var i;
  	      var len = maskManager.viewData.length;
  	      for (i = 0; i < len; i += 1) {
  	        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
  	      }
  	      var maskFunction = function maskFunction(name) {
  	        i = 0;
  	        while (i < len) {
  	          if (maskManager.masksProperties[i].nm === name) {
  	            return _masksInterfaces[i];
  	          }
  	          i += 1;
  	        }
  	        return null;
  	      };
  	      return maskFunction;
  	    };
  	    return MaskManager;
  	  }();

  	  var ExpressionPropertyInterface = function () {
  	    var defaultUnidimensionalValue = {
  	      pv: 0,
  	      v: 0,
  	      mult: 1
  	    };
  	    var defaultMultidimensionalValue = {
  	      pv: [0, 0, 0],
  	      v: [0, 0, 0],
  	      mult: 1
  	    };
  	    function completeProperty(expressionValue, property, type) {
  	      Object.defineProperty(expressionValue, 'velocity', {
  	        get: function get() {
  	          return property.getVelocityAtTime(property.comp.currentFrame);
  	        }
  	      });
  	      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
  	      expressionValue.key = function (pos) {
  	        if (!expressionValue.numKeys) {
  	          return 0;
  	        }
  	        var value = '';
  	        if ('s' in property.keyframes[pos - 1]) {
  	          value = property.keyframes[pos - 1].s;
  	        } else if ('e' in property.keyframes[pos - 2]) {
  	          value = property.keyframes[pos - 2].e;
  	        } else {
  	          value = property.keyframes[pos - 2].s;
  	        }
  	        var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
  	        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
  	        valueProp.value = type === 'unidimensional' ? value[0] : value;
  	        return valueProp;
  	      };
  	      expressionValue.valueAtTime = property.getValueAtTime;
  	      expressionValue.speedAtTime = property.getSpeedAtTime;
  	      expressionValue.velocityAtTime = property.getVelocityAtTime;
  	      expressionValue.propertyGroup = property.propertyGroup;
  	    }
  	    function UnidimensionalPropertyInterface(property) {
  	      if (!property || !('pv' in property)) {
  	        property = defaultUnidimensionalValue;
  	      }
  	      var mult = 1 / property.mult;
  	      var val = property.pv * mult;
  	      var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
  	      expressionValue.value = val;
  	      completeProperty(expressionValue, property, 'unidimensional');
  	      return function () {
  	        if (property.k) {
  	          property.getValue();
  	        }
  	        val = property.v * mult;
  	        if (expressionValue.value !== val) {
  	          expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
  	          expressionValue.value = val;
  	          expressionValue[0] = val;
  	          completeProperty(expressionValue, property, 'unidimensional');
  	        }
  	        return expressionValue;
  	      };
  	    }
  	    function MultidimensionalPropertyInterface(property) {
  	      if (!property || !('pv' in property)) {
  	        property = defaultMultidimensionalValue;
  	      }
  	      var mult = 1 / property.mult;
  	      var len = property.data && property.data.l || property.pv.length;
  	      var expressionValue = createTypedArray('float32', len);
  	      var arrValue = createTypedArray('float32', len);
  	      expressionValue.value = arrValue;
  	      completeProperty(expressionValue, property, 'multidimensional');
  	      return function () {
  	        if (property.k) {
  	          property.getValue();
  	        }
  	        for (var i = 0; i < len; i += 1) {
  	          arrValue[i] = property.v[i] * mult;
  	          expressionValue[i] = arrValue[i];
  	        }
  	        return expressionValue;
  	      };
  	    }

  	    // TODO: try to avoid using this getter
  	    function defaultGetter() {
  	      return defaultUnidimensionalValue;
  	    }
  	    return function (property) {
  	      if (!property) {
  	        return defaultGetter;
  	      }
  	      if (property.propType === 'unidimensional') {
  	        return UnidimensionalPropertyInterface(property);
  	      }
  	      return MultidimensionalPropertyInterface(property);
  	    };
  	  }();

  	  var TransformExpressionInterface = function () {
  	    return function (transform) {
  	      function _thisFunction(name) {
  	        switch (name) {
  	          case 'scale':
  	          case 'Scale':
  	          case 'ADBE Scale':
  	          case 6:
  	            return _thisFunction.scale;
  	          case 'rotation':
  	          case 'Rotation':
  	          case 'ADBE Rotation':
  	          case 'ADBE Rotate Z':
  	          case 10:
  	            return _thisFunction.rotation;
  	          case 'ADBE Rotate X':
  	            return _thisFunction.xRotation;
  	          case 'ADBE Rotate Y':
  	            return _thisFunction.yRotation;
  	          case 'position':
  	          case 'Position':
  	          case 'ADBE Position':
  	          case 2:
  	            return _thisFunction.position;
  	          case 'ADBE Position_0':
  	            return _thisFunction.xPosition;
  	          case 'ADBE Position_1':
  	            return _thisFunction.yPosition;
  	          case 'ADBE Position_2':
  	            return _thisFunction.zPosition;
  	          case 'anchorPoint':
  	          case 'AnchorPoint':
  	          case 'Anchor Point':
  	          case 'ADBE AnchorPoint':
  	          case 1:
  	            return _thisFunction.anchorPoint;
  	          case 'opacity':
  	          case 'Opacity':
  	          case 11:
  	            return _thisFunction.opacity;
  	          default:
  	            return null;
  	        }
  	      }
  	      Object.defineProperty(_thisFunction, 'rotation', {
  	        get: ExpressionPropertyInterface(transform.r || transform.rz)
  	      });
  	      Object.defineProperty(_thisFunction, 'zRotation', {
  	        get: ExpressionPropertyInterface(transform.rz || transform.r)
  	      });
  	      Object.defineProperty(_thisFunction, 'xRotation', {
  	        get: ExpressionPropertyInterface(transform.rx)
  	      });
  	      Object.defineProperty(_thisFunction, 'yRotation', {
  	        get: ExpressionPropertyInterface(transform.ry)
  	      });
  	      Object.defineProperty(_thisFunction, 'scale', {
  	        get: ExpressionPropertyInterface(transform.s)
  	      });
  	      var _px;
  	      var _py;
  	      var _pz;
  	      var _transformFactory;
  	      if (transform.p) {
  	        _transformFactory = ExpressionPropertyInterface(transform.p);
  	      } else {
  	        _px = ExpressionPropertyInterface(transform.px);
  	        _py = ExpressionPropertyInterface(transform.py);
  	        if (transform.pz) {
  	          _pz = ExpressionPropertyInterface(transform.pz);
  	        }
  	      }
  	      Object.defineProperty(_thisFunction, 'position', {
  	        get: function get() {
  	          if (transform.p) {
  	            return _transformFactory();
  	          }
  	          return [_px(), _py(), _pz ? _pz() : 0];
  	        }
  	      });
  	      Object.defineProperty(_thisFunction, 'xPosition', {
  	        get: ExpressionPropertyInterface(transform.px)
  	      });
  	      Object.defineProperty(_thisFunction, 'yPosition', {
  	        get: ExpressionPropertyInterface(transform.py)
  	      });
  	      Object.defineProperty(_thisFunction, 'zPosition', {
  	        get: ExpressionPropertyInterface(transform.pz)
  	      });
  	      Object.defineProperty(_thisFunction, 'anchorPoint', {
  	        get: ExpressionPropertyInterface(transform.a)
  	      });
  	      Object.defineProperty(_thisFunction, 'opacity', {
  	        get: ExpressionPropertyInterface(transform.o)
  	      });
  	      Object.defineProperty(_thisFunction, 'skew', {
  	        get: ExpressionPropertyInterface(transform.sk)
  	      });
  	      Object.defineProperty(_thisFunction, 'skewAxis', {
  	        get: ExpressionPropertyInterface(transform.sa)
  	      });
  	      Object.defineProperty(_thisFunction, 'orientation', {
  	        get: ExpressionPropertyInterface(transform.or)
  	      });
  	      return _thisFunction;
  	    };
  	  }();

  	  var LayerExpressionInterface = function () {
  	    function getMatrix(time) {
  	      var toWorldMat = new Matrix();
  	      if (time !== undefined) {
  	        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
  	        propMatrix.clone(toWorldMat);
  	      } else {
  	        var transformMat = this._elem.finalTransform.mProp;
  	        transformMat.applyToMatrix(toWorldMat);
  	      }
  	      return toWorldMat;
  	    }
  	    function toWorldVec(arr, time) {
  	      var toWorldMat = this.getMatrix(time);
  	      toWorldMat.props[12] = 0;
  	      toWorldMat.props[13] = 0;
  	      toWorldMat.props[14] = 0;
  	      return this.applyPoint(toWorldMat, arr);
  	    }
  	    function toWorld(arr, time) {
  	      var toWorldMat = this.getMatrix(time);
  	      return this.applyPoint(toWorldMat, arr);
  	    }
  	    function fromWorldVec(arr, time) {
  	      var toWorldMat = this.getMatrix(time);
  	      toWorldMat.props[12] = 0;
  	      toWorldMat.props[13] = 0;
  	      toWorldMat.props[14] = 0;
  	      return this.invertPoint(toWorldMat, arr);
  	    }
  	    function fromWorld(arr, time) {
  	      var toWorldMat = this.getMatrix(time);
  	      return this.invertPoint(toWorldMat, arr);
  	    }
  	    function applyPoint(matrix, arr) {
  	      if (this._elem.hierarchy && this._elem.hierarchy.length) {
  	        var i;
  	        var len = this._elem.hierarchy.length;
  	        for (i = 0; i < len; i += 1) {
  	          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
  	        }
  	      }
  	      return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
  	    }
  	    function invertPoint(matrix, arr) {
  	      if (this._elem.hierarchy && this._elem.hierarchy.length) {
  	        var i;
  	        var len = this._elem.hierarchy.length;
  	        for (i = 0; i < len; i += 1) {
  	          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
  	        }
  	      }
  	      return matrix.inversePoint(arr);
  	    }
  	    function fromComp(arr) {
  	      var toWorldMat = new Matrix();
  	      toWorldMat.reset();
  	      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
  	      if (this._elem.hierarchy && this._elem.hierarchy.length) {
  	        var i;
  	        var len = this._elem.hierarchy.length;
  	        for (i = 0; i < len; i += 1) {
  	          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
  	        }
  	        return toWorldMat.inversePoint(arr);
  	      }
  	      return toWorldMat.inversePoint(arr);
  	    }
  	    function sampleImage() {
  	      return [1, 1, 1, 1];
  	    }
  	    return function (elem) {
  	      var transformInterface;
  	      function _registerMaskInterface(maskManager) {
  	        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
  	      }
  	      function _registerEffectsInterface(effects) {
  	        _thisLayerFunction.effect = effects;
  	      }
  	      function _thisLayerFunction(name) {
  	        switch (name) {
  	          case 'ADBE Root Vectors Group':
  	          case 'Contents':
  	          case 2:
  	            return _thisLayerFunction.shapeInterface;
  	          case 1:
  	          case 6:
  	          case 'Transform':
  	          case 'transform':
  	          case 'ADBE Transform Group':
  	            return transformInterface;
  	          case 4:
  	          case 'ADBE Effect Parade':
  	          case 'effects':
  	          case 'Effects':
  	            return _thisLayerFunction.effect;
  	          case 'ADBE Text Properties':
  	            return _thisLayerFunction.textInterface;
  	          default:
  	            return null;
  	        }
  	      }
  	      _thisLayerFunction.getMatrix = getMatrix;
  	      _thisLayerFunction.invertPoint = invertPoint;
  	      _thisLayerFunction.applyPoint = applyPoint;
  	      _thisLayerFunction.toWorld = toWorld;
  	      _thisLayerFunction.toWorldVec = toWorldVec;
  	      _thisLayerFunction.fromWorld = fromWorld;
  	      _thisLayerFunction.fromWorldVec = fromWorldVec;
  	      _thisLayerFunction.toComp = toWorld;
  	      _thisLayerFunction.fromComp = fromComp;
  	      _thisLayerFunction.sampleImage = sampleImage;
  	      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
  	      _thisLayerFunction._elem = elem;
  	      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
  	      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
  	      Object.defineProperties(_thisLayerFunction, {
  	        hasParent: {
  	          get: function get() {
  	            return elem.hierarchy.length;
  	          }
  	        },
  	        parent: {
  	          get: function get() {
  	            return elem.hierarchy[0].layerInterface;
  	          }
  	        },
  	        rotation: getDescriptor(transformInterface, 'rotation'),
  	        scale: getDescriptor(transformInterface, 'scale'),
  	        position: getDescriptor(transformInterface, 'position'),
  	        opacity: getDescriptor(transformInterface, 'opacity'),
  	        anchorPoint: anchorPointDescriptor,
  	        anchor_point: anchorPointDescriptor,
  	        transform: {
  	          get: function get() {
  	            return transformInterface;
  	          }
  	        },
  	        active: {
  	          get: function get() {
  	            return elem.isInRange;
  	          }
  	        }
  	      });
  	      _thisLayerFunction.startTime = elem.data.st;
  	      _thisLayerFunction.index = elem.data.ind;
  	      _thisLayerFunction.source = elem.data.refId;
  	      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
  	      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
  	      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
  	      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
  	      _thisLayerFunction._name = elem.data.nm;
  	      _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
  	      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
  	      return _thisLayerFunction;
  	    };
  	  }();

  	  var propertyGroupFactory = function () {
  	    return function (interfaceFunction, parentPropertyGroup) {
  	      return function (val) {
  	        val = val === undefined ? 1 : val;
  	        if (val <= 0) {
  	          return interfaceFunction;
  	        }
  	        return parentPropertyGroup(val - 1);
  	      };
  	    };
  	  }();

  	  var PropertyInterface = function () {
  	    return function (propertyName, propertyGroup) {
  	      var interfaceFunction = {
  	        _name: propertyName
  	      };
  	      function _propertyGroup(val) {
  	        val = val === undefined ? 1 : val;
  	        if (val <= 0) {
  	          return interfaceFunction;
  	        }
  	        return propertyGroup(val - 1);
  	      }
  	      return _propertyGroup;
  	    };
  	  }();

  	  var EffectsExpressionInterface = function () {
  	    var ob = {
  	      createEffectsInterface: createEffectsInterface
  	    };
  	    function createEffectsInterface(elem, propertyGroup) {
  	      if (elem.effectsManager) {
  	        var effectElements = [];
  	        var effectsData = elem.data.ef;
  	        var i;
  	        var len = elem.effectsManager.effectElements.length;
  	        for (i = 0; i < len; i += 1) {
  	          effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
  	        }
  	        var effects = elem.data.ef || [];
  	        var groupInterface = function groupInterface(name) {
  	          i = 0;
  	          len = effects.length;
  	          while (i < len) {
  	            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
  	              return effectElements[i];
  	            }
  	            i += 1;
  	          }
  	          return null;
  	        };
  	        Object.defineProperty(groupInterface, 'numProperties', {
  	          get: function get() {
  	            return effects.length;
  	          }
  	        });
  	        return groupInterface;
  	      }
  	      return null;
  	    }
  	    function createGroupInterface(data, elements, propertyGroup, elem) {
  	      function groupInterface(name) {
  	        var effects = data.ef;
  	        var i = 0;
  	        var len = effects.length;
  	        while (i < len) {
  	          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
  	            if (effects[i].ty === 5) {
  	              return effectElements[i];
  	            }
  	            return effectElements[i]();
  	          }
  	          i += 1;
  	        }
  	        throw new Error();
  	      }
  	      var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
  	      var effectElements = [];
  	      var i;
  	      var len = data.ef.length;
  	      for (i = 0; i < len; i += 1) {
  	        if (data.ef[i].ty === 5) {
  	          effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
  	        } else {
  	          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
  	        }
  	      }
  	      if (data.mn === 'ADBE Color Control') {
  	        Object.defineProperty(groupInterface, 'color', {
  	          get: function get() {
  	            return effectElements[0]();
  	          }
  	        });
  	      }
  	      Object.defineProperties(groupInterface, {
  	        numProperties: {
  	          get: function get() {
  	            return data.np;
  	          }
  	        },
  	        _name: {
  	          value: data.nm
  	        },
  	        propertyGroup: {
  	          value: _propertyGroup
  	        }
  	      });
  	      groupInterface.enabled = data.en !== 0;
  	      groupInterface.active = groupInterface.enabled;
  	      return groupInterface;
  	    }
  	    function createValueInterface(element, type, elem, propertyGroup) {
  	      var expressionProperty = ExpressionPropertyInterface(element.p);
  	      function interfaceFunction() {
  	        if (type === 10) {
  	          return elem.comp.compInterface(element.p.v);
  	        }
  	        return expressionProperty();
  	      }
  	      if (element.p.setGroupProperty) {
  	        element.p.setGroupProperty(PropertyInterface('', propertyGroup));
  	      }
  	      return interfaceFunction;
  	    }
  	    return ob;
  	  }();

  	  var ShapePathInterface = function () {
  	    return function pathInterfaceFactory(shape, view, propertyGroup) {
  	      var prop = view.sh;
  	      function interfaceFunction(val) {
  	        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
  	          return interfaceFunction.path;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        path: {
  	          get: function get() {
  	            if (prop.k) {
  	              prop.getValue();
  	            }
  	            return prop;
  	          }
  	        },
  	        shape: {
  	          get: function get() {
  	            if (prop.k) {
  	              prop.getValue();
  	            }
  	            return prop;
  	          }
  	        },
  	        _name: {
  	          value: shape.nm
  	        },
  	        ix: {
  	          value: shape.ix
  	        },
  	        propertyIndex: {
  	          value: shape.ix
  	        },
  	        mn: {
  	          value: shape.mn
  	        },
  	        propertyGroup: {
  	          value: propertyGroup
  	        }
  	      });
  	      return interfaceFunction;
  	    };
  	  }();

  	  var ShapeExpressionInterface = function () {
  	    function iterateElements(shapes, view, propertyGroup) {
  	      var arr = [];
  	      var i;
  	      var len = shapes ? shapes.length : 0;
  	      for (i = 0; i < len; i += 1) {
  	        if (shapes[i].ty === 'gr') {
  	          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'fl') {
  	          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'st') {
  	          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'tm') {
  	          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'tr') ; else if (shapes[i].ty === 'el') {
  	          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'sr') {
  	          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'sh') {
  	          arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'rc') {
  	          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'rd') {
  	          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'rp') {
  	          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else if (shapes[i].ty === 'gf') {
  	          arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
  	        } else {
  	          arr.push(defaultInterfaceFactory(shapes[i], view[i]));
  	        }
  	      }
  	      return arr;
  	    }
  	    function contentsInterfaceFactory(shape, view, propertyGroup) {
  	      var interfaces;
  	      var interfaceFunction = function _interfaceFunction(value) {
  	        var i = 0;
  	        var len = interfaces.length;
  	        while (i < len) {
  	          if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
  	            return interfaces[i];
  	          }
  	          i += 1;
  	        }
  	        if (typeof value === 'number') {
  	          return interfaces[value - 1];
  	        }
  	        return null;
  	      };
  	      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
  	      interfaceFunction.numProperties = interfaces.length;
  	      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
  	      interfaceFunction.transform = transformInterface;
  	      interfaceFunction.propertyIndex = shape.cix;
  	      interfaceFunction._name = shape.nm;
  	      return interfaceFunction;
  	    }
  	    function groupInterfaceFactory(shape, view, propertyGroup) {
  	      var interfaceFunction = function _interfaceFunction(value) {
  	        switch (value) {
  	          case 'ADBE Vectors Group':
  	          case 'Contents':
  	          case 2:
  	            return interfaceFunction.content;
  	          // Not necessary for now. Keeping them here in case a new case appears
  	          // case 'ADBE Vector Transform Group':
  	          // case 3:
  	          default:
  	            return interfaceFunction.transform;
  	        }
  	      };
  	      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
  	      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
  	      interfaceFunction.content = content;
  	      interfaceFunction.transform = transformInterface;
  	      Object.defineProperty(interfaceFunction, '_name', {
  	        get: function get() {
  	          return shape.nm;
  	        }
  	      });
  	      // interfaceFunction.content = interfaceFunction;
  	      interfaceFunction.numProperties = shape.np;
  	      interfaceFunction.propertyIndex = shape.ix;
  	      interfaceFunction.nm = shape.nm;
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function fillInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(val) {
  	        if (val === 'Color' || val === 'color') {
  	          return interfaceFunction.color;
  	        }
  	        if (val === 'Opacity' || val === 'opacity') {
  	          return interfaceFunction.opacity;
  	        }
  	        return null;
  	      }
  	      Object.defineProperties(interfaceFunction, {
  	        color: {
  	          get: ExpressionPropertyInterface(view.c)
  	        },
  	        opacity: {
  	          get: ExpressionPropertyInterface(view.o)
  	        },
  	        _name: {
  	          value: shape.nm
  	        },
  	        mn: {
  	          value: shape.mn
  	        }
  	      });
  	      view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
  	      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
  	      return interfaceFunction;
  	    }
  	    function gradientFillInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(val) {
  	        if (val === 'Start Point' || val === 'start point') {
  	          return interfaceFunction.startPoint;
  	        }
  	        if (val === 'End Point' || val === 'end point') {
  	          return interfaceFunction.endPoint;
  	        }
  	        if (val === 'Opacity' || val === 'opacity') {
  	          return interfaceFunction.opacity;
  	        }
  	        return null;
  	      }
  	      Object.defineProperties(interfaceFunction, {
  	        startPoint: {
  	          get: ExpressionPropertyInterface(view.s)
  	        },
  	        endPoint: {
  	          get: ExpressionPropertyInterface(view.e)
  	        },
  	        opacity: {
  	          get: ExpressionPropertyInterface(view.o)
  	        },
  	        type: {
  	          get: function get() {
  	            return 'a';
  	          }
  	        },
  	        _name: {
  	          value: shape.nm
  	        },
  	        mn: {
  	          value: shape.mn
  	        }
  	      });
  	      view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
  	      view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
  	      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
  	      return interfaceFunction;
  	    }
  	    function defaultInterfaceFactory() {
  	      function interfaceFunction() {
  	        return null;
  	      }
  	      return interfaceFunction;
  	    }
  	    function strokeInterfaceFactory(shape, view, propertyGroup) {
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
  	      function addPropertyToDashOb(i) {
  	        Object.defineProperty(dashOb, shape.d[i].nm, {
  	          get: ExpressionPropertyInterface(view.d.dataProps[i].p)
  	        });
  	      }
  	      var i;
  	      var len = shape.d ? shape.d.length : 0;
  	      var dashOb = {};
  	      for (i = 0; i < len; i += 1) {
  	        addPropertyToDashOb(i);
  	        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
  	      }
  	      function interfaceFunction(val) {
  	        if (val === 'Color' || val === 'color') {
  	          return interfaceFunction.color;
  	        }
  	        if (val === 'Opacity' || val === 'opacity') {
  	          return interfaceFunction.opacity;
  	        }
  	        if (val === 'Stroke Width' || val === 'stroke width') {
  	          return interfaceFunction.strokeWidth;
  	        }
  	        return null;
  	      }
  	      Object.defineProperties(interfaceFunction, {
  	        color: {
  	          get: ExpressionPropertyInterface(view.c)
  	        },
  	        opacity: {
  	          get: ExpressionPropertyInterface(view.o)
  	        },
  	        strokeWidth: {
  	          get: ExpressionPropertyInterface(view.w)
  	        },
  	        dash: {
  	          get: function get() {
  	            return dashOb;
  	          }
  	        },
  	        _name: {
  	          value: shape.nm
  	        },
  	        mn: {
  	          value: shape.mn
  	        }
  	      });
  	      view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
  	      view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
  	      view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
  	      return interfaceFunction;
  	    }
  	    function trimInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(val) {
  	        if (val === shape.e.ix || val === 'End' || val === 'end') {
  	          return interfaceFunction.end;
  	        }
  	        if (val === shape.s.ix) {
  	          return interfaceFunction.start;
  	        }
  	        if (val === shape.o.ix) {
  	          return interfaceFunction.offset;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      interfaceFunction.propertyIndex = shape.ix;
  	      view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
  	      view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
  	      view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
  	      interfaceFunction.propertyIndex = shape.ix;
  	      interfaceFunction.propertyGroup = propertyGroup;
  	      Object.defineProperties(interfaceFunction, {
  	        start: {
  	          get: ExpressionPropertyInterface(view.s)
  	        },
  	        end: {
  	          get: ExpressionPropertyInterface(view.e)
  	        },
  	        offset: {
  	          get: ExpressionPropertyInterface(view.o)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function transformInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.a.ix === value || value === 'Anchor Point') {
  	          return interfaceFunction.anchorPoint;
  	        }
  	        if (shape.o.ix === value || value === 'Opacity') {
  	          return interfaceFunction.opacity;
  	        }
  	        if (shape.p.ix === value || value === 'Position') {
  	          return interfaceFunction.position;
  	        }
  	        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
  	          return interfaceFunction.rotation;
  	        }
  	        if (shape.s.ix === value || value === 'Scale') {
  	          return interfaceFunction.scale;
  	        }
  	        if (shape.sk && shape.sk.ix === value || value === 'Skew') {
  	          return interfaceFunction.skew;
  	        }
  	        if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
  	          return interfaceFunction.skewAxis;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
  	      view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
  	      view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
  	      view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
  	      view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
  	      if (view.transform.mProps.sk) {
  	        view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
  	        view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
  	      }
  	      view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        opacity: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.o)
  	        },
  	        position: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.p)
  	        },
  	        anchorPoint: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.a)
  	        },
  	        scale: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.s)
  	        },
  	        rotation: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.r)
  	        },
  	        skew: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.sk)
  	        },
  	        skewAxis: {
  	          get: ExpressionPropertyInterface(view.transform.mProps.sa)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.ty = 'tr';
  	      interfaceFunction.mn = shape.mn;
  	      interfaceFunction.propertyGroup = propertyGroup;
  	      return interfaceFunction;
  	    }
  	    function ellipseInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.p.ix === value) {
  	          return interfaceFunction.position;
  	        }
  	        if (shape.s.ix === value) {
  	          return interfaceFunction.size;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      interfaceFunction.propertyIndex = shape.ix;
  	      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
  	      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
  	      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        size: {
  	          get: ExpressionPropertyInterface(prop.s)
  	        },
  	        position: {
  	          get: ExpressionPropertyInterface(prop.p)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function starInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.p.ix === value) {
  	          return interfaceFunction.position;
  	        }
  	        if (shape.r.ix === value) {
  	          return interfaceFunction.rotation;
  	        }
  	        if (shape.pt.ix === value) {
  	          return interfaceFunction.points;
  	        }
  	        if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
  	          return interfaceFunction.outerRadius;
  	        }
  	        if (shape.os.ix === value) {
  	          return interfaceFunction.outerRoundness;
  	        }
  	        if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
  	          return interfaceFunction.innerRadius;
  	        }
  	        if (shape.is && shape.is.ix === value) {
  	          return interfaceFunction.innerRoundness;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
  	      interfaceFunction.propertyIndex = shape.ix;
  	      prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
  	      prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
  	      prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
  	      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
  	      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
  	      if (shape.ir) {
  	        prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
  	        prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
  	      }
  	      Object.defineProperties(interfaceFunction, {
  	        position: {
  	          get: ExpressionPropertyInterface(prop.p)
  	        },
  	        rotation: {
  	          get: ExpressionPropertyInterface(prop.r)
  	        },
  	        points: {
  	          get: ExpressionPropertyInterface(prop.pt)
  	        },
  	        outerRadius: {
  	          get: ExpressionPropertyInterface(prop.or)
  	        },
  	        outerRoundness: {
  	          get: ExpressionPropertyInterface(prop.os)
  	        },
  	        innerRadius: {
  	          get: ExpressionPropertyInterface(prop.ir)
  	        },
  	        innerRoundness: {
  	          get: ExpressionPropertyInterface(prop.is)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function rectInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.p.ix === value) {
  	          return interfaceFunction.position;
  	        }
  	        if (shape.r.ix === value) {
  	          return interfaceFunction.roundness;
  	        }
  	        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
  	          return interfaceFunction.size;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
  	      interfaceFunction.propertyIndex = shape.ix;
  	      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
  	      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
  	      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        position: {
  	          get: ExpressionPropertyInterface(prop.p)
  	        },
  	        roundness: {
  	          get: ExpressionPropertyInterface(prop.r)
  	        },
  	        size: {
  	          get: ExpressionPropertyInterface(prop.s)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function roundedInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.r.ix === value || value === 'Round Corners 1') {
  	          return interfaceFunction.radius;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var prop = view;
  	      interfaceFunction.propertyIndex = shape.ix;
  	      prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        radius: {
  	          get: ExpressionPropertyInterface(prop.rd)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    function repeaterInterfaceFactory(shape, view, propertyGroup) {
  	      function interfaceFunction(value) {
  	        if (shape.c.ix === value || value === 'Copies') {
  	          return interfaceFunction.copies;
  	        }
  	        if (shape.o.ix === value || value === 'Offset') {
  	          return interfaceFunction.offset;
  	        }
  	        return null;
  	      }
  	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
  	      var prop = view;
  	      interfaceFunction.propertyIndex = shape.ix;
  	      prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
  	      prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
  	      Object.defineProperties(interfaceFunction, {
  	        copies: {
  	          get: ExpressionPropertyInterface(prop.c)
  	        },
  	        offset: {
  	          get: ExpressionPropertyInterface(prop.o)
  	        },
  	        _name: {
  	          value: shape.nm
  	        }
  	      });
  	      interfaceFunction.mn = shape.mn;
  	      return interfaceFunction;
  	    }
  	    return function (shapes, view, propertyGroup) {
  	      var interfaces;
  	      function _interfaceFunction(value) {
  	        if (typeof value === 'number') {
  	          value = value === undefined ? 1 : value;
  	          if (value === 0) {
  	            return propertyGroup;
  	          }
  	          return interfaces[value - 1];
  	        }
  	        var i = 0;
  	        var len = interfaces.length;
  	        while (i < len) {
  	          if (interfaces[i]._name === value) {
  	            return interfaces[i];
  	          }
  	          i += 1;
  	        }
  	        return null;
  	      }
  	      function parentGroupWrapper() {
  	        return propertyGroup;
  	      }
  	      _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
  	      interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
  	      _interfaceFunction.numProperties = interfaces.length;
  	      _interfaceFunction._name = 'Contents';
  	      return _interfaceFunction;
  	    };
  	  }();

  	  var TextExpressionInterface = function () {
  	    return function (elem) {
  	      var _sourceText;
  	      function _thisLayerFunction(name) {
  	        switch (name) {
  	          case 'ADBE Text Document':
  	            return _thisLayerFunction.sourceText;
  	          default:
  	            return null;
  	        }
  	      }
  	      Object.defineProperty(_thisLayerFunction, 'sourceText', {
  	        get: function get() {
  	          elem.textProperty.getValue();
  	          var stringValue = elem.textProperty.currentData.t;
  	          if (!_sourceText || stringValue !== _sourceText.value) {
  	            _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
  	            // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
  	            _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
  	            Object.defineProperty(_sourceText, 'style', {
  	              get: function get() {
  	                return {
  	                  fillColor: elem.textProperty.currentData.fc
  	                };
  	              }
  	            });
  	          }
  	          return _sourceText;
  	        }
  	      });
  	      return _thisLayerFunction;
  	    };
  	  }();

  	  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	  var FootageInterface = function () {
  	    var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
  	      var currentPropertyName = '';
  	      var currentProperty = elem.getFootageData();
  	      function init() {
  	        currentPropertyName = '';
  	        currentProperty = elem.getFootageData();
  	        return searchProperty;
  	      }
  	      function searchProperty(value) {
  	        if (currentProperty[value]) {
  	          currentPropertyName = value;
  	          currentProperty = currentProperty[value];
  	          if (_typeof(currentProperty) === 'object') {
  	            return searchProperty;
  	          }
  	          return currentProperty;
  	        }
  	        var propertyNameIndex = value.indexOf(currentPropertyName);
  	        if (propertyNameIndex !== -1) {
  	          var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
  	          currentProperty = currentProperty[index];
  	          if (_typeof(currentProperty) === 'object') {
  	            return searchProperty;
  	          }
  	          return currentProperty;
  	        }
  	        return '';
  	      }
  	      return init;
  	    };
  	    var dataInterfaceFactory = function dataInterfaceFactory(elem) {
  	      function interfaceFunction(value) {
  	        if (value === 'Outline') {
  	          return interfaceFunction.outlineInterface();
  	        }
  	        return null;
  	      }
  	      interfaceFunction._name = 'Outline';
  	      interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
  	      return interfaceFunction;
  	    };
  	    return function (elem) {
  	      function _interfaceFunction(value) {
  	        if (value === 'Data') {
  	          return _interfaceFunction.dataInterface;
  	        }
  	        return null;
  	      }
  	      _interfaceFunction._name = 'Data';
  	      _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
  	      return _interfaceFunction;
  	    };
  	  }();

  	  var interfaces = {
  	    layer: LayerExpressionInterface,
  	    effects: EffectsExpressionInterface,
  	    comp: CompExpressionInterface,
  	    shape: ShapeExpressionInterface,
  	    text: TextExpressionInterface,
  	    footage: FootageInterface
  	  };
  	  function getInterface(type) {
  	    return interfaces[type] || null;
  	  }

  	  var expressionHelpers = function () {
  	    function searchExpressions(elem, data, prop) {
  	      if (data.x) {
  	        prop.k = true;
  	        prop.x = true;
  	        prop.initiateExpression = ExpressionManager.initiateExpression;
  	        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
  	      }
  	    }
  	    function getValueAtTime(frameNum) {
  	      frameNum *= this.elem.globalData.frameRate;
  	      frameNum -= this.offsetTime;
  	      if (frameNum !== this._cachingAtTime.lastFrame) {
  	        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
  	        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
  	        this._cachingAtTime.lastFrame = frameNum;
  	      }
  	      return this._cachingAtTime.value;
  	    }
  	    function getSpeedAtTime(frameNum) {
  	      var delta = -0.01;
  	      var v1 = this.getValueAtTime(frameNum);
  	      var v2 = this.getValueAtTime(frameNum + delta);
  	      var speed = 0;
  	      if (v1.length) {
  	        var i;
  	        for (i = 0; i < v1.length; i += 1) {
  	          speed += Math.pow(v2[i] - v1[i], 2);
  	        }
  	        speed = Math.sqrt(speed) * 100;
  	      } else {
  	        speed = 0;
  	      }
  	      return speed;
  	    }
  	    function getVelocityAtTime(frameNum) {
  	      if (this.vel !== undefined) {
  	        return this.vel;
  	      }
  	      var delta = -0.001;
  	      // frameNum += this.elem.data.st;
  	      var v1 = this.getValueAtTime(frameNum);
  	      var v2 = this.getValueAtTime(frameNum + delta);
  	      var velocity;
  	      if (v1.length) {
  	        velocity = createTypedArray('float32', v1.length);
  	        var i;
  	        for (i = 0; i < v1.length; i += 1) {
  	          // removing frameRate
  	          // if needed, don't add it here
  	          // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
  	          velocity[i] = (v2[i] - v1[i]) / delta;
  	        }
  	      } else {
  	        velocity = (v2 - v1) / delta;
  	      }
  	      return velocity;
  	    }
  	    function getStaticValueAtTime() {
  	      return this.pv;
  	    }
  	    function setGroupProperty(propertyGroup) {
  	      this.propertyGroup = propertyGroup;
  	    }
  	    return {
  	      searchExpressions: searchExpressions,
  	      getSpeedAtTime: getSpeedAtTime,
  	      getVelocityAtTime: getVelocityAtTime,
  	      getValueAtTime: getValueAtTime,
  	      getStaticValueAtTime: getStaticValueAtTime,
  	      setGroupProperty: setGroupProperty
  	    };
  	  }();

  	  function addPropertyDecorator() {
  	    function loopOut(type, duration, durationFlag) {
  	      if (!this.k || !this.keyframes) {
  	        return this.pv;
  	      }
  	      type = type ? type.toLowerCase() : '';
  	      var currentFrame = this.comp.renderedFrame;
  	      var keyframes = this.keyframes;
  	      var lastKeyFrame = keyframes[keyframes.length - 1].t;
  	      if (currentFrame <= lastKeyFrame) {
  	        return this.pv;
  	      }
  	      var cycleDuration;
  	      var firstKeyFrame;
  	      if (!durationFlag) {
  	        if (!duration || duration > keyframes.length - 1) {
  	          duration = keyframes.length - 1;
  	        }
  	        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
  	        cycleDuration = lastKeyFrame - firstKeyFrame;
  	      } else {
  	        if (!duration) {
  	          cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
  	        } else {
  	          cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
  	        }
  	        firstKeyFrame = lastKeyFrame - cycleDuration;
  	      }
  	      var i;
  	      var len;
  	      var ret;
  	      if (type === 'pingpong') {
  	        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
  	        if (iterations % 2 !== 0) {
  	          return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
  	        }
  	      } else if (type === 'offset') {
  	        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
  	        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
  	        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
  	        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
  	        if (this.pv.length) {
  	          ret = new Array(initV.length);
  	          len = ret.length;
  	          for (i = 0; i < len; i += 1) {
  	            ret[i] = (endV[i] - initV[i]) * repeats + current[i];
  	          }
  	          return ret;
  	        }
  	        return (endV - initV) * repeats + current;
  	      } else if (type === 'continue') {
  	        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
  	        var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
  	        if (this.pv.length) {
  	          ret = new Array(lastValue.length);
  	          len = ret.length;
  	          for (i = 0; i < len; i += 1) {
  	            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
  	          }
  	          return ret;
  	        }
  	        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
  	      }
  	      return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
  	    }
  	    function loopIn(type, duration, durationFlag) {
  	      if (!this.k) {
  	        return this.pv;
  	      }
  	      type = type ? type.toLowerCase() : '';
  	      var currentFrame = this.comp.renderedFrame;
  	      var keyframes = this.keyframes;
  	      var firstKeyFrame = keyframes[0].t;
  	      if (currentFrame >= firstKeyFrame) {
  	        return this.pv;
  	      }
  	      var cycleDuration;
  	      var lastKeyFrame;
  	      if (!durationFlag) {
  	        if (!duration || duration > keyframes.length - 1) {
  	          duration = keyframes.length - 1;
  	        }
  	        lastKeyFrame = keyframes[duration].t;
  	        cycleDuration = lastKeyFrame - firstKeyFrame;
  	      } else {
  	        if (!duration) {
  	          cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
  	        } else {
  	          cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
  	        }
  	        lastKeyFrame = firstKeyFrame + cycleDuration;
  	      }
  	      var i;
  	      var len;
  	      var ret;
  	      if (type === 'pingpong') {
  	        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
  	        if (iterations % 2 === 0) {
  	          return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
  	        }
  	      } else if (type === 'offset') {
  	        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
  	        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
  	        var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
  	        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
  	        if (this.pv.length) {
  	          ret = new Array(initV.length);
  	          len = ret.length;
  	          for (i = 0; i < len; i += 1) {
  	            ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
  	          }
  	          return ret;
  	        }
  	        return current - (endV - initV) * repeats;
  	      } else if (type === 'continue') {
  	        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
  	        var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
  	        if (this.pv.length) {
  	          ret = new Array(firstValue.length);
  	          len = ret.length;
  	          for (i = 0; i < len; i += 1) {
  	            ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
  	          }
  	          return ret;
  	        }
  	        return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
  	      }
  	      return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
  	    }
  	    function smooth(width, samples) {
  	      if (!this.k) {
  	        return this.pv;
  	      }
  	      width = (width || 0.4) * 0.5;
  	      samples = Math.floor(samples || 5);
  	      if (samples <= 1) {
  	        return this.pv;
  	      }
  	      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
  	      var initFrame = currentTime - width;
  	      var endFrame = currentTime + width;
  	      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
  	      var i = 0;
  	      var j = 0;
  	      var value;
  	      if (this.pv.length) {
  	        value = createTypedArray('float32', this.pv.length);
  	      } else {
  	        value = 0;
  	      }
  	      var sampleValue;
  	      while (i < samples) {
  	        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
  	        if (this.pv.length) {
  	          for (j = 0; j < this.pv.length; j += 1) {
  	            value[j] += sampleValue[j];
  	          }
  	        } else {
  	          value += sampleValue;
  	        }
  	        i += 1;
  	      }
  	      if (this.pv.length) {
  	        for (j = 0; j < this.pv.length; j += 1) {
  	          value[j] /= samples;
  	        }
  	      } else {
  	        value /= samples;
  	      }
  	      return value;
  	    }
  	    function getTransformValueAtTime(time) {
  	      if (!this._transformCachingAtTime) {
  	        this._transformCachingAtTime = {
  	          v: new Matrix()
  	        };
  	      }
  	      /// /
  	      var matrix = this._transformCachingAtTime.v;
  	      matrix.cloneFromProps(this.pre.props);
  	      if (this.appliedTransformations < 1) {
  	        var anchor = this.a.getValueAtTime(time);
  	        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
  	      }
  	      if (this.appliedTransformations < 2) {
  	        var scale = this.s.getValueAtTime(time);
  	        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
  	      }
  	      if (this.sk && this.appliedTransformations < 3) {
  	        var skew = this.sk.getValueAtTime(time);
  	        var skewAxis = this.sa.getValueAtTime(time);
  	        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
  	      }
  	      if (this.r && this.appliedTransformations < 4) {
  	        var rotation = this.r.getValueAtTime(time);
  	        matrix.rotate(-rotation * this.r.mult);
  	      } else if (!this.r && this.appliedTransformations < 4) {
  	        var rotationZ = this.rz.getValueAtTime(time);
  	        var rotationY = this.ry.getValueAtTime(time);
  	        var rotationX = this.rx.getValueAtTime(time);
  	        var orientation = this.or.getValueAtTime(time);
  	        matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
  	      }
  	      if (this.data.p && this.data.p.s) {
  	        var positionX = this.px.getValueAtTime(time);
  	        var positionY = this.py.getValueAtTime(time);
  	        if (this.data.p.z) {
  	          var positionZ = this.pz.getValueAtTime(time);
  	          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
  	        } else {
  	          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
  	        }
  	      } else {
  	        var position = this.p.getValueAtTime(time);
  	        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
  	      }
  	      return matrix;
  	      /// /
  	    }
  	    function getTransformStaticValueAtTime() {
  	      return this.v.clone(new Matrix());
  	    }
  	    var getTransformProperty = TransformPropertyFactory.getTransformProperty;
  	    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
  	      var prop = getTransformProperty(elem, data, container);
  	      if (prop.dynamicProperties.length) {
  	        prop.getValueAtTime = getTransformValueAtTime.bind(prop);
  	      } else {
  	        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
  	      }
  	      prop.setGroupProperty = expressionHelpers.setGroupProperty;
  	      return prop;
  	    };
  	    var propertyGetProp = PropertyFactory.getProp;
  	    PropertyFactory.getProp = function (elem, data, type, mult, container) {
  	      var prop = propertyGetProp(elem, data, type, mult, container);
  	      // prop.getVelocityAtTime = getVelocityAtTime;
  	      // prop.loopOut = loopOut;
  	      // prop.loopIn = loopIn;
  	      if (prop.kf) {
  	        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
  	      } else {
  	        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
  	      }
  	      prop.setGroupProperty = expressionHelpers.setGroupProperty;
  	      prop.loopOut = loopOut;
  	      prop.loopIn = loopIn;
  	      prop.smooth = smooth;
  	      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
  	      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
  	      prop.numKeys = data.a === 1 ? data.k.length : 0;
  	      prop.propertyIndex = data.ix;
  	      var value = 0;
  	      if (type !== 0) {
  	        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
  	      }
  	      prop._cachingAtTime = {
  	        lastFrame: initialDefaultFrame,
  	        lastIndex: 0,
  	        value: value
  	      };
  	      expressionHelpers.searchExpressions(elem, data, prop);
  	      if (prop.k) {
  	        container.addDynamicProperty(prop);
  	      }
  	      return prop;
  	    };
  	    function getShapeValueAtTime(frameNum) {
  	      // For now this caching object is created only when needed instead of creating it when the shape is initialized.
  	      if (!this._cachingAtTime) {
  	        this._cachingAtTime = {
  	          shapeValue: shapePool.clone(this.pv),
  	          lastIndex: 0,
  	          lastTime: initialDefaultFrame
  	        };
  	      }
  	      frameNum *= this.elem.globalData.frameRate;
  	      frameNum -= this.offsetTime;
  	      if (frameNum !== this._cachingAtTime.lastTime) {
  	        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
  	        this._cachingAtTime.lastTime = frameNum;
  	        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
  	      }
  	      return this._cachingAtTime.shapeValue;
  	    }
  	    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
  	    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
  	    function ShapeExpressions() {}
  	    ShapeExpressions.prototype = {
  	      vertices: function vertices(prop, time) {
  	        if (this.k) {
  	          this.getValue();
  	        }
  	        var shapePath = this.v;
  	        if (time !== undefined) {
  	          shapePath = this.getValueAtTime(time, 0);
  	        }
  	        var i;
  	        var len = shapePath._length;
  	        var vertices = shapePath[prop];
  	        var points = shapePath.v;
  	        var arr = createSizedArray(len);
  	        for (i = 0; i < len; i += 1) {
  	          if (prop === 'i' || prop === 'o') {
  	            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
  	          } else {
  	            arr[i] = [vertices[i][0], vertices[i][1]];
  	          }
  	        }
  	        return arr;
  	      },
  	      points: function points(time) {
  	        return this.vertices('v', time);
  	      },
  	      inTangents: function inTangents(time) {
  	        return this.vertices('i', time);
  	      },
  	      outTangents: function outTangents(time) {
  	        return this.vertices('o', time);
  	      },
  	      isClosed: function isClosed() {
  	        return this.v.c;
  	      },
  	      pointOnPath: function pointOnPath(perc, time) {
  	        var shapePath = this.v;
  	        if (time !== undefined) {
  	          shapePath = this.getValueAtTime(time, 0);
  	        }
  	        if (!this._segmentsLength) {
  	          this._segmentsLength = bez.getSegmentsLength(shapePath);
  	        }
  	        var segmentsLength = this._segmentsLength;
  	        var lengths = segmentsLength.lengths;
  	        var lengthPos = segmentsLength.totalLength * perc;
  	        var i = 0;
  	        var len = lengths.length;
  	        var accumulatedLength = 0;
  	        var pt;
  	        while (i < len) {
  	          if (accumulatedLength + lengths[i].addedLength > lengthPos) {
  	            var initIndex = i;
  	            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
  	            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
  	            pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
  	            break;
  	          } else {
  	            accumulatedLength += lengths[i].addedLength;
  	          }
  	          i += 1;
  	        }
  	        if (!pt) {
  	          pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
  	        }
  	        return pt;
  	      },
  	      vectorOnPath: function vectorOnPath(perc, time, vectorType) {
  	        // perc doesn't use triple equality because it can be a Number object as well as a primitive.
  	        if (perc == 1) {
  	          // eslint-disable-line eqeqeq
  	          perc = this.v.c;
  	        } else if (perc == 0) {
  	          // eslint-disable-line eqeqeq
  	          perc = 0.999;
  	        }
  	        var pt1 = this.pointOnPath(perc, time);
  	        var pt2 = this.pointOnPath(perc + 0.001, time);
  	        var xLength = pt2[0] - pt1[0];
  	        var yLength = pt2[1] - pt1[1];
  	        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
  	        if (magnitude === 0) {
  	          return [0, 0];
  	        }
  	        var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
  	        return unitVector;
  	      },
  	      tangentOnPath: function tangentOnPath(perc, time) {
  	        return this.vectorOnPath(perc, time, 'tangent');
  	      },
  	      normalOnPath: function normalOnPath(perc, time) {
  	        return this.vectorOnPath(perc, time, 'normal');
  	      },
  	      setGroupProperty: expressionHelpers.setGroupProperty,
  	      getValueAtTime: expressionHelpers.getStaticValueAtTime
  	    };
  	    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
  	    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
  	    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
  	    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
  	    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
  	    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
  	      var prop = propertyGetShapeProp(elem, data, type, arr, trims);
  	      prop.propertyIndex = data.ix;
  	      prop.lock = false;
  	      if (type === 3) {
  	        expressionHelpers.searchExpressions(elem, data.pt, prop);
  	      } else if (type === 4) {
  	        expressionHelpers.searchExpressions(elem, data.ks, prop);
  	      }
  	      if (prop.k) {
  	        elem.addDynamicProperty(prop);
  	      }
  	      return prop;
  	    };
  	  }
  	  function initialize$1() {
  	    addPropertyDecorator();
  	  }

  	  function addDecorator() {
  	    function searchExpressions() {
  	      if (this.data.d.x) {
  	        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
  	        this.addEffect(this.getExpressionValue.bind(this));
  	        return true;
  	      }
  	      return null;
  	    }
  	    TextProperty.prototype.getExpressionValue = function (currentValue, text) {
  	      var newValue = this.calculateExpression(text);
  	      if (currentValue.t !== newValue) {
  	        var newData = {};
  	        this.copyData(newData, currentValue);
  	        newData.t = newValue.toString();
  	        newData.__complete = false;
  	        return newData;
  	      }
  	      return currentValue;
  	    };
  	    TextProperty.prototype.searchProperty = function () {
  	      var isKeyframed = this.searchKeyframes();
  	      var hasExpressions = this.searchExpressions();
  	      this.kf = isKeyframed || hasExpressions;
  	      return this.kf;
  	    };
  	    TextProperty.prototype.searchExpressions = searchExpressions;
  	  }
  	  function initialize() {
  	    addDecorator();
  	  }

  	  function SVGComposableEffect() {}
  	  SVGComposableEffect.prototype = {
  	    createMergeNode: function createMergeNode(resultId, ins) {
  	      var feMerge = createNS('feMerge');
  	      feMerge.setAttribute('result', resultId);
  	      var feMergeNode;
  	      var i;
  	      for (i = 0; i < ins.length; i += 1) {
  	        feMergeNode = createNS('feMergeNode');
  	        feMergeNode.setAttribute('in', ins[i]);
  	        feMerge.appendChild(feMergeNode);
  	        feMerge.appendChild(feMergeNode);
  	      }
  	      return feMerge;
  	    }
  	  };

  	  var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';
  	  function SVGTintFilter(filter, filterManager, elem, id, source) {
  	    this.filterManager = filterManager;
  	    var feColorMatrix = createNS('feColorMatrix');
  	    feColorMatrix.setAttribute('type', 'matrix');
  	    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  	    feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');
  	    this.linearFilter = feColorMatrix;
  	    feColorMatrix.setAttribute('result', id + '_tint_1');
  	    filter.appendChild(feColorMatrix);
  	    feColorMatrix = createNS('feColorMatrix');
  	    feColorMatrix.setAttribute('type', 'matrix');
  	    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  	    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  	    feColorMatrix.setAttribute('result', id + '_tint_2');
  	    filter.appendChild(feColorMatrix);
  	    this.matrixFilter = feColorMatrix;
  	    var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);
  	    filter.appendChild(feMerge);
  	  }
  	  extendPrototype([SVGComposableEffect], SVGTintFilter);
  	  SVGTintFilter.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      var colorBlack = this.filterManager.effectElements[0].p.v;
  	      var colorWhite = this.filterManager.effectElements[1].p.v;
  	      var opacity = this.filterManager.effectElements[2].p.v / 100;
  	      this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');
  	      this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');
  	    }
  	  };

  	  function SVGFillFilter(filter, filterManager, elem, id) {
  	    this.filterManager = filterManager;
  	    var feColorMatrix = createNS('feColorMatrix');
  	    feColorMatrix.setAttribute('type', 'matrix');
  	    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  	    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  	    feColorMatrix.setAttribute('result', id);
  	    filter.appendChild(feColorMatrix);
  	    this.matrixFilter = feColorMatrix;
  	  }
  	  SVGFillFilter.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      var color = this.filterManager.effectElements[2].p.v;
  	      var opacity = this.filterManager.effectElements[6].p.v;
  	      this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
  	    }
  	  };

  	  function SVGStrokeEffect(fil, filterManager, elem) {
  	    this.initialized = false;
  	    this.filterManager = filterManager;
  	    this.elem = elem;
  	    this.paths = [];
  	  }
  	  SVGStrokeEffect.prototype.initialize = function () {
  	    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
  	    var path;
  	    var groupPath;
  	    var i;
  	    var len;
  	    if (this.filterManager.effectElements[1].p.v === 1) {
  	      len = this.elem.maskManager.masksProperties.length;
  	      i = 0;
  	    } else {
  	      i = this.filterManager.effectElements[0].p.v - 1;
  	      len = i + 1;
  	    }
  	    groupPath = createNS('g');
  	    groupPath.setAttribute('fill', 'none');
  	    groupPath.setAttribute('stroke-linecap', 'round');
  	    groupPath.setAttribute('stroke-dashoffset', 1);
  	    for (i; i < len; i += 1) {
  	      path = createNS('path');
  	      groupPath.appendChild(path);
  	      this.paths.push({
  	        p: path,
  	        m: i
  	      });
  	    }
  	    if (this.filterManager.effectElements[10].p.v === 3) {
  	      var mask = createNS('mask');
  	      var id = createElementID();
  	      mask.setAttribute('id', id);
  	      mask.setAttribute('mask-type', 'alpha');
  	      mask.appendChild(groupPath);
  	      this.elem.globalData.defs.appendChild(mask);
  	      var g = createNS('g');
  	      g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
  	      while (elemChildren[0]) {
  	        g.appendChild(elemChildren[0]);
  	      }
  	      this.elem.layerElement.appendChild(g);
  	      this.masker = mask;
  	      groupPath.setAttribute('stroke', '#fff');
  	    } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
  	      if (this.filterManager.effectElements[10].p.v === 2) {
  	        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
  	        while (elemChildren.length) {
  	          this.elem.layerElement.removeChild(elemChildren[0]);
  	        }
  	      }
  	      this.elem.layerElement.appendChild(groupPath);
  	      this.elem.layerElement.removeAttribute('mask');
  	      groupPath.setAttribute('stroke', '#fff');
  	    }
  	    this.initialized = true;
  	    this.pathMasker = groupPath;
  	  };
  	  SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
  	    if (!this.initialized) {
  	      this.initialize();
  	    }
  	    var i;
  	    var len = this.paths.length;
  	    var mask;
  	    var path;
  	    for (i = 0; i < len; i += 1) {
  	      if (this.paths[i].m !== -1) {
  	        mask = this.elem.maskManager.viewData[this.paths[i].m];
  	        path = this.paths[i].p;
  	        if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
  	          path.setAttribute('d', mask.lastPath);
  	        }
  	        if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
  	          var dasharrayValue;
  	          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
  	            var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
  	            var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
  	            var l = path.getTotalLength();
  	            dasharrayValue = '0 0 0 ' + l * s + ' ';
  	            var lineLength = l * (e - s);
  	            var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
  	            var units = Math.floor(lineLength / segment);
  	            var j;
  	            for (j = 0; j < units; j += 1) {
  	              dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
  	            }
  	            dasharrayValue += '0 ' + l * 10 + ' 0 0';
  	          } else {
  	            dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
  	          }
  	          path.setAttribute('stroke-dasharray', dasharrayValue);
  	        }
  	      }
  	    }
  	    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
  	      this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
  	    }
  	    if (forceRender || this.filterManager.effectElements[6].p._mdf) {
  	      this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
  	    }
  	    if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
  	      if (forceRender || this.filterManager.effectElements[3].p._mdf) {
  	        var color = this.filterManager.effectElements[3].p.v;
  	        this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
  	      }
  	    }
  	  };

  	  function SVGTritoneFilter(filter, filterManager, elem, id) {
  	    this.filterManager = filterManager;
  	    var feColorMatrix = createNS('feColorMatrix');
  	    feColorMatrix.setAttribute('type', 'matrix');
  	    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  	    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  	    filter.appendChild(feColorMatrix);
  	    var feComponentTransfer = createNS('feComponentTransfer');
  	    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  	    feComponentTransfer.setAttribute('result', id);
  	    this.matrixFilter = feComponentTransfer;
  	    var feFuncR = createNS('feFuncR');
  	    feFuncR.setAttribute('type', 'table');
  	    feComponentTransfer.appendChild(feFuncR);
  	    this.feFuncR = feFuncR;
  	    var feFuncG = createNS('feFuncG');
  	    feFuncG.setAttribute('type', 'table');
  	    feComponentTransfer.appendChild(feFuncG);
  	    this.feFuncG = feFuncG;
  	    var feFuncB = createNS('feFuncB');
  	    feFuncB.setAttribute('type', 'table');
  	    feComponentTransfer.appendChild(feFuncB);
  	    this.feFuncB = feFuncB;
  	    filter.appendChild(feComponentTransfer);
  	  }
  	  SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      var color1 = this.filterManager.effectElements[0].p.v;
  	      var color2 = this.filterManager.effectElements[1].p.v;
  	      var color3 = this.filterManager.effectElements[2].p.v;
  	      var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
  	      var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
  	      var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
  	      this.feFuncR.setAttribute('tableValues', tableR);
  	      this.feFuncG.setAttribute('tableValues', tableG);
  	      this.feFuncB.setAttribute('tableValues', tableB);
  	    }
  	  };

  	  function SVGProLevelsFilter(filter, filterManager, elem, id) {
  	    this.filterManager = filterManager;
  	    var effectElements = this.filterManager.effectElements;
  	    var feComponentTransfer = createNS('feComponentTransfer');

  	    // Red
  	    if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
  	      this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
  	    }
  	    // Green
  	    if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
  	      this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
  	    }
  	    // Blue
  	    if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
  	      this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
  	    }
  	    // Alpha
  	    if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
  	      this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
  	    }
  	    // RGB
  	    if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
  	      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  	      filter.appendChild(feComponentTransfer);
  	    }
  	    if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
  	      feComponentTransfer = createNS('feComponentTransfer');
  	      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  	      feComponentTransfer.setAttribute('result', id);
  	      filter.appendChild(feComponentTransfer);
  	      this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
  	      this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
  	      this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
  	    }
  	  }
  	  SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
  	    var feFunc = createNS(type);
  	    feFunc.setAttribute('type', 'table');
  	    feComponentTransfer.appendChild(feFunc);
  	    return feFunc;
  	  };
  	  SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
  	    var cnt = 0;
  	    var segments = 256;
  	    var perc;
  	    var min = Math.min(inputBlack, inputWhite);
  	    var max = Math.max(inputBlack, inputWhite);
  	    var table = Array.call(null, {
  	      length: segments
  	    });
  	    var colorValue;
  	    var pos = 0;
  	    var outputDelta = outputWhite - outputBlack;
  	    var inputDelta = inputWhite - inputBlack;
  	    while (cnt <= 256) {
  	      perc = cnt / 256;
  	      if (perc <= min) {
  	        colorValue = inputDelta < 0 ? outputWhite : outputBlack;
  	      } else if (perc >= max) {
  	        colorValue = inputDelta < 0 ? outputBlack : outputWhite;
  	      } else {
  	        colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
  	      }
  	      table[pos] = colorValue;
  	      pos += 1;
  	      cnt += 256 / (segments - 1);
  	    }
  	    return table.join(' ');
  	  };
  	  SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      var val;
  	      var effectElements = this.filterManager.effectElements;
  	      if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
  	        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
  	        this.feFuncRComposed.setAttribute('tableValues', val);
  	        this.feFuncGComposed.setAttribute('tableValues', val);
  	        this.feFuncBComposed.setAttribute('tableValues', val);
  	      }
  	      if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
  	        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
  	        this.feFuncR.setAttribute('tableValues', val);
  	      }
  	      if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
  	        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
  	        this.feFuncG.setAttribute('tableValues', val);
  	      }
  	      if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
  	        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
  	        this.feFuncB.setAttribute('tableValues', val);
  	      }
  	      if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
  	        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
  	        this.feFuncA.setAttribute('tableValues', val);
  	      }
  	    }
  	  };

  	  function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
  	    var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
  	    var filterSize = filterManager.data.fs || globalFilterSize;
  	    filter.setAttribute('x', filterSize.x || globalFilterSize.x);
  	    filter.setAttribute('y', filterSize.y || globalFilterSize.y);
  	    filter.setAttribute('width', filterSize.width || globalFilterSize.width);
  	    filter.setAttribute('height', filterSize.height || globalFilterSize.height);
  	    this.filterManager = filterManager;
  	    var feGaussianBlur = createNS('feGaussianBlur');
  	    feGaussianBlur.setAttribute('in', 'SourceAlpha');
  	    feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
  	    feGaussianBlur.setAttribute('stdDeviation', '0');
  	    this.feGaussianBlur = feGaussianBlur;
  	    filter.appendChild(feGaussianBlur);
  	    var feOffset = createNS('feOffset');
  	    feOffset.setAttribute('dx', '25');
  	    feOffset.setAttribute('dy', '0');
  	    feOffset.setAttribute('in', id + '_drop_shadow_1');
  	    feOffset.setAttribute('result', id + '_drop_shadow_2');
  	    this.feOffset = feOffset;
  	    filter.appendChild(feOffset);
  	    var feFlood = createNS('feFlood');
  	    feFlood.setAttribute('flood-color', '#00ff00');
  	    feFlood.setAttribute('flood-opacity', '1');
  	    feFlood.setAttribute('result', id + '_drop_shadow_3');
  	    this.feFlood = feFlood;
  	    filter.appendChild(feFlood);
  	    var feComposite = createNS('feComposite');
  	    feComposite.setAttribute('in', id + '_drop_shadow_3');
  	    feComposite.setAttribute('in2', id + '_drop_shadow_2');
  	    feComposite.setAttribute('operator', 'in');
  	    feComposite.setAttribute('result', id + '_drop_shadow_4');
  	    filter.appendChild(feComposite);
  	    var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);
  	    filter.appendChild(feMerge);
  	    //
  	  }
  	  extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
  	  SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
  	        this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
  	      }
  	      if (forceRender || this.filterManager.effectElements[0].p._mdf) {
  	        var col = this.filterManager.effectElements[0].p.v;
  	        this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
  	      }
  	      if (forceRender || this.filterManager.effectElements[1].p._mdf) {
  	        this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
  	      }
  	      if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
  	        var distance = this.filterManager.effectElements[3].p.v;
  	        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
  	        var x = distance * Math.cos(angle);
  	        var y = distance * Math.sin(angle);
  	        this.feOffset.setAttribute('dx', x);
  	        this.feOffset.setAttribute('dy', y);
  	      }
  	    }
  	  };

  	  var _svgMatteSymbols = [];
  	  function SVGMatte3Effect(filterElem, filterManager, elem) {
  	    this.initialized = false;
  	    this.filterManager = filterManager;
  	    this.filterElem = filterElem;
  	    this.elem = elem;
  	    elem.matteElement = createNS('g');
  	    elem.matteElement.appendChild(elem.layerElement);
  	    elem.matteElement.appendChild(elem.transformedElement);
  	    elem.baseElement = elem.matteElement;
  	  }
  	  SVGMatte3Effect.prototype.findSymbol = function (mask) {
  	    var i = 0;
  	    var len = _svgMatteSymbols.length;
  	    while (i < len) {
  	      if (_svgMatteSymbols[i] === mask) {
  	        return _svgMatteSymbols[i];
  	      }
  	      i += 1;
  	    }
  	    return null;
  	  };
  	  SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
  	    var parentNode = mask.layerElement.parentNode;
  	    if (!parentNode) {
  	      return;
  	    }
  	    var children = parentNode.children;
  	    var i = 0;
  	    var len = children.length;
  	    while (i < len) {
  	      if (children[i] === mask.layerElement) {
  	        break;
  	      }
  	      i += 1;
  	    }
  	    var nextChild;
  	    if (i <= len - 2) {
  	      nextChild = children[i + 1];
  	    }
  	    var useElem = createNS('use');
  	    useElem.setAttribute('href', '#' + symbolId);
  	    if (nextChild) {
  	      parentNode.insertBefore(useElem, nextChild);
  	    } else {
  	      parentNode.appendChild(useElem);
  	    }
  	  };
  	  SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
  	    if (!this.findSymbol(mask)) {
  	      var symbolId = createElementID();
  	      var masker = createNS('mask');
  	      masker.setAttribute('id', mask.layerId);
  	      masker.setAttribute('mask-type', 'alpha');
  	      _svgMatteSymbols.push(mask);
  	      var defs = elem.globalData.defs;
  	      defs.appendChild(masker);
  	      var symbol = createNS('symbol');
  	      symbol.setAttribute('id', symbolId);
  	      this.replaceInParent(mask, symbolId);
  	      symbol.appendChild(mask.layerElement);
  	      defs.appendChild(symbol);
  	      var useElem = createNS('use');
  	      useElem.setAttribute('href', '#' + symbolId);
  	      masker.appendChild(useElem);
  	      mask.data.hd = false;
  	      mask.show();
  	    }
  	    elem.setMatte(mask.layerId);
  	  };
  	  SVGMatte3Effect.prototype.initialize = function () {
  	    var ind = this.filterManager.effectElements[0].p.v;
  	    var elements = this.elem.comp.elements;
  	    var i = 0;
  	    var len = elements.length;
  	    while (i < len) {
  	      if (elements[i] && elements[i].data.ind === ind) {
  	        this.setElementAsMask(this.elem, elements[i]);
  	      }
  	      i += 1;
  	    }
  	    this.initialized = true;
  	  };
  	  SVGMatte3Effect.prototype.renderFrame = function () {
  	    if (!this.initialized) {
  	      this.initialize();
  	    }
  	  };

  	  function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
  	    // Outset the filter region by 100% on all sides to accommodate blur expansion.
  	    filter.setAttribute('x', '-100%');
  	    filter.setAttribute('y', '-100%');
  	    filter.setAttribute('width', '300%');
  	    filter.setAttribute('height', '300%');
  	    this.filterManager = filterManager;
  	    var feGaussianBlur = createNS('feGaussianBlur');
  	    feGaussianBlur.setAttribute('result', id);
  	    filter.appendChild(feGaussianBlur);
  	    this.feGaussianBlur = feGaussianBlur;
  	  }
  	  SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
  	    if (forceRender || this.filterManager._mdf) {
  	      // Empirical value, matching AE's blur appearance.
  	      var kBlurrinessToSigma = 0.3;
  	      var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

  	      // Dimensions mapping:
  	      //
  	      //   1 -> horizontal & vertical
  	      //   2 -> horizontal only
  	      //   3 -> vertical only
  	      //
  	      var dimensions = this.filterManager.effectElements[1].p.v;
  	      var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq
  	      var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

  	      this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

  	      // Repeat edges mapping:
  	      //
  	      //   0 -> off -> duplicate
  	      //   1 -> on  -> wrap
  	      var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
  	      this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
  	    }
  	  };

  	  function TransformEffect() {}
  	  TransformEffect.prototype.init = function (effectsManager) {
  	    this.effectsManager = effectsManager;
  	    this.type = effectTypes.TRANSFORM_EFFECT;
  	    this.matrix = new Matrix();
  	    this.opacity = -1;
  	    this._mdf = false;
  	    this._opMdf = false;
  	  };
  	  TransformEffect.prototype.renderFrame = function (forceFrame) {
  	    this._opMdf = false;
  	    this._mdf = false;
  	    if (forceFrame || this.effectsManager._mdf) {
  	      var effectElements = this.effectsManager.effectElements;
  	      var anchor = effectElements[0].p.v;
  	      var position = effectElements[1].p.v;
  	      var isUniformScale = effectElements[2].p.v === 1;
  	      var scaleHeight = effectElements[3].p.v;
  	      var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
  	      var skew = effectElements[5].p.v;
  	      var skewAxis = effectElements[6].p.v;
  	      var rotation = effectElements[7].p.v;
  	      this.matrix.reset();
  	      this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
  	      this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
  	      this.matrix.rotate(-rotation * degToRads);
  	      this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
  	      this.matrix.translate(position[0], position[1], 0);
  	      this._mdf = true;
  	      if (this.opacity !== effectElements[8].p.v) {
  	        this.opacity = effectElements[8].p.v;
  	        this._opMdf = true;
  	      }
  	    }
  	  };

  	  function SVGTransformEffect(_, filterManager) {
  	    this.init(filterManager);
  	  }
  	  extendPrototype([TransformEffect], SVGTransformEffect);

  	  function CVTransformEffect(effectsManager) {
  	    this.init(effectsManager);
  	  }
  	  extendPrototype([TransformEffect], CVTransformEffect);

  	  // Registering renderers
  	  registerRenderer('canvas', CanvasRenderer);
  	  registerRenderer('html', HybridRenderer);
  	  registerRenderer('svg', SVGRenderer);

  	  // Registering shape modifiers
  	  ShapeModifiers.registerModifier('tm', TrimModifier);
  	  ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
  	  ShapeModifiers.registerModifier('rp', RepeaterModifier);
  	  ShapeModifiers.registerModifier('rd', RoundCornersModifier);
  	  ShapeModifiers.registerModifier('zz', ZigZagModifier);
  	  ShapeModifiers.registerModifier('op', OffsetPathModifier);

  	  // Registering expression plugin
  	  setExpressionsPlugin(Expressions);
  	  setExpressionInterfaces(getInterface);
  	  initialize$1();
  	  initialize();

  	  // Registering svg effects
  	  registerEffect$1(20, SVGTintFilter, true);
  	  registerEffect$1(21, SVGFillFilter, true);
  	  registerEffect$1(22, SVGStrokeEffect, false);
  	  registerEffect$1(23, SVGTritoneFilter, true);
  	  registerEffect$1(24, SVGProLevelsFilter, true);
  	  registerEffect$1(25, SVGDropShadowEffect, true);
  	  registerEffect$1(28, SVGMatte3Effect, false);
  	  registerEffect$1(29, SVGGaussianBlurEffect, true);
  	  registerEffect$1(35, SVGTransformEffect, false);
  	  registerEffect(35, CVTransformEffect);

  	  return lottie;

  	})); 
  } (lottie$1, lottie$1.exports));

  var lottieExports = lottie$1.exports;
  var lottie = /*@__PURE__*/getDefaultExportFromCjs(lottieExports);

  var Lottie = /*#__PURE__*/function () {
    function Lottie() {
      _classCallCheck(this, Lottie);
      this.load();
      window.addEventListener('load', function () {
        ScrollTrigger$1.refresh();
      });
    }
    return _createClass$1(Lottie, [{
      key: "load",
      value: function load() {
        var items = document.querySelectorAll('.js-lottie');
        if (items.length > 0) {
          items.forEach(function (item) {
            var once = !!item.dataset.once;
            var animation = lottie.loadAnimation({
              container: item,
              renderer: 'svg',
              // or 'canvas' / 'html'
              loop: !once,
              autoplay: !once,
              path: item.dataset.src
            });
            if (once) {
              ScrollTrigger$1.create({
                trigger: item,
                start: "top 70%",
                once: true,
                onEnter: function onEnter() {
                  animation.goToAndPlay(0, true);
                }
              });
            }
          });
        }
      }
    }]);
  }();

  const model = { "UW3": { "": 6699, "": 3897, "": 4784, "": 3706, "": 4162, "": 5769, "": 4221, "": 2900, "": 2971, "": 2902, "": 3155, "": 2242, "": 2447, "": 3372, "": 2217, "": 1855, "": 2357, "": -1853, "": 2814, "": 1353, "": 967, "": 1790, "": 2166, "": 1899, "": 3358, "": 1013, "": 3252, "": -102, "": 2149, "": 3703, "": 2093, "": 1074, "": 2428, "": 1732, "": 992, "": -2327, "": 2573, "": -2137, "": 2675, "": -1495, "": 428, "": -1870, "": 1078, "": 1608, "": 2714, "": -1669, "": 335, "": 866, "": 2073, "": 1142, "": 2335, "": 1456, "": 475, "": 514, "": 1179, "": 1080, "": 2053, "": 1111, "": 1389, "": -1134, "": -1396, "": 998, "": 486, "": -794, "": -568, "": 938, "": -599, "": -370, "": -681, "": 752, "": -870, "": 1322, "": -1285, "": -284, "": -1434, "": -337, "": 530, "": 713, "": -901, "": 1112, "": 1224, "": 1435, "": -1196, "": 982, "": -976, "": -517, "": -725, "": -995, "": -636, "": 728, "": 902, "": 1480, "": -700, "": 1404, "": -550, "": 1000, "": 1464, "": -819, "": -718, "": 1287, "": -960, "": 1113, "": -710, "": 1294, "": 920, "": -552, "": -749, "": 584, "": 701, "": 328, "": 976, "": 672, "": 515, "": 489, "": 295, "": 680, "": 13, "": 768, "": -218, "": -477, "": 825, "": 344, "": -711, "": -463, "": -419, "": 363, "": 130, "": 275, "": -520, "": 588, "": 181, "": 159, "": -635, "": 160, "": 304, "": -352, "": 767, "": 252, "": 469, "": 257, "": 454, "": -160, "": 338, "": -102, "": -136, "": -240, "": 203, "": -50, "": 285, "": 486, "": 270, "": 398, "": 101, "": -160, "": 159, "": 215, "": -149, "": 189, "": 94, "": -111, "": 149, "": 145, "": -93, "": -76, "": 50, "": 54, "": -54, "": -29, "": 33, "": 12, "": -16 }, "UW4": { "": -7440, "": -4018, "": -3577, "": -4299, "": -3839, "": -5462, "": -7452, "": -3332, "": -4313, "": -3120, "": -4861, "": -2446, "": -2917, "": -4081, "": -1296, "": -1675, "": 501, "": -4326, "": -1928, "": 456, "": -2884, "": -2662, "": -4391, "": 591, "": -1725, "": -517, "": -2037, "": -2074, "": -1531, "": -3821, "": -2899, "": -2746, "": -1111, "": 652, "": 411, "": 1386, "": -1159, "": 2526, "": 788, "": -5393, "": -2352, "": -1257, "": -3441, "": -1867, "": -1716, "": -643, "": 2301, "": 1003, "": 695, "": 1811, "": 333, "": 576, "": 564, "": -1762, "": 2351, "": 614, "": -4205, "": -1624, "": 512, "": 1957, "": -4469, "": -1844, "": -2189, "": 384, "": -677, "": -2078, "": 710, "": -816, "": -2964, "": 270, "": 430, "": -2793, "": -1498, "": -1178, "": -2432, "": -1195, "": 1131, "": 2399, "": 180, "": -2208, "": -2265, "": -3412, "": -4207, "": -2267, "": 1291, "": 1247, "": -1619, "": -3444, "": -1249, "": -697, "": 1760, "": -2874, "": 227, "": 820, "": -1966, "": -507, "": 1002, "": -2441, "": 386, "": 792, "": 533, "": 1072, "": -716, "": -1138, "": -393, "": 441, "": 1062, "": -707, "": -1270, "": -3209, "": -1427, "": 235, "": 412, "": 744, "": -1659, "": 451, "": -1501, "": -1428, "": 34, "": 1076, "": 1409, "": -817, "": 673, "": 344, "": -1527, "": 286, "": -375, "": -374, "": -1261, "": -948, "": 724, "": -949, "": -1513, "": 736, "": 856, "": -1296, "": -1156, "": -76, "": 308, "": 475, "": 411, "": -218, "": 481, "": -582, "": 436, "": 505, "": -347, "": -356, "": -907, "": 229, "": 623, "": 413, "": 368, "": -776, "": 117, "": -935, "": 316, "": -233, "": -840, "": -625, "": 22, "": 181, "": -500, "": -489, "": 368, "": 366, "": 192, "": 443, "": 470, "": -204, "": -434, "": -176, "": -568, "": 383, "": -212, "": -278, "": 191, "": 150, "": 403, "": -157, "": -148, "": -455, "": -327, "": 174, "": -471, "": 28, "": 307, "": 179, "": 153, "": -247, "": -156, "": 254, "": 138, "": 75, "": -75, "": 101, "": 264, "": 61, "": -148, "": -256, "": -125, "": 52, "": -142, "": 159, "": -154, "": -56, "": -145, "": 63, "": 54, "": 45, "": 45, "": -45, "": -41, "": -8, "": -8, "": 4, "": 4 }, "UW5": { "": -2177, "": -955, "": -681, "": -1011, "": -608, "": -353, "": 169, "": 964, "": 175, "": -874, "": 1177, "": -394, "": 345, "": -674, "": 287, "": 500, "": 886, "": -612, "": -421, "": 219, "": 710, "": 1871, "": 637, "": 1001, "": -271, "": 198, "": 293, "": 345, "": -1082, "": -617, "": -587, "": -641, "": -360, "": -1087, "": 210, "": -338, "": 851, "": 303, "": 495, "": 1494, "": 222, "": 1173, "": -327, "": 1091, "": -472, "": 776, "": -1068, "": -285, "": 1415, "": 342, "": -272, "": 826, "": -303, "": -891, "": 572, "": 1123, "": 409, "": 876, "": -1390, "": 365, "": 791, "": -384, "": -470, "": 255, "": 15, "": -1133, "": 708, "": 159, "": -254, "": -93, "": 325, "": -341, "": -571, "": -313, "": -1085, "": 401, "": 505, "": 173, "": 171, "": -272, "": -122, "": 579, "": -461, "": 348, "": 179, "": -872, "": 458, "": -209, "": -184, "": 244, "": -180, "": -192, "": -154, "": -562, "": 40, "": -151, "": -41, "": 209, "": -123, "": 49, "": -116, "": 104, "": 95, "": -146, "": -176, "": 111, "": -30, "": 90, "": 4, "": -135, "": -67, "": 42, "": -101, "": -54, "": 46, "": 29, "": 104, "": -29, "": -37, "": 8, "": 4 }, "UW2": { "": -1401, "": -1370, "": -2403, "": -1207, "": -653, "": -1010, "": 18, "": 5, "": 269, "": 2215, "": -985, "": -489, "": 1762, "": -695, "": -534, "": -810, "": 523, "": 1668, "": 922, "": -812, "": 81, "": -751, "": -813, "": -233, "": 1197, "": -49, "": 344, "": -711, "": 981, "": -682, "": -556, "": 1671, "": 1952, "": 754, "": 676, "": 445, "": 1001, "": -118, "": 2257, "": -421, "": 577, "": 567, "": -479, "": 1341, "": 201, "": 531, "": -492, "": -482, "": -464, "": 745, "": -377, "": 694, "": -79, "": 266, "": -1004, "": 387, "": -477, "": -423, "": -246, "": -1313, "": 283, "": 848, "": 663, "": -1353, "": 956, "": 335, "": -1421, "": -207, "": -1437, "": 274, "": 567, "": 396, "": 341, "": -264, "": -551, "": 787, "": -173, "": 826, "": 435, "": 1181, "": 498, "": 276, "": 494, "": -91, "": 167, "": -109, "": -123, "": 70, "": -122, "": 315, "": -664, "": 557, "": -47, "": -793, "": 289, "": -487, "": 990, "": -195, "": -360, "": 149, "": 190, "": 161, "": -306, "": -499, "": 313, "": -361, "": 748, "": -160, "": 183, "": -210, "": 54, "": -310, "": -161, "": 93, "": 80, "": 124, "": -292, "": 154, "": 31, "": 227, "": 97, "": 159, "": -115, "": 94, "": 106, "": -50, "": -84, "": 42, "": 75, "": 58, "": 16, "": 130, "": 100, "": -16, "": -25, "": -33, "": 20, "": -12, "": -4 }, "UW6": { "": 320, "": -307, "": -16, "": 219, "": 307, "": 581, "": 621, "": 828, "": -496, "": 1589, "": 218, "": -90, "": 95, "": 1415, "": 1711, "": 555, "": -283, "": 85, "": 2064, "": 35, "": 819, "": 578, "": -864, "": 245, "": 506, "": 352, "": -17, "": 301, "": 71, "": 231, "": 365, "": 65, "": -101, "": 527, "": -213, "": -66, "": 324, "": -1272, "": -346, "": 207, "": 626, "": 240, "": 180, "": -284, "": -906, "": 611, "": -639, "": 1217, "": -361, "": 755, "": 221, "": 679, "": 85, "": 479, "": 567, "": 380, "": 415, "": -111, "": 813, "": 170, "": 239, "": -18, "": 780, "": 292, "": -896, "": -261, "": 846, "": -244, "": -725, "": -130, "": -388, "": -403, "": -248, "": 643, "": 119, "": -150, "": 216, "": 60, "": -64, "": -235, "": 33, "": 41, "": 164, "": 360, "": 129, "": -94, "": 280, "": 204, "": -18, "": 123, "": 168, "": -112, "": 275, "": 68, "": 114, "": 33, "": -20, "": -4, "": 8, "": -4 }, "UW1": { "": -273, "": 275, "": 128, "": 922, "": 890, "": 165, "": -385, "": -34, "": 210, "": -91, "": 289, "": -230, "": -127, "": 209, "": -102, "": 1464, "": -344, "": -1424, "": 241, "": 511, "": -220, "": 60, "": 1969, "": -26, "": 127, "": -1038, "": 1899, "": 72, "": -44, "": -86, "": -176, "": 137, "": 194, "": 303, "": -601, "": 113, "": -110, "": 572, "": 285, "": -428, "": -30, "": 301, "": -155, "": -96, "": 275, "": -524, "": -251, "": 134, "": 412, "": 151, "": 599, "": -164, "": 183, "": -196, "": 266, "": 134, "": 574, "": -371, "": 254, "": 318, "": -400, "": -53, "": 619, "": 211, "": -258, "": 96, "": -306, "": 173, "": 64, "": 588, "": 124, "": -248, "": -49, "": 225, "": 365, "": 137, "": -382, "": 42, "": -31, "": 170, "": -17, "": 117, "": 63, "": 178, "": -72, "": 92, "": -79, "": 76, "": 113, "": 209, "": 65, "": -182, "": 79, "": 120, "": 137, "": 144, "": -42, "": 114, "": 63, "": 50, "": 126, "": -16, "": -12, "": -8, "": -79, "": 12, "": -8, "": -29, "": 16 }, "BW2": { "": 1475, "": -3875, "": 274, "": -2003, "": -2999, "": -2622, "": -1296, "": -3302, "": -838, "": -3035, "": -2116, "": -1737, "": -2082, "": -921, "": -2119, "": -1012, "": -1213, "": -2465, "": -1810, "": -1022, "": -1771, "": -1689, "": -331, "": -1100, "": -643, "": -2518, "": -1807, "": -1351, "": -1856, "": -558, "": -2737, "": -2687, "": -1520, "": -944, "": 709, "": -935, "": -1014, "": -2039, "": -1183, "": -1524, "": -652, "": -490, "": -1248, "": -675, "": -1684, "": -820, "": -873, "": -956, "": -362, "": 1674, "": -722, "": -753, "": -421, "": 545, "": -890, "": -770, "": -1196, "": -1043, "": -1221, "": -1069, "": -1494, "": -1185, "": -1027, "": -659, "": 159, "": -681, "": 280, "": -458, "": -1227, "": -851, "": 458, "": -968, "": -145, "": 421, "": -489, "": -782, "": -64, "": -299, "": -278, "": -1003, "": 318, "": -337, "": -157, "": -402, "": -433, "": -357, "": -523, "": -230, "": -157, "": -393, "": 41, "": -359, "": -401, "": -494, "": -333, "": -524, "": -442, "": -175, "": -144, "": 476, "": -197, "": -297, "": -643, "": -151, "": 191, "": 195, "": -539, "": -137, "": -374, "": -360, "": -127, "": 186, "": -152, "": -93, "": -101, "": 80, "": -126, "": 83, "": 62, "": 96, "": -54, "": -33, "": -37, "": -20 }, "BW1": { "": 3058, "": 1223, "": 2830, "": 1723, "": 2162, "": 1494, "": 3534, "": -2703, "": 969, "": 1045, "": -1066, "": -518, "": 166, "": -948, "": -1455, "": 922, "": 1688, "": -1593, "": 513, "": -1543, "": 1277, "": 1376, "": 667, "": -1393, "": 917, "": -1290, "": 631, "": -1620, "": 471, "": 1085, "": 2456, "": 949, "": -70, "": 623, "": 1018, "": 1515, "": -1545, "": -1039, "": 816, "": 1694, "": 1178, "": -1090, "": -96, "": 1198, "": -325, "": 1343, "": 588, "": 1414, "": 1375, "": 1349, "": 1413, "": 1231, "": 936, "": 1014, "": 1427, "": 202, "": 1736, "": 1018, "": 138, "": 436, "": -725, "": -329, "": 1251, "": -1273, "": 702, "": 141, "": -196, "": 572, "": 1571, "": 356, "": -399, "": -429, "": 350, "": 242, "": 293, "": 1050, "": 1155, "": 1137, "": -369, "": -1096, "": 391, "": -522, "": 941, "": 680, "": 515, "": -781, "": -844, "": 655, "": 725, "": 57, "": 791, "": 687, "": -579, "": 310, "": 310, "": -538, "": 398, "": 482, "": 372, "": 401, "": 753, "": 626, "": 96, "": -364, "": 252, "": 444, "": -715, "": -591, "": -137, "": -698, "": 322, "": -429, "": 564, "": 304, "": 302, "": 789, "": -159, "": 625, "": 437, "": -442, "": 416, "": -619, "": 449, "": 245, "": 589, "": 524, "": 160, "": -255, "": 218, "": 149, "": 386, "": 236, "": 424, "": 254, "": 342, "": -303, "": 237, "": -302, "": -315, "": 281, "": 274, "": 199, "": 147, "": 190, "": -216, "": 180, "": -98, "": 115, "": 102, "": -71, "": 83, "": -20, "": 29, "": -24, "": 24, "": 12, "": 37, "": -4 }, "BW3": { "": 4971, "": 3479, "": 1053, "": 712, "": -404, "": 719, "": 1571, "": -943, "": 3173, "": -693, "": 1383, "": 1979, "": 1237, "": -2875, "": 3096, "": 402, "": -1016, "": 899, "": 647, "": 1643, "": 1844, "": -512, "": -1257, "": -339, "": 1656, "": 1917, "": -1050, "": 1242, "": -1223, "": 1098, "": 980, "": 2909, "": 2245, "": 481, "": 3011, "": 1986, "": 278, "": 678, "": 2538, "": 364, "": -190, "": -184, "": 1752, "": 2306, "": -397, "": -1499, "": -1463, "": -93, "": 1038, "": -1778, "": 1078, "": 832, "": 1442, "": -941, "": 813, "": -1566, "": 444, "": 727, "": 1082, "": 897, "": -807, "": 287, "": 686, "": 1075, "": 296, "": 1041, "": -152, "": 917, "": 408, "": 1283, "": -802, "": 1198, "": -519, "": 1094, "": 1264, "": 422, "": -670, "": -1304, "": 121, "": -670, "": 480, "": 589, "": 691, "": 348, "": 556, "": 742, "": 414, "": -672, "": -739, "": 821, "": -372, "": 198, "": -160, "": 680, "": -93, "": 626, "": -479, "": 732, "": 429, "": -268, "": 666, "": 296, "": -514, "": -677, "": 627, "": -520, "": 539, "": 621, "": -239, "": -596, "": -428, "": 437, "": -350, "": -238, "": 552, "": 272, "": -218, "": 128, "": -136, "": 260, "": 438, "": 128, "": 85, "": 251, "": -374, "": 233, "": -357, "": 249, "": -345, "": 8, "": 214, "": 109, "": -161, "": 329, "": 203, "": 246, "": 119, "": 46, "": 121, "": 62, "": -58, "": 71, "": -95, "": -28, "": -24, "": -24, "": 12 }, "TW3": { "": 970, "": -1899, "": -1724, "": 655, "": -2756, "": -1375, "": -473, "": -961, "": 710, "": -1361, "": -1075, "": -1539, "": -289, "": -1169, "": -1166, "": 769, "": -749, "": -293, "": -49, "": -812, "": 229, "": 574, "": 75, "": -408, "": -183, "": -535, "": -120, "": -137, "": -37, "": -66, "": 108, "": -54, "": -4 }, "TW4": { "": 2195, "": -1673, "": 1598, "": -1569, "": -1767, "": 2848, "": 2069, "": -1366, "": -2232, "": -824, "": 1066, "": 1092, "": 1258, "": -925, "": -856, "": 1697, "": 1383, "": 380, "": 191, "": -588, "": -595, "": 1130, "": -1150, "": 406, "": 683, "": 628, "": 590, "": 651, "": 256, "": -896, "": 669, "": 253, "": 438, "": 512, "": 255, "": -234, "": -824, "": 481, "": 314, "": 278, "": 397, "": 424, "": 494, "": -232, "": -390, "": 140, "": -174, "": 52, "": 116, "": -102, "": 170, "": -75, "": -63, "": 37, "": 20, "": 16 }, "TW2": { "": -4086, "": -1086, "": -1130, "": -463, "": -2306, "": -1441, "": -803, "": -406, "": -936, "": -267, "": 440, "": -757, "": -477, "": -436, "": -207, "": -59, "": 50, "": -37 }, "TW1": { "": 545, "": 1686, "": 1298, "": 1104, "": -1851, "": 2079, "": 1444, "": 1162, "": 2083, "": 1728, "": 1223, "": 1174, "": 947, "": 811, "": 1250, "": 412, "": -1039, "": -691, "": -1017, "": -418, "": 732, "": 251, "": -268, "": 267, "": 698, "": 556, "": 599, "": 676, "": 309, "": 141, "": -68, "": 196, "": 225, "": -271, "": 164, "": -86, "": 163, "": 54, "": 16, "": 4 } };

  // used in Attr to signal changes
  const CHANGED = Symbol('changed');

  // used in Element to setup once classList
  const CLASS_LIST = Symbol('classList');

  // used in Document to attach once customElements
  const CUSTOM_ELEMENTS = Symbol('CustomElements');

  // used in HTMLTemplateElement
  const CONTENT = Symbol('content');

  // used in Element for data attributes
  const DATASET = Symbol('dataset');

  // used in Document to attach the DocType
  const DOCTYPE = Symbol('doctype');

  // used in parser and Document to attach once a DOMParser
  const DOM_PARSER = Symbol('DOMParser');

  // used to reference an end node
  const END = Symbol('end');

  // used in Document to make the globalThis an event target
  const EVENT_TARGET = Symbol('EventTarget');

  // used to augment a created document defaultView
  const GLOBALS = Symbol('globals');

  // used in both Canvas and Document to provide images
  const IMAGE = Symbol('image');

  // used to define Document mime type
  const MIME = Symbol('mime');

  // used in Document to attach once MutationObserver
  const MUTATION_OBSERVER = Symbol('MutationObserver');

  // used to define next node reference
  const NEXT = Symbol('next');

  // used to define Attr owner elements
  const OWNER_ELEMENT = Symbol('ownerElement');

  // used to define previous node reference
  const PREV = Symbol('prev');

  // used to define various "private" properties
  const PRIVATE = Symbol('private');

  // used to define the CSSStyleSheet.sheet
  const SHEET = Symbol('sheet');

  // used to define start node reference
  const START = Symbol('start');

  // used to define special CSS style attribute
  const STYLE = Symbol('style');

  // used to upgrade Custom Elements
  const UPGRADE = Symbol('upgrade');

  // used to define generic values
  const VALUE = Symbol('value');

  // Generated using scripts/write-decode-map.ts
  const htmlDecodeTree = /* #__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* #__PURE__ */ "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Generated using scripts/write-decode-map.ts
  const xmlDecodeTree = /* #__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* #__PURE__ */ "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
  var _a;
  const decodeMap = new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
  ]);
  /**
   * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
   */
  const fromCodePoint = 
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
      let output = "";
      if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
          codePoint = 56320 | (codePoint & 1023);
      }
      output += String.fromCharCode(codePoint);
      return output;
  };
  /**
   * Replace the given code point with a replacement character if it is a
   * surrogate or is outside the valid range. Otherwise return the code
   * point unchanged.
   */
  function replaceCodePoint(codePoint) {
      var _a;
      if ((codePoint >= 55296 && codePoint <= 57343) ||
          codePoint > 1114111) {
          return 65533;
      }
      return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
  }

  var CharCodes$1;
  (function (CharCodes) {
      CharCodes[CharCodes["NUM"] = 35] = "NUM";
      CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
      CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
      CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
      CharCodes[CharCodes["NINE"] = 57] = "NINE";
      CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
      CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
      CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
      CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
      CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
      CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes$1 || (CharCodes$1 = {}));
  /** Bit that needs to be set to convert an upper case ASCII character to lower case */
  const TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function (BinTrieFlags) {
      BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber(code) {
      return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
  }
  function isHexadecimalCharacter(code) {
      return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F) ||
          (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F));
  }
  function isAsciiAlphaNumeric(code) {
      return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z) ||
          (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z) ||
          isNumber(code));
  }
  /**
   * Checks if the given character is a valid end character for an entity in an attribute.
   *
   * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
   * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
   */
  function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function (EntityDecoderState) {
      EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function (DecodingMode) {
      /** Entities in text nodes that can end with any character. */
      DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
      /** Only allow entities terminated with a semicolon. */
      DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
      /** Entities in attributes have limitations on ending characters. */
      DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  /**
   * Token decoder with support of writing partial entities.
   */
  class EntityDecoder {
      constructor(
      /** The tree used to decode entities. */
      decodeTree, 
      /**
       * The function that is called when a codepoint is decoded.
       *
       * For multi-byte named entities, this will be called multiple times,
       * with the second codepoint, and the same `consumed` value.
       *
       * @param codepoint The decoded codepoint.
       * @param consumed The number of bytes consumed by the decoder.
       */
      emitCodePoint, 
      /** An object that is used to produce errors. */
      errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          /** The current state of the decoder. */
          this.state = EntityDecoderState.EntityStart;
          /** Characters that were consumed while parsing an entity. */
          this.consumed = 1;
          /**
           * The result of the entity.
           *
           * Either the result index of a numeric entity, or the codepoint of a
           * numeric entity.
           */
          this.result = 0;
          /** The current index in the decode tree. */
          this.treeIndex = 0;
          /** The number of characters that were consumed in excess. */
          this.excess = 1;
          /** The mode in which the decoder is operating. */
          this.decodeMode = DecodingMode.Strict;
      }
      /** Resets the instance to make it reusable. */
      startEntity(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
      }
      /**
       * Write an entity to the decoder. This can be called multiple times with partial entities.
       * If the entity is incomplete, the decoder will return -1.
       *
       * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
       * entity is incomplete, and resume when the next string is written.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      write(input, offset) {
          switch (this.state) {
              case EntityDecoderState.EntityStart: {
                  if (input.charCodeAt(offset) === CharCodes$1.NUM) {
                      this.state = EntityDecoderState.NumericStart;
                      this.consumed += 1;
                      return this.stateNumericStart(input, offset + 1);
                  }
                  this.state = EntityDecoderState.NamedEntity;
                  return this.stateNamedEntity(input, offset);
              }
              case EntityDecoderState.NumericStart: {
                  return this.stateNumericStart(input, offset);
              }
              case EntityDecoderState.NumericDecimal: {
                  return this.stateNumericDecimal(input, offset);
              }
              case EntityDecoderState.NumericHex: {
                  return this.stateNumericHex(input, offset);
              }
              case EntityDecoderState.NamedEntity: {
                  return this.stateNamedEntity(input, offset);
              }
          }
      }
      /**
       * Switches between the numeric decimal and hexadecimal states.
       *
       * Equivalent to the `Numeric character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericStart(input, offset) {
          if (offset >= input.length) {
              return -1;
          }
          if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
              this.state = EntityDecoderState.NumericHex;
              this.consumed += 1;
              return this.stateNumericHex(input, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(input, offset);
      }
      addToNumericResult(input, start, end, base) {
          if (start !== end) {
              const digitCount = end - start;
              this.result =
                  this.result * Math.pow(base, digitCount) +
                      Number.parseInt(input.substr(start, digitCount), base);
              this.consumed += digitCount;
          }
      }
      /**
       * Parses a hexadecimal numeric entity.
       *
       * Equivalent to the `Hexademical character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericHex(input, offset) {
          const startIndex = offset;
          while (offset < input.length) {
              const char = input.charCodeAt(offset);
              if (isNumber(char) || isHexadecimalCharacter(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(input, startIndex, offset, 16);
                  return this.emitNumericEntity(char, 3);
              }
          }
          this.addToNumericResult(input, startIndex, offset, 16);
          return -1;
      }
      /**
       * Parses a decimal numeric entity.
       *
       * Equivalent to the `Decimal character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericDecimal(input, offset) {
          const startIndex = offset;
          while (offset < input.length) {
              const char = input.charCodeAt(offset);
              if (isNumber(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(input, startIndex, offset, 10);
                  return this.emitNumericEntity(char, 2);
              }
          }
          this.addToNumericResult(input, startIndex, offset, 10);
          return -1;
      }
      /**
       * Validate and emit a numeric entity.
       *
       * Implements the logic from the `Hexademical character reference start
       * state` and `Numeric character reference end state` in the HTML spec.
       *
       * @param lastCp The last code point of the entity. Used to see if the
       *               entity was terminated with a semicolon.
       * @param expectedLength The minimum number of characters that should be
       *                       consumed. Used to validate that at least one digit
       *                       was consumed.
       * @returns The number of characters that were consumed.
       */
      emitNumericEntity(lastCp, expectedLength) {
          var _a;
          // Ensure we consumed at least one digit.
          if (this.consumed <= expectedLength) {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
          }
          // Figure out if this is a legit end of the entity
          if (lastCp === CharCodes$1.SEMI) {
              this.consumed += 1;
          }
          else if (this.decodeMode === DecodingMode.Strict) {
              return 0;
          }
          this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
          if (this.errors) {
              if (lastCp !== CharCodes$1.SEMI) {
                  this.errors.missingSemicolonAfterCharacterReference();
              }
              this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
      }
      /**
       * Parses a named entity.
       *
       * Equivalent to the `Named character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNamedEntity(input, offset) {
          const { decodeTree } = this;
          let current = decodeTree[this.treeIndex];
          // The mask is the number of bytes of the value, including the current byte.
          let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < input.length; offset++, this.excess++) {
              const char = input.charCodeAt(offset);
              this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
              if (this.treeIndex < 0) {
                  return this.result === 0 ||
                      // If we are parsing an attribute
                      (this.decodeMode === DecodingMode.Attribute &&
                          // We shouldn't have consumed any characters after the entity,
                          (valueLength === 0 ||
                              // And there should be no invalid characters.
                              isEntityInAttributeInvalidEnd(char)))
                      ? 0
                      : this.emitNotTerminatedNamedEntity();
              }
              current = decodeTree[this.treeIndex];
              valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
              // If the branch is a value, store it and continue
              if (valueLength !== 0) {
                  // If the entity is terminated by a semicolon, we are done.
                  if (char === CharCodes$1.SEMI) {
                      return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                  }
                  // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                  if (this.decodeMode !== DecodingMode.Strict) {
                      this.result = this.treeIndex;
                      this.consumed += this.excess;
                      this.excess = 0;
                  }
              }
          }
          return -1;
      }
      /**
       * Emit a named entity that was not terminated with a semicolon.
       *
       * @returns The number of characters consumed.
       */
      emitNotTerminatedNamedEntity() {
          var _a;
          const { result, decodeTree } = this;
          const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
      }
      /**
       * Emit a named entity.
       *
       * @param result The index of the entity in the decode tree.
       * @param valueLength The number of bytes in the entity.
       * @param consumed The number of characters consumed.
       *
       * @returns The number of characters consumed.
       */
      emitNamedEntityData(result, valueLength, consumed) {
          const { decodeTree } = this;
          this.emitCodePoint(valueLength === 1
              ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
              : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
              // For multi-byte values, we need to emit the second byte.
              this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
      }
      /**
       * Signal to the parser that the end of the input was reached.
       *
       * Remaining data will be emitted and relevant errors will be produced.
       *
       * @returns The number of characters consumed.
       */
      end() {
          var _a;
          switch (this.state) {
              case EntityDecoderState.NamedEntity: {
                  // Emit a named entity if we have one.
                  return this.result !== 0 &&
                      (this.decodeMode !== DecodingMode.Attribute ||
                          this.result === this.treeIndex)
                      ? this.emitNotTerminatedNamedEntity()
                      : 0;
              }
              // Otherwise, emit a numeric entity if we have one.
              case EntityDecoderState.NumericDecimal: {
                  return this.emitNumericEntity(0, 2);
              }
              case EntityDecoderState.NumericHex: {
                  return this.emitNumericEntity(0, 3);
              }
              case EntityDecoderState.NumericStart: {
                  (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                  return 0;
              }
              case EntityDecoderState.EntityStart: {
                  // Return 0 if we have no entity.
                  return 0;
              }
          }
      }
  }
  /**
   * Determines the branch of the current node that is taken given the current
   * character. This function is used to traverse the trie.
   *
   * @param decodeTree The trie.
   * @param current The current node.
   * @param nodeIdx The index right after the current node and its value.
   * @param char The current character.
   * @returns The index of the next node, or -1 if no branch is taken.
   */
  function determineBranch(decodeTree, current, nodeIndex, char) {
      const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      // Case 1: Single branch encoded in jump offset
      if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
      }
      // Case 2: Multiple branches encoded in jump table
      if (jumpOffset) {
          const value = char - jumpOffset;
          return value < 0 || value >= branchCount
              ? -1
              : decodeTree[nodeIndex + value] - 1;
      }
      // Case 3: Multiple branches encoded in dictionary
      // Binary search for the character.
      let lo = nodeIndex;
      let hi = lo + branchCount - 1;
      while (lo <= hi) {
          const mid = (lo + hi) >>> 1;
          const midValue = decodeTree[mid];
          if (midValue < char) {
              lo = mid + 1;
          }
          else if (midValue > char) {
              hi = mid - 1;
          }
          else {
              return decodeTree[mid + branchCount];
          }
      }
      return -1;
  }

  var CharCodes;
  (function (CharCodes) {
      CharCodes[CharCodes["Tab"] = 9] = "Tab";
      CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
      CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
      CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes[CharCodes["Space"] = 32] = "Space";
      CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes[CharCodes["Number"] = 35] = "Number";
      CharCodes[CharCodes["Amp"] = 38] = "Amp";
      CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
      CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes[CharCodes["Dash"] = 45] = "Dash";
      CharCodes[CharCodes["Slash"] = 47] = "Slash";
      CharCodes[CharCodes["Zero"] = 48] = "Zero";
      CharCodes[CharCodes["Nine"] = 57] = "Nine";
      CharCodes[CharCodes["Semi"] = 59] = "Semi";
      CharCodes[CharCodes["Lt"] = 60] = "Lt";
      CharCodes[CharCodes["Eq"] = 61] = "Eq";
      CharCodes[CharCodes["Gt"] = 62] = "Gt";
      CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
      CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
      CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
      CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
      CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
      CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
      CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
      CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
      CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  /** All the states the tokenizer can be in. */
  var State;
  (function (State) {
      State[State["Text"] = 1] = "Text";
      State[State["BeforeTagName"] = 2] = "BeforeTagName";
      State[State["InTagName"] = 3] = "InTagName";
      State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State[State["InClosingTagName"] = 6] = "InClosingTagName";
      State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      // Attributes
      State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State[State["InAttributeName"] = 9] = "InAttributeName";
      State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
      State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      // Declarations
      State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State[State["InDeclaration"] = 16] = "InDeclaration";
      // Processing instructions
      State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      // Comments & CDATA
      State[State["BeforeComment"] = 18] = "BeforeComment";
      State[State["CDATASequence"] = 19] = "CDATASequence";
      State[State["InSpecialComment"] = 20] = "InSpecialComment";
      State[State["InCommentLike"] = 21] = "InCommentLike";
      // Special tags
      State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State[State["BeforeSpecialT"] = 23] = "BeforeSpecialT";
      State[State["SpecialStartSequence"] = 24] = "SpecialStartSequence";
      State[State["InSpecialTag"] = 25] = "InSpecialTag";
      State[State["InEntity"] = 26] = "InEntity";
  })(State || (State = {}));
  function isWhitespace$1(c) {
      return (c === CharCodes.Space ||
          c === CharCodes.NewLine ||
          c === CharCodes.Tab ||
          c === CharCodes.FormFeed ||
          c === CharCodes.CarriageReturn);
  }
  function isEndOfTagSection(c) {
      return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace$1(c);
  }
  function isASCIIAlpha(c) {
      return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
          (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
  }
  var QuoteType;
  (function (QuoteType) {
      QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
      QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
      QuoteType[QuoteType["Single"] = 2] = "Single";
      QuoteType[QuoteType["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  /**
   * Sequences used to match longer strings.
   *
   * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
   * sequences with an increased offset.
   */
  const Sequences = {
      Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[
      CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>
      CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`
      ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`
      StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`
      TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
      TextareaEnd: new Uint8Array([
          0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,
      ]), // `</textarea`
      XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`
  };
  class Tokenizer {
      constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
          this.cbs = cbs;
          /** The current state the tokenizer is in. */
          this.state = State.Text;
          /** The read buffer. */
          this.buffer = "";
          /** The beginning of the section that is currently being read. */
          this.sectionStart = 0;
          /** The index within the buffer that we are currently looking at. */
          this.index = 0;
          /** The start of the last entity. */
          this.entityStart = 0;
          /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
          this.baseState = State.Text;
          /** For special parsing behavior inside of script and style tags. */
          this.isSpecial = false;
          /** Indicates whether the tokenizer has been paused. */
          this.running = true;
          /** The offset of the current buffer. */
          this.offset = 0;
          this.currentSequence = undefined;
          this.sequenceIndex = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
      }
      reset() {
          this.state = State.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State.Text;
          this.currentSequence = undefined;
          this.running = true;
          this.offset = 0;
      }
      write(chunk) {
          this.offset += this.buffer.length;
          this.buffer = chunk;
          this.parse();
      }
      end() {
          if (this.running)
              this.finish();
      }
      pause() {
          this.running = false;
      }
      resume() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
              this.parse();
          }
      }
      stateText(c) {
          if (c === CharCodes.Lt ||
              (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
              if (this.index > this.sectionStart) {
                  this.cbs.ontext(this.sectionStart, this.index);
              }
              this.state = State.BeforeTagName;
              this.sectionStart = this.index;
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateSpecialStartSequence(c) {
          const isEnd = this.sequenceIndex === this.currentSequence.length;
          const isMatch = isEnd
              ? // If we are at the end of the sequence, make sure the tag name has ended
                  isEndOfTagSection(c)
              : // Otherwise, do a case-insensitive comparison
                  (c | 0x20) === this.currentSequence[this.sequenceIndex];
          if (!isMatch) {
              this.isSpecial = false;
          }
          else if (!isEnd) {
              this.sequenceIndex++;
              return;
          }
          this.sequenceIndex = 0;
          this.state = State.InTagName;
          this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> tags, also decode entities. */
      stateInSpecialTag(c) {
          if (this.sequenceIndex === this.currentSequence.length) {
              if (c === CharCodes.Gt || isWhitespace$1(c)) {
                  const endOfText = this.index - this.currentSequence.length;
                  if (this.sectionStart < endOfText) {
                      // Spoof the index so that reported locations match up.
                      const actualIndex = this.index;
                      this.index = endOfText;
                      this.cbs.ontext(this.sectionStart, endOfText);
                      this.index = actualIndex;
                  }
                  this.isSpecial = false;
                  this.sectionStart = endOfText + 2; // Skip over the `</`
                  this.stateInClosingTagName(c);
                  return; // We are done; skip the rest of the function.
              }
              this.sequenceIndex = 0;
          }
          if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
              this.sequenceIndex += 1;
          }
          else if (this.sequenceIndex === 0) {
              if (this.currentSequence === Sequences.TitleEnd) {
                  // We have to parse entities in <title> tags.
                  if (this.decodeEntities && c === CharCodes.Amp) {
                      this.startEntity();
                  }
              }
              else if (this.fastForwardTo(CharCodes.Lt)) {
                  // Outside of <title> tags, we can fast-forward.
                  this.sequenceIndex = 1;
              }
          }
          else {
              // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
              this.sequenceIndex = Number(c === CharCodes.Lt);
          }
      }
      stateCDATASequence(c) {
          if (c === Sequences.Cdata[this.sequenceIndex]) {
              if (++this.sequenceIndex === Sequences.Cdata.length) {
                  this.state = State.InCommentLike;
                  this.currentSequence = Sequences.CdataEnd;
                  this.sequenceIndex = 0;
                  this.sectionStart = this.index + 1;
              }
          }
          else {
              this.sequenceIndex = 0;
              this.state = State.InDeclaration;
              this.stateInDeclaration(c); // Reconsume the character
          }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
          while (++this.index < this.buffer.length + this.offset) {
              if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                  return true;
              }
          }
          /*
           * We increment the index at the end of the `parse` loop,
           * so set it to `buffer.length - 1` here.
           *
           * TODO: Refactor `parse` to increment index before calling states.
           */
          this.index = this.buffer.length + this.offset - 1;
          return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
          if (c === this.currentSequence[this.sequenceIndex]) {
              if (++this.sequenceIndex === this.currentSequence.length) {
                  if (this.currentSequence === Sequences.CdataEnd) {
                      this.cbs.oncdata(this.sectionStart, this.index, 2);
                  }
                  else {
                      this.cbs.oncomment(this.sectionStart, this.index, 2);
                  }
                  this.sequenceIndex = 0;
                  this.sectionStart = this.index + 1;
                  this.state = State.Text;
              }
          }
          else if (this.sequenceIndex === 0) {
              // Fast-forward to the first character of the sequence
              if (this.fastForwardTo(this.currentSequence[0])) {
                  this.sequenceIndex = 1;
              }
          }
          else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
              // Allow long sequences, eg. --->, ]]]>
              this.sequenceIndex = 0;
          }
      }
      /**
       * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
       *
       * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
       * We allow anything that wouldn't end the tag.
       */
      isTagStartChar(c) {
          return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
      }
      startSpecial(sequence, offset) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset;
          this.state = State.SpecialStartSequence;
      }
      stateBeforeTagName(c) {
          if (c === CharCodes.ExclamationMark) {
              this.state = State.BeforeDeclaration;
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.Questionmark) {
              this.state = State.InProcessingInstruction;
              this.sectionStart = this.index + 1;
          }
          else if (this.isTagStartChar(c)) {
              const lower = c | 0x20;
              this.sectionStart = this.index;
              if (this.xmlMode) {
                  this.state = State.InTagName;
              }
              else if (lower === Sequences.ScriptEnd[2]) {
                  this.state = State.BeforeSpecialS;
              }
              else if (lower === Sequences.TitleEnd[2] ||
                  lower === Sequences.XmpEnd[2]) {
                  this.state = State.BeforeSpecialT;
              }
              else {
                  this.state = State.InTagName;
              }
          }
          else if (c === CharCodes.Slash) {
              this.state = State.BeforeClosingTagName;
          }
          else {
              this.state = State.Text;
              this.stateText(c);
          }
      }
      stateInTagName(c) {
          if (isEndOfTagSection(c)) {
              this.cbs.onopentagname(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
      }
      stateBeforeClosingTagName(c) {
          if (isWhitespace$1(c)) ;
          else if (c === CharCodes.Gt) {
              this.state = State.Text;
          }
          else {
              this.state = this.isTagStartChar(c)
                  ? State.InClosingTagName
                  : State.InSpecialComment;
              this.sectionStart = this.index;
          }
      }
      stateInClosingTagName(c) {
          if (c === CharCodes.Gt || isWhitespace$1(c)) {
              this.cbs.onclosetag(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.AfterClosingTagName;
              this.stateAfterClosingTagName(c);
          }
      }
      stateAfterClosingTagName(c) {
          // Skip everything until ">"
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeAttributeName(c) {
          if (c === CharCodes.Gt) {
              this.cbs.onopentagend(this.index);
              if (this.isSpecial) {
                  this.state = State.InSpecialTag;
                  this.sequenceIndex = 0;
              }
              else {
                  this.state = State.Text;
              }
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.Slash) {
              this.state = State.InSelfClosingTag;
          }
          else if (!isWhitespace$1(c)) {
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
          }
      }
      stateInSelfClosingTag(c) {
          if (c === CharCodes.Gt) {
              this.cbs.onselfclosingtag(this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
              this.isSpecial = false; // Reset special state, in case of self-closing special tags
          }
          else if (!isWhitespace$1(c)) {
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
      }
      stateInAttributeName(c) {
          if (c === CharCodes.Eq || isEndOfTagSection(c)) {
              this.cbs.onattribname(this.sectionStart, this.index);
              this.sectionStart = this.index;
              this.state = State.AfterAttributeName;
              this.stateAfterAttributeName(c);
          }
      }
      stateAfterAttributeName(c) {
          if (c === CharCodes.Eq) {
              this.state = State.BeforeAttributeValue;
          }
          else if (c === CharCodes.Slash || c === CharCodes.Gt) {
              this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
              this.sectionStart = -1;
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
          else if (!isWhitespace$1(c)) {
              this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
          }
      }
      stateBeforeAttributeValue(c) {
          if (c === CharCodes.DoubleQuote) {
              this.state = State.InAttributeValueDq;
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.SingleQuote) {
              this.state = State.InAttributeValueSq;
              this.sectionStart = this.index + 1;
          }
          else if (!isWhitespace$1(c)) {
              this.sectionStart = this.index;
              this.state = State.InAttributeValueNq;
              this.stateInAttributeValueNoQuotes(c); // Reconsume token
          }
      }
      handleInAttributeValue(c, quote) {
          if (c === quote ||
              (!this.decodeEntities && this.fastForwardTo(quote))) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(quote === CharCodes.DoubleQuote
                  ? QuoteType.Double
                  : QuoteType.Single, this.index + 1);
              this.state = State.BeforeAttributeName;
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateInAttributeValueDoubleQuotes(c) {
          this.handleInAttributeValue(c, CharCodes.DoubleQuote);
      }
      stateInAttributeValueSingleQuotes(c) {
          this.handleInAttributeValue(c, CharCodes.SingleQuote);
      }
      stateInAttributeValueNoQuotes(c) {
          if (isWhitespace$1(c) || c === CharCodes.Gt) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(QuoteType.Unquoted, this.index);
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateBeforeDeclaration(c) {
          if (c === CharCodes.OpeningSquareBracket) {
              this.state = State.CDATASequence;
              this.sequenceIndex = 0;
          }
          else {
              this.state =
                  c === CharCodes.Dash
                      ? State.BeforeComment
                      : State.InDeclaration;
          }
      }
      stateInDeclaration(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.ondeclaration(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateInProcessingInstruction(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.onprocessinginstruction(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeComment(c) {
          if (c === CharCodes.Dash) {
              this.state = State.InCommentLike;
              this.currentSequence = Sequences.CommentEnd;
              // Allow short comments (eg. <!-->)
              this.sequenceIndex = 2;
              this.sectionStart = this.index + 1;
          }
          else {
              this.state = State.InDeclaration;
          }
      }
      stateInSpecialComment(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.oncomment(this.sectionStart, this.index, 0);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeSpecialS(c) {
          const lower = c | 0x20;
          if (lower === Sequences.ScriptEnd[3]) {
              this.startSpecial(Sequences.ScriptEnd, 4);
          }
          else if (lower === Sequences.StyleEnd[3]) {
              this.startSpecial(Sequences.StyleEnd, 4);
          }
          else {
              this.state = State.InTagName;
              this.stateInTagName(c); // Consume the token again
          }
      }
      stateBeforeSpecialT(c) {
          const lower = c | 0x20;
          switch (lower) {
              case Sequences.TitleEnd[3]: {
                  this.startSpecial(Sequences.TitleEnd, 4);
                  break;
              }
              case Sequences.TextareaEnd[3]: {
                  this.startSpecial(Sequences.TextareaEnd, 4);
                  break;
              }
              case Sequences.XmpEnd[3]: {
                  this.startSpecial(Sequences.XmpEnd, 4);
                  break;
              }
              default: {
                  this.state = State.InTagName;
                  this.stateInTagName(c); // Consume the token again
              }
          }
      }
      startEntity() {
          this.baseState = this.state;
          this.state = State.InEntity;
          this.entityStart = this.index;
          this.entityDecoder.startEntity(this.xmlMode
              ? DecodingMode.Strict
              : this.baseState === State.Text ||
                  this.baseState === State.InSpecialTag
                  ? DecodingMode.Legacy
                  : DecodingMode.Attribute);
      }
      stateInEntity() {
          const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
          // If `length` is positive, we are done with the entity.
          if (length >= 0) {
              this.state = this.baseState;
              if (length === 0) {
                  this.index = this.entityStart;
              }
          }
          else {
              // Mark buffer as consumed.
              this.index = this.offset + this.buffer.length - 1;
          }
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
          // If we are inside of text or attributes, emit what we already have.
          if (this.running && this.sectionStart !== this.index) {
              if (this.state === State.Text ||
                  (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                  this.cbs.ontext(this.sectionStart, this.index);
                  this.sectionStart = this.index;
              }
              else if (this.state === State.InAttributeValueDq ||
                  this.state === State.InAttributeValueSq ||
                  this.state === State.InAttributeValueNq) {
                  this.cbs.onattribdata(this.sectionStart, this.index);
                  this.sectionStart = this.index;
              }
          }
      }
      shouldContinue() {
          return this.index < this.buffer.length + this.offset && this.running;
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse() {
          while (this.shouldContinue()) {
              const c = this.buffer.charCodeAt(this.index - this.offset);
              switch (this.state) {
                  case State.Text: {
                      this.stateText(c);
                      break;
                  }
                  case State.SpecialStartSequence: {
                      this.stateSpecialStartSequence(c);
                      break;
                  }
                  case State.InSpecialTag: {
                      this.stateInSpecialTag(c);
                      break;
                  }
                  case State.CDATASequence: {
                      this.stateCDATASequence(c);
                      break;
                  }
                  case State.InAttributeValueDq: {
                      this.stateInAttributeValueDoubleQuotes(c);
                      break;
                  }
                  case State.InAttributeName: {
                      this.stateInAttributeName(c);
                      break;
                  }
                  case State.InCommentLike: {
                      this.stateInCommentLike(c);
                      break;
                  }
                  case State.InSpecialComment: {
                      this.stateInSpecialComment(c);
                      break;
                  }
                  case State.BeforeAttributeName: {
                      this.stateBeforeAttributeName(c);
                      break;
                  }
                  case State.InTagName: {
                      this.stateInTagName(c);
                      break;
                  }
                  case State.InClosingTagName: {
                      this.stateInClosingTagName(c);
                      break;
                  }
                  case State.BeforeTagName: {
                      this.stateBeforeTagName(c);
                      break;
                  }
                  case State.AfterAttributeName: {
                      this.stateAfterAttributeName(c);
                      break;
                  }
                  case State.InAttributeValueSq: {
                      this.stateInAttributeValueSingleQuotes(c);
                      break;
                  }
                  case State.BeforeAttributeValue: {
                      this.stateBeforeAttributeValue(c);
                      break;
                  }
                  case State.BeforeClosingTagName: {
                      this.stateBeforeClosingTagName(c);
                      break;
                  }
                  case State.AfterClosingTagName: {
                      this.stateAfterClosingTagName(c);
                      break;
                  }
                  case State.BeforeSpecialS: {
                      this.stateBeforeSpecialS(c);
                      break;
                  }
                  case State.BeforeSpecialT: {
                      this.stateBeforeSpecialT(c);
                      break;
                  }
                  case State.InAttributeValueNq: {
                      this.stateInAttributeValueNoQuotes(c);
                      break;
                  }
                  case State.InSelfClosingTag: {
                      this.stateInSelfClosingTag(c);
                      break;
                  }
                  case State.InDeclaration: {
                      this.stateInDeclaration(c);
                      break;
                  }
                  case State.BeforeDeclaration: {
                      this.stateBeforeDeclaration(c);
                      break;
                  }
                  case State.BeforeComment: {
                      this.stateBeforeComment(c);
                      break;
                  }
                  case State.InProcessingInstruction: {
                      this.stateInProcessingInstruction(c);
                      break;
                  }
                  case State.InEntity: {
                      this.stateInEntity();
                      break;
                  }
              }
              this.index++;
          }
          this.cleanup();
      }
      finish() {
          if (this.state === State.InEntity) {
              this.entityDecoder.end();
              this.state = this.baseState;
          }
          this.handleTrailingData();
          this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
          const endIndex = this.buffer.length + this.offset;
          // If there is no remaining data, we are done.
          if (this.sectionStart >= endIndex) {
              return;
          }
          if (this.state === State.InCommentLike) {
              if (this.currentSequence === Sequences.CdataEnd) {
                  this.cbs.oncdata(this.sectionStart, endIndex, 0);
              }
              else {
                  this.cbs.oncomment(this.sectionStart, endIndex, 0);
              }
          }
          else if (this.state === State.InTagName ||
              this.state === State.BeforeAttributeName ||
              this.state === State.BeforeAttributeValue ||
              this.state === State.AfterAttributeName ||
              this.state === State.InAttributeName ||
              this.state === State.InAttributeValueSq ||
              this.state === State.InAttributeValueDq ||
              this.state === State.InAttributeValueNq ||
              this.state === State.InClosingTagName) ;
          else {
              this.cbs.ontext(this.sectionStart, endIndex);
          }
      }
      emitCodePoint(cp, consumed) {
          if (this.baseState !== State.Text &&
              this.baseState !== State.InSpecialTag) {
              if (this.sectionStart < this.entityStart) {
                  this.cbs.onattribdata(this.sectionStart, this.entityStart);
              }
              this.sectionStart = this.entityStart + consumed;
              this.index = this.sectionStart - 1;
              this.cbs.onattribentity(cp);
          }
          else {
              if (this.sectionStart < this.entityStart) {
                  this.cbs.ontext(this.sectionStart, this.entityStart);
              }
              this.sectionStart = this.entityStart + consumed;
              this.index = this.sectionStart - 1;
              this.cbs.ontextentity(cp, this.sectionStart);
          }
      }
  }

  const formTags = new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea",
  ]);
  const pTag = new Set(["p"]);
  const tableSectionTags = new Set(["thead", "tbody"]);
  const ddtTags = new Set(["dd", "dt"]);
  const rtpTags = new Set(["rt", "rp"]);
  const openImpliesClose = new Map([
      ["tr", new Set(["tr", "th", "td"])],
      ["th", new Set(["th"])],
      ["td", new Set(["thead", "th", "td"])],
      ["body", new Set(["head", "link", "script"])],
      ["li", new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", new Set(["option"])],
      ["optgroup", new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags],
  ]);
  const voidElements$1 = new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
  ]);
  const foreignContextElements = new Set(["math", "svg"]);
  const htmlIntegrationElements = new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title",
  ]);
  const reNameEnd = /\s|\//;
  let Parser$2 = class Parser {
      constructor(cbs, options = {}) {
          var _a, _b, _c, _d, _e, _f;
          this.options = options;
          /** The start index of the last event. */
          this.startIndex = 0;
          /** The end index of the last event. */
          this.endIndex = 0;
          /**
           * Store the start index of the current open tag,
           * so we can update the start index for attributes.
           */
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.buffers = [];
          this.bufferOffset = 0;
          /** The index of the last written buffer. Used when resuming after a `pause()`. */
          this.writeIndex = 0;
          /** Indicates whether the parser has finished running / `.end` has been called. */
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.htmlMode = !this.options.xmlMode;
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;
          this.lowerCaseAttributeNames =
              (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
          this.recognizeSelfClosing =
              (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
          this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
          this.foreignContext = [!this.htmlMode];
          (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
      }
      // Tokenizer event handlers
      /** @internal */
      ontext(start, endIndex) {
          var _a, _b;
          const data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
      }
      /** @internal */
      ontextentity(cp, endIndex) {
          var _a, _b;
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));
          this.startIndex = endIndex;
      }
      /**
       * Checks if the current tag is a void element. Override this if you want
       * to specify your own additional void elements.
       */
      isVoidElement(name) {
          return this.htmlMode && voidElements$1.has(name);
      }
      /** @internal */
      onopentagname(start, endIndex) {
          this.endIndex = endIndex;
          let name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          this.emitOpenTag(name);
      }
      emitOpenTag(name) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          const impliesClose = this.htmlMode && openImpliesClose.get(name);
          if (impliesClose) {
              while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
                  const element = this.stack.shift();
                  (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
              }
          }
          if (!this.isVoidElement(name)) {
              this.stack.unshift(name);
              if (this.htmlMode) {
                  if (foreignContextElements.has(name)) {
                      this.foreignContext.unshift(true);
                  }
                  else if (htmlIntegrationElements.has(name)) {
                      this.foreignContext.unshift(false);
                  }
              }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
              this.attribs = {};
      }
      endOpenTag(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
              (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
              this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
              this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
      }
      /** @internal */
      onopentagend(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onclosetag(start, endIndex) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          this.endIndex = endIndex;
          let name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          if (this.htmlMode &&
              (foreignContextElements.has(name) ||
                  htmlIntegrationElements.has(name))) {
              this.foreignContext.shift();
          }
          if (!this.isVoidElement(name)) {
              const pos = this.stack.indexOf(name);
              if (pos !== -1) {
                  for (let index = 0; index <= pos; index++) {
                      const element = this.stack.shift();
                      // We know the stack has sufficient elements.
                      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);
                  }
              }
              else if (this.htmlMode && name === "p") {
                  // Implicit open before close
                  this.emitOpenTag("p");
                  this.closeCurrentTag(true);
              }
          }
          else if (this.htmlMode && name === "br") {
              // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
              (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
              (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
              (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onselfclosingtag(endIndex) {
          this.endIndex = endIndex;
          if (this.recognizeSelfClosing || this.foreignContext[0]) {
              this.closeCurrentTag(false);
              // Set `startIndex` for next node
              this.startIndex = endIndex + 1;
          }
          else {
              // Ignore the fact that the tag is self-closing.
              this.onopentagend(endIndex);
          }
      }
      closeCurrentTag(isOpenImplied) {
          var _a, _b;
          const name = this.tagname;
          this.endOpenTag(isOpenImplied);
          // Self-closing tags will be on the top of the stack
          if (this.stack[0] === name) {
              // If the opening tag isn't implied, the closing tag has to be implied.
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
              this.stack.shift();
          }
      }
      /** @internal */
      onattribname(start, endIndex) {
          this.startIndex = start;
          const name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames
              ? name.toLowerCase()
              : name;
      }
      /** @internal */
      onattribdata(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
      }
      /** @internal */
      onattribentity(cp) {
          this.attribvalue += fromCodePoint(cp);
      }
      /** @internal */
      onattribend(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double
              ? '"'
              : quote === QuoteType.Single
                  ? "'"
                  : quote === QuoteType.NoValue
                      ? undefined
                      : null);
          if (this.attribs &&
              !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
              this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
      }
      getInstructionName(value) {
          const index = value.search(reNameEnd);
          let name = index < 0 ? value : value.substr(0, index);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          return name;
      }
      /** @internal */
      ondeclaration(start, endIndex) {
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
              const name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onprocessinginstruction(start, endIndex) {
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
              const name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      oncomment(start, endIndex, offset) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      oncdata(start, endIndex, offset) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex - offset);
          if (!this.htmlMode || this.options.recognizeCDATA) {
              (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
              (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
              (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          }
          else {
              (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
              (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onend() {
          var _a, _b;
          if (this.cbs.onclosetag) {
              // Set the end index for all remaining tags
              this.endIndex = this.startIndex;
              for (let index = 0; index < this.stack.length; index++) {
                  this.cbs.onclosetag(this.stack[index], true);
              }
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * Resets the parser to a blank state, ready to parse a new HTML document
       */
      reset() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.foreignContext.length = 0;
          this.foreignContext.unshift(!this.htmlMode);
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
      }
      /**
       * Resets the parser, then parses a complete document and
       * pushes it to the handler.
       *
       * @param data Document to parse.
       */
      parseComplete(data) {
          this.reset();
          this.end(data);
      }
      getSlice(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
              this.shiftBuffer();
          }
          let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
              this.shiftBuffer();
              slice += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice;
      }
      shiftBuffer() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
      }
      /**
       * Parses a chunk of data and calls the corresponding callbacks.
       *
       * @param chunk Chunk to parse.
       */
      write(chunk) {
          var _a, _b;
          if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
              return;
          }
          this.buffers.push(chunk);
          if (this.tokenizer.running) {
              this.tokenizer.write(chunk);
              this.writeIndex++;
          }
      }
      /**
       * Parses the end of the buffer and clears the stack, calls onend.
       *
       * @param chunk Optional final chunk to parse.
       */
      end(chunk) {
          var _a, _b;
          if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
              return;
          }
          if (chunk)
              this.write(chunk);
          this.ended = true;
          this.tokenizer.end();
      }
      /**
       * Pauses parsing. The parser won't emit events until `resume` is called.
       */
      pause() {
          this.tokenizer.pause();
      }
      /**
       * Resumes parsing after `pause` was called.
       */
      resume() {
          this.tokenizer.resume();
          while (this.tokenizer.running &&
              this.writeIndex < this.buffers.length) {
              this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
              this.tokenizer.end();
      }
      /**
       * Alias of `write`, for backwards compatibility.
       *
       * @param chunk Chunk to parse.
       * @deprecated
       */
      parseChunk(chunk) {
          this.write(chunk);
      }
      /**
       * Alias of `end`, for backwards compatibility.
       *
       * @param chunk Optional final chunk to parse.
       * @deprecated
       */
      done(chunk) {
          this.end(chunk);
      }
  };

  /** Types of elements found in htmlparser2's DOM */
  var ElementType;
  (function (ElementType) {
      /** Type for the root element of a document */
      ElementType["Root"] = "root";
      /** Type for Text */
      ElementType["Text"] = "text";
      /** Type for <? ... ?> */
      ElementType["Directive"] = "directive";
      /** Type for <!-- ... --> */
      ElementType["Comment"] = "comment";
      /** Type for <script> tags */
      ElementType["Script"] = "script";
      /** Type for <style> tags */
      ElementType["Style"] = "style";
      /** Type for Any tag */
      ElementType["Tag"] = "tag";
      /** Type for <![CDATA[ ... ]]> */
      ElementType["CDATA"] = "cdata";
      /** Type for <!doctype ...> */
      ElementType["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  /**
   * Tests whether an element is a tag or not.
   *
   * @param elem Element to test
   */
  function isTag$2(elem) {
      return (elem.type === ElementType.Tag ||
          elem.type === ElementType.Script ||
          elem.type === ElementType.Style);
  }
  // Exports for backwards compatibility
  /** Type for the root element of a document */
  const Root = ElementType.Root;
  /** Type for Text */
  const Text$3 = ElementType.Text;
  /** Type for <? ... ?> */
  const Directive = ElementType.Directive;
  /** Type for <!-- ... --> */
  const Comment$3 = ElementType.Comment;
  /** Type for <script> tags */
  const Script = ElementType.Script;
  /** Type for <style> tags */
  const Style = ElementType.Style;
  /** Type for Any tag */
  const Tag = ElementType.Tag;
  /** Type for <![CDATA[ ... ]]> */
  const CDATA$1 = ElementType.CDATA;
  /** Type for <!doctype ...> */
  const Doctype = ElementType.Doctype;

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CDATA: CDATA$1,
    Comment: Comment$3,
    Directive: Directive,
    Doctype: Doctype,
    get ElementType () { return ElementType; },
    Root: Root,
    Script: Script,
    Style: Style,
    Tag: Tag,
    Text: Text$3,
    isTag: isTag$2
  });

  /**
   * This object will be used as the prototype for Nodes when creating a
   * DOM-Level-1-compliant structure.
   */
  let Node$2 = class Node {
      constructor() {
          /** Parent of the node */
          this.parent = null;
          /** Previous sibling */
          this.prev = null;
          /** Next sibling */
          this.next = null;
          /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
          this.startIndex = null;
          /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
          this.endIndex = null;
      }
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get parentNode() {
          return this.parent;
      }
      set parentNode(parent) {
          this.parent = parent;
      }
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get previousSibling() {
          return this.prev;
      }
      set previousSibling(prev) {
          this.prev = prev;
      }
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get nextSibling() {
          return this.next;
      }
      set nextSibling(next) {
          this.next = next;
      }
      /**
       * Clone this node, and optionally its children.
       *
       * @param recursive Clone child nodes as well.
       * @returns A clone of the node.
       */
      cloneNode(recursive = false) {
          return cloneNode(this, recursive);
      }
  };
  /**
   * A node that contains some data.
   */
  class DataNode extends Node$2 {
      /**
       * @param data The content of the data node
       */
      constructor(data) {
          super();
          this.data = data;
      }
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get nodeValue() {
          return this.data;
      }
      set nodeValue(data) {
          this.data = data;
      }
  }
  /**
   * Text within the document.
   */
  let Text$2 = class Text extends DataNode {
      constructor() {
          super(...arguments);
          this.type = ElementType.Text;
      }
      get nodeType() {
          return 3;
      }
  };
  /**
   * Comments within the document.
   */
  let Comment$2 = class Comment extends DataNode {
      constructor() {
          super(...arguments);
          this.type = ElementType.Comment;
      }
      get nodeType() {
          return 8;
      }
  };
  /**
   * Processing instructions, including doc types.
   */
  class ProcessingInstruction extends DataNode {
      constructor(name, data) {
          super(data);
          this.name = name;
          this.type = ElementType.Directive;
      }
      get nodeType() {
          return 1;
      }
  }
  /**
   * A `Node` that can have children.
   */
  class NodeWithChildren extends Node$2 {
      /**
       * @param children Children of the node. Only certain node types can have children.
       */
      constructor(children) {
          super();
          this.children = children;
      }
      // Aliases
      /** First child of the node. */
      get firstChild() {
          var _a;
          return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      }
      /** Last child of the node. */
      get lastChild() {
          return this.children.length > 0
              ? this.children[this.children.length - 1]
              : null;
      }
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get childNodes() {
          return this.children;
      }
      set childNodes(children) {
          this.children = children;
      }
  }
  class CDATA extends NodeWithChildren {
      constructor() {
          super(...arguments);
          this.type = ElementType.CDATA;
      }
      get nodeType() {
          return 4;
      }
  }
  /**
   * The root node of the document.
   */
  let Document$2 = class Document extends NodeWithChildren {
      constructor() {
          super(...arguments);
          this.type = ElementType.Root;
      }
      get nodeType() {
          return 9;
      }
  };
  /**
   * An element within the DOM.
   */
  let Element$2 = class Element extends NodeWithChildren {
      /**
       * @param name Name of the tag, eg. `div`, `span`.
       * @param attribs Object mapping attribute names to attribute values.
       * @param children Children of the node.
       */
      constructor(name, attribs, children = [], type = name === "script"
          ? ElementType.Script
          : name === "style"
              ? ElementType.Style
              : ElementType.Tag) {
          super(children);
          this.name = name;
          this.attribs = attribs;
          this.type = type;
      }
      get nodeType() {
          return 1;
      }
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get tagName() {
          return this.name;
      }
      set tagName(name) {
          this.name = name;
      }
      get attributes() {
          return Object.keys(this.attribs).map((name) => {
              var _a, _b;
              return ({
                  name,
                  value: this.attribs[name],
                  namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                  prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
              });
          });
      }
  };
  /**
   * @param node Node to check.
   * @returns `true` if the node is a `Element`, `false` otherwise.
   */
  function isTag$1(node) {
      return isTag$2(node);
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `CDATA`, `false` otherwise.
   */
  function isCDATA(node) {
      return node.type === ElementType.CDATA;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `Text`, `false` otherwise.
   */
  function isText(node) {
      return node.type === ElementType.Text;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `Comment`, `false` otherwise.
   */
  function isComment(node) {
      return node.type === ElementType.Comment;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
   */
  function isDirective(node) {
      return node.type === ElementType.Directive;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
   */
  function isDocument(node) {
      return node.type === ElementType.Root;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has children, `false` otherwise.
   */
  function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
  }
  /**
   * Clone a node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  function cloneNode(node, recursive = false) {
      let result;
      if (isText(node)) {
          result = new Text$2(node.data);
      }
      else if (isComment(node)) {
          result = new Comment$2(node.data);
      }
      else if (isTag$1(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new Element$2(node.name, { ...node.attribs }, children);
          children.forEach((child) => (child.parent = clone));
          if (node.namespace != null) {
              clone.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
              clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
          }
          if (node["x-attribsPrefix"]) {
              clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
          }
          result = clone;
      }
      else if (isCDATA(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new CDATA(children);
          children.forEach((child) => (child.parent = clone));
          result = clone;
      }
      else if (isDocument(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new Document$2(children);
          children.forEach((child) => (child.parent = clone));
          if (node["x-mode"]) {
              clone["x-mode"] = node["x-mode"];
          }
          result = clone;
      }
      else if (isDirective(node)) {
          const instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
              instruction["x-name"] = node["x-name"];
              instruction["x-publicId"] = node["x-publicId"];
              instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
      }
      else {
          throw new Error(`Not implemented yet: ${node.type}`);
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
  }
  function cloneChildren(childs) {
      const children = childs.map((child) => cloneNode(child, true));
      for (let i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
      }
      return children;
  }

  // Default options
  const defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false,
  };
  class DomHandler {
      /**
       * @param callback Called once parsing has completed.
       * @param options Settings for the handler.
       * @param elementCB Callback whenever a tag is closed.
       */
      constructor(callback, options, elementCB) {
          /** The elements of the DOM */
          this.dom = [];
          /** The root element for the DOM */
          this.root = new Document$2(this.dom);
          /** Indicated whether parsing has been completed. */
          this.done = false;
          /** Stack of open tags. */
          this.tagStack = [this.root];
          /** A data node that is still being written to. */
          this.lastNode = null;
          /** Reference to the parser instance. Used for location information. */
          this.parser = null;
          // Make it possible to skip arguments, for backwards-compatibility
          if (typeof options === "function") {
              elementCB = options;
              options = defaultOpts;
          }
          if (typeof callback === "object") {
              options = callback;
              callback = undefined;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      onparserinit(parser) {
          this.parser = parser;
      }
      // Resets the handler back to starting state
      onreset() {
          this.dom = [];
          this.root = new Document$2(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
      }
      // Signals the handler that parsing is done
      onend() {
          if (this.done)
              return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
      }
      onerror(error) {
          this.handleCallback(error);
      }
      onclosetag() {
          this.lastNode = null;
          const elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
              elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
              this.elementCB(elem);
      }
      onopentag(name, attribs) {
          const type = this.options.xmlMode ? ElementType.Tag : undefined;
          const element = new Element$2(name, attribs, undefined, type);
          this.addNode(element);
          this.tagStack.push(element);
      }
      ontext(data) {
          const { lastNode } = this;
          if (lastNode && lastNode.type === ElementType.Text) {
              lastNode.data += data;
              if (this.options.withEndIndices) {
                  lastNode.endIndex = this.parser.endIndex;
              }
          }
          else {
              const node = new Text$2(data);
              this.addNode(node);
              this.lastNode = node;
          }
      }
      oncomment(data) {
          if (this.lastNode && this.lastNode.type === ElementType.Comment) {
              this.lastNode.data += data;
              return;
          }
          const node = new Comment$2(data);
          this.addNode(node);
          this.lastNode = node;
      }
      oncommentend() {
          this.lastNode = null;
      }
      oncdatastart() {
          const text = new Text$2("");
          const node = new CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
      }
      oncdataend() {
          this.lastNode = null;
      }
      onprocessinginstruction(name, data) {
          const node = new ProcessingInstruction(name, data);
          this.addNode(node);
      }
      handleCallback(error) {
          if (typeof this.callback === "function") {
              this.callback(error, this.dom);
          }
          else if (error) {
              throw error;
          }
      }
      addNode(node) {
          const parent = this.tagStack[this.tagStack.length - 1];
          const previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
              node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
              node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
              node.prev = previousSibling;
              previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
      }
  }

  const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  const xmlCodeMap = new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"],
  ]);
  // For compatibility with node < 4, we wrap `codePointAt`
  const getCodePoint = 
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null
      ? (str, index) => str.codePointAt(index)
      : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800
              ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                  c.charCodeAt(index + 1) -
                  0xdc00 +
                  0x10000
              : c.charCodeAt(index);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using XML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  function encodeXML(str) {
      let ret = "";
      let lastIdx = 0;
      let match;
      while ((match = xmlReplacer.exec(str)) !== null) {
          const i = match.index;
          const char = str.charCodeAt(i);
          const next = xmlCodeMap.get(char);
          if (next !== undefined) {
              ret += str.substring(lastIdx, i) + next;
              lastIdx = i + 1;
          }
          else {
              ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
              // Increase by 1 if we have a surrogate pair
              lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
          }
      }
      return ret + str.substr(lastIdx);
  }
  /**
   * Creates a function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   *
   * @param regex Regular expression to match characters to escape.
   * @param map Map of characters to escape to their entities.
   *
   * @returns Function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   */
  function getEscaper(regex, map) {
      return function escape(data) {
          let match;
          let lastIdx = 0;
          let result = "";
          while ((match = regex.exec(data))) {
              if (lastIdx !== match.index) {
                  result += data.substring(lastIdx, match.index);
              }
              // We know that this character will be in the map.
              result += map.get(match[0].charCodeAt(0));
              // Every match will be of length 1
              lastIdx = match.index + 1;
          }
          return result + data.substring(lastIdx);
      };
  }
  /**
   * Encodes all characters that have to be escaped in HTML attributes,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"],
  ]));
  /**
   * Encodes all characters that have to be escaped in HTML text,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"],
  ]));

  const elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath",
  ].map((val) => [val.toLowerCase(), val]));
  const attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan",
  ].map((val) => [val.toLowerCase(), val]));

  /*
   * Module dependencies
   */
  const unencodedElements = new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript",
  ]);
  function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
  }
  /**
   * Format attributes
   */
  function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
          return;
      const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
          ? replaceQuotes
          : opts.xmlMode || opts.encodeEntities !== "utf8"
              ? encodeXML
              : escapeAttribute;
      return Object.keys(attributes)
          .map((key) => {
          var _a, _b;
          const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
          if (opts.xmlMode === "foreign") {
              /* Fix up mixed-case attribute names */
              key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
              return key;
          }
          return `${key}="${encode(value)}"`;
      })
          .join(" ");
  }
  /**
   * Self-enclosing tags
   */
  const singleTag = new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
  ]);
  /**
   * Renders a DOM node or an array of DOM nodes to a string.
   *
   * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
   *
   * @param node Node to be rendered.
   * @param options Changes serialization behavior
   */
  function render(node, options = {}) {
      const nodes = "length" in node ? node : [node];
      let output = "";
      for (let i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
      }
      return output;
  }
  function renderNode(node, options) {
      switch (node.type) {
          case Root:
              return render(node.children, options);
          // @ts-expect-error We don't use `Doctype` yet
          case Doctype:
          case Directive:
              return renderDirective(node);
          case Comment$3:
              return renderComment(node);
          case CDATA$1:
              return renderCdata(node);
          case Script:
          case Style:
          case Tag:
              return renderTag(node, options);
          case Text$3:
              return renderText(node, options);
      }
  }
  const foreignModeIntegrationPoints = new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title",
  ]);
  const foreignElements = new Set(["svg", "math"]);
  function renderTag(elem, opts) {
      var _a;
      // Handle SVG / MathML in HTML
      if (opts.xmlMode === "foreign") {
          /* Fix up mixed-case element names */
          elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
          /* Exit foreign mode at integration points */
          if (elem.parent &&
              foreignModeIntegrationPoints.has(elem.parent.name)) {
              opts = { ...opts, xmlMode: false };
          }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = { ...opts, xmlMode: "foreign" };
      }
      let tag = `<${elem.name}`;
      const attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
          tag += ` ${attribs}`;
      }
      if (elem.children.length === 0 &&
          (opts.xmlMode
              ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                  opts.selfClosingTags !== false
              : // User explicitly asked for self-closing tags, even in HTML mode
                  opts.selfClosingTags && singleTag.has(elem.name))) {
          if (!opts.xmlMode)
              tag += " ";
          tag += "/>";
      }
      else {
          tag += ">";
          if (elem.children.length > 0) {
              tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
              tag += `</${elem.name}>`;
          }
      }
      return tag;
  }
  function renderDirective(elem) {
      return `<${elem.data}>`;
  }
  function renderText(elem, opts) {
      var _a;
      let data = elem.data || "";
      // If entities weren't decoded, no need to encode them back
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
          !(!opts.xmlMode &&
              elem.parent &&
              unencodedElements.has(elem.parent.name))) {
          data =
              opts.xmlMode || opts.encodeEntities !== "utf8"
                  ? encodeXML(data)
                  : escapeText(data);
      }
      return data;
  }
  function renderCdata(elem) {
      return `<![CDATA[${elem.children[0].data}]]>`;
  }
  function renderComment(elem) {
      return `<!--${elem.data}-->`;
  }

  /**
   * @category Stringify
   * @deprecated Use the `dom-serializer` module directly.
   * @param node Node to get the outer HTML of.
   * @param options Options for serialization.
   * @returns `node`'s outer HTML.
   */
  function getOuterHTML(node, options) {
      return render(node, options);
  }
  /**
   * @category Stringify
   * @deprecated Use the `dom-serializer` module directly.
   * @param node Node to get the inner HTML of.
   * @param options Options for serialization.
   * @returns `node`'s inner HTML.
   */
  function getInnerHTML(node, options) {
      return hasChildren(node)
          ? node.children.map((node) => getOuterHTML(node, options)).join("")
          : "";
  }
  /**
   * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
   *
   * @category Stringify
   * @deprecated Use `textContent` instead.
   * @param node Node to get the inner text of.
   * @returns `node`'s inner text.
   */
  function getText$1(node) {
      if (Array.isArray(node))
          return node.map(getText$1).join("");
      if (isTag$1(node))
          return node.name === "br" ? "\n" : getText$1(node.children);
      if (isCDATA(node))
          return getText$1(node.children);
      if (isText(node))
          return node.data;
      return "";
  }
  /**
   * Get a node's text content. Ignores comments.
   *
   * @category Stringify
   * @param node Node to get the text content of.
   * @returns `node`'s text content.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
   */
  function textContent(node) {
      if (Array.isArray(node))
          return node.map(textContent).join("");
      if (hasChildren(node) && !isComment(node)) {
          return textContent(node.children);
      }
      if (isText(node))
          return node.data;
      return "";
  }
  /**
   * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
   *
   * @category Stringify
   * @param node Node to get the inner text of.
   * @returns `node`'s inner text.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
   */
  function innerText(node) {
      if (Array.isArray(node))
          return node.map(innerText).join("");
      if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
          return innerText(node.children);
      }
      if (isText(node))
          return node.data;
      return "";
  }

  /**
   * Get a node's children.
   *
   * @category Traversal
   * @param elem Node to get the children of.
   * @returns `elem`'s children, or an empty array.
   */
  function getChildren$1(elem) {
      return hasChildren(elem) ? elem.children : [];
  }
  /**
   * Get a node's parent.
   *
   * @category Traversal
   * @param elem Node to get the parent of.
   * @returns `elem`'s parent node, or `null` if `elem` is a root node.
   */
  function getParent$1(elem) {
      return elem.parent || null;
  }
  /**
   * Gets an elements siblings, including the element itself.
   *
   * Attempts to get the children through the element's parent first. If we don't
   * have a parent (the element is a root node), we walk the element's `prev` &
   * `next` to get all remaining nodes.
   *
   * @category Traversal
   * @param elem Element to get the siblings of.
   * @returns `elem`'s siblings, including `elem`.
   */
  function getSiblings$1(elem) {
      const parent = getParent$1(elem);
      if (parent != null)
          return getChildren$1(parent);
      const siblings = [elem];
      let { prev, next } = elem;
      while (prev != null) {
          siblings.unshift(prev);
          ({ prev } = prev);
      }
      while (next != null) {
          siblings.push(next);
          ({ next } = next);
      }
      return siblings;
  }
  /**
   * Gets an attribute from an element.
   *
   * @category Traversal
   * @param elem Element to check.
   * @param name Attribute name to retrieve.
   * @returns The element's attribute value, or `undefined`.
   */
  function getAttributeValue$1(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
  }
  /**
   * Checks whether an element has an attribute.
   *
   * @category Traversal
   * @param elem Element to check.
   * @param name Attribute name to look for.
   * @returns Returns whether `elem` has the attribute `name`.
   */
  function hasAttrib$1(elem, name) {
      return (elem.attribs != null &&
          Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
          elem.attribs[name] != null);
  }
  /**
   * Get the tag name of an element.
   *
   * @category Traversal
   * @param elem The element to get the name for.
   * @returns The tag name of `elem`.
   */
  function getName$1(elem) {
      return elem.name;
  }
  /**
   * Returns the next element sibling of a node.
   *
   * @category Traversal
   * @param elem The element to get the next sibling of.
   * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
   * sibling.
   */
  function nextElementSibling$1(elem) {
      let { next } = elem;
      while (next !== null && !isTag$1(next))
          ({ next } = next);
      return next;
  }
  /**
   * Returns the previous element sibling of a node.
   *
   * @category Traversal
   * @param elem The element to get the previous sibling of.
   * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
   * previous sibling.
   */
  function prevElementSibling(elem) {
      let { prev } = elem;
      while (prev !== null && !isTag$1(prev))
          ({ prev } = prev);
      return prev;
  }

  /**
   * Remove an element from the dom
   *
   * @category Manipulation
   * @param elem The element to be removed
   */
  function removeElement(elem) {
      if (elem.prev)
          elem.prev.next = elem.next;
      if (elem.next)
          elem.next.prev = elem.prev;
      if (elem.parent) {
          const childs = elem.parent.children;
          const childsIndex = childs.lastIndexOf(elem);
          if (childsIndex >= 0) {
              childs.splice(childsIndex, 1);
          }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
  }
  /**
   * Replace an element in the dom
   *
   * @category Manipulation
   * @param elem The element to be replaced
   * @param replacement The element to be added
   */
  function replaceElement(elem, replacement) {
      const prev = (replacement.prev = elem.prev);
      if (prev) {
          prev.next = replacement;
      }
      const next = (replacement.next = elem.next);
      if (next) {
          next.prev = replacement;
      }
      const parent = (replacement.parent = elem.parent);
      if (parent) {
          const childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
          elem.parent = null;
      }
  }
  /**
   * Append a child to an element.
   *
   * @category Manipulation
   * @param parent The element to append to.
   * @param child The element to be added as a child.
   */
  function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
          const sibling = parent.children[parent.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
      }
      else {
          child.prev = null;
      }
  }
  /**
   * Append an element after another.
   *
   * @category Manipulation
   * @param elem The element to append after.
   * @param next The element be added.
   */
  function append$1(elem, next) {
      removeElement(next);
      const { parent } = elem;
      const currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
          currNext.prev = next;
          if (parent) {
              const childs = parent.children;
              childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
      }
      else if (parent) {
          parent.children.push(next);
      }
  }
  /**
   * Prepend a child to an element.
   *
   * @category Manipulation
   * @param parent The element to prepend before.
   * @param child The element to be added as a child.
   */
  function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
          const sibling = parent.children[1];
          sibling.prev = child;
          child.next = sibling;
      }
      else {
          child.next = null;
      }
  }
  /**
   * Prepend an element before another.
   *
   * @category Manipulation
   * @param elem The element to prepend before.
   * @param prev The element be added.
   */
  function prepend(elem, prev) {
      removeElement(prev);
      const { parent } = elem;
      if (parent) {
          const childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
          elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
  }

  /**
   * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param node Node to search. Will be included in the result set if it matches.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes passing `test`.
   */
  function filter(test, node, recurse = true, limit = Infinity) {
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
  }
  /**
   * Search an array of nodes and their children for nodes passing a test function.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes passing `test`.
   */
  function find(test, nodes, recurse, limit) {
      const result = [];
      /** Stack of the arrays we are looking at. */
      const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      /** Stack of the indices within the arrays. */
      const indexStack = [0];
      for (;;) {
          // First, check if the current array has any more elements to look at.
          if (indexStack[0] >= nodeStack[0].length) {
              // If we have no more arrays to look at, we are done.
              if (indexStack.length === 1) {
                  return result;
              }
              // Otherwise, remove the current array from the stack.
              nodeStack.shift();
              indexStack.shift();
              // Loop back to the start to continue with the next array.
              continue;
          }
          const elem = nodeStack[0][indexStack[0]++];
          if (test(elem)) {
              result.push(elem);
              if (--limit <= 0)
                  return result;
          }
          if (recurse && hasChildren(elem) && elem.children.length > 0) {
              /*
               * Add the children to the stack. We are depth-first, so this is
               * the next array we look at.
               */
              indexStack.unshift(0);
              nodeStack.unshift(elem.children);
          }
      }
  }
  /**
   * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns The first node in the array that passes `test`.
   * @deprecated Use `Array.prototype.find` directly.
   */
  function findOneChild(test, nodes) {
      return nodes.find(test);
  }
  /**
   * Finds one element in a tree that passes a test.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Node or array of nodes to search.
   * @param recurse Also consider child nodes.
   * @returns The first node that passes `test`.
   */
  function findOne$1(test, nodes, recurse = true) {
      const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
      for (let i = 0; i < searchedNodes.length; i++) {
          const node = searchedNodes[i];
          if (isTag$1(node) && test(node)) {
              return node;
          }
          if (recurse && hasChildren(node) && node.children.length > 0) {
              const found = findOne$1(test, node.children, true);
              if (found)
                  return found;
          }
      }
      return null;
  }
  /**
   * Checks if a tree of nodes contains at least one node passing a test.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns Whether a tree of nodes contains at least one node passing the test.
   */
  function existsOne$1(test, nodes) {
      return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => (isTag$1(node) && test(node)) ||
          (hasChildren(node) && existsOne$1(test, node.children)));
  }
  /**
   * Search an array of nodes and their children for elements passing a test function.
   *
   * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns All nodes passing `test`.
   */
  function findAll$1(test, nodes) {
      const result = [];
      const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      const indexStack = [0];
      for (;;) {
          if (indexStack[0] >= nodeStack[0].length) {
              if (nodeStack.length === 1) {
                  return result;
              }
              // Otherwise, remove the current array from the stack.
              nodeStack.shift();
              indexStack.shift();
              // Loop back to the start to continue with the next array.
              continue;
          }
          const elem = nodeStack[0][indexStack[0]++];
          if (isTag$1(elem) && test(elem))
              result.push(elem);
          if (hasChildren(elem) && elem.children.length > 0) {
              indexStack.unshift(0);
              nodeStack.unshift(elem.children);
          }
      }
  }

  /**
   * A map of functions to check nodes against.
   */
  const Checks = {
      tag_name(name) {
          if (typeof name === "function") {
              return (elem) => isTag$1(elem) && name(elem.name);
          }
          else if (name === "*") {
              return isTag$1;
          }
          return (elem) => isTag$1(elem) && elem.name === name;
      },
      tag_type(type) {
          if (typeof type === "function") {
              return (elem) => type(elem.type);
          }
          return (elem) => elem.type === type;
      },
      tag_contains(data) {
          if (typeof data === "function") {
              return (elem) => isText(elem) && data(elem.data);
          }
          return (elem) => isText(elem) && elem.data === data;
      },
  };
  /**
   * Returns a function to check whether a node has an attribute with a particular
   * value.
   *
   * @param attrib Attribute to check.
   * @param value Attribute value to look for.
   * @returns A function to check whether the a node has an attribute with a
   *   particular value.
   */
  function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
          return (elem) => isTag$1(elem) && value(elem.attribs[attrib]);
      }
      return (elem) => isTag$1(elem) && elem.attribs[attrib] === value;
  }
  /**
   * Returns a function that returns `true` if either of the input functions
   * returns `true` for a node.
   *
   * @param a First function to combine.
   * @param b Second function to combine.
   * @returns A function taking a node and returning `true` if either of the input
   *   functions returns `true` for the node.
   */
  function combineFuncs(a, b) {
      return (elem) => a(elem) || b(elem);
  }
  /**
   * Returns a function that executes all checks in `options` and returns `true`
   * if any of them match a node.
   *
   * @param options An object describing nodes to look for.
   * @returns A function that executes all checks in `options` and returns `true`
   *   if any of them match a node.
   */
  function compileTest(options) {
      const funcs = Object.keys(options).map((key) => {
          const value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key)
              ? Checks[key](value)
              : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  }
  /**
   * Checks whether a node matches the description in `options`.
   *
   * @category Legacy Query Functions
   * @param options An object describing nodes to look for.
   * @param node The element to test.
   * @returns Whether the element matches the description in `options`.
   */
  function testElement(options, node) {
      const test = compileTest(options);
      return test ? test(node) : true;
  }
  /**
   * Returns all nodes that match `options`.
   *
   * @category Legacy Query Functions
   * @param options An object describing nodes to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes that match `options`.
   */
  function getElements(options, nodes, recurse, limit = Infinity) {
      const test = compileTest(options);
      return test ? filter(test, nodes, recurse, limit) : [];
  }
  /**
   * Returns the node with the supplied ID.
   *
   * @category Legacy Query Functions
   * @param id The unique ID attribute value to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @returns The node with the supplied ID.
   */
  function getElementById(id, nodes, recurse = true) {
      if (!Array.isArray(nodes))
          nodes = [nodes];
      return findOne$1(getAttribCheck("id", id), nodes, recurse);
  }
  /**
   * Returns all nodes with the supplied `tagName`.
   *
   * @category Legacy Query Functions
   * @param tagName Tag name to search for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `tagName`.
   */
  function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
      return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
  }
  /**
   * Returns all nodes with the supplied `className`.
   *
   * @category Legacy Query Functions
   * @param className Class name to search for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `className`.
   */
  function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
      return filter(getAttribCheck("class", className), nodes, recurse, limit);
  }
  /**
   * Returns all nodes with the supplied `type`.
   *
   * @category Legacy Query Functions
   * @param type Element type to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `type`.
   */
  function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
      return filter(Checks["tag_type"](type), nodes, recurse, limit);
  }

  /**
   * Given an array of nodes, remove any member that is contained by another
   * member.
   *
   * @category Helpers
   * @param nodes Nodes to filter.
   * @returns Remaining nodes that aren't contained by other nodes.
   */
  function removeSubsets$1(nodes) {
      let idx = nodes.length;
      /*
       * Check if each node (or one of its ancestors) is already contained in the
       * array.
       */
      while (--idx >= 0) {
          const node = nodes[idx];
          /*
           * Remove the node if it is not unique.
           * We are going through the array from the end, so we only
           * have to check nodes that preceed the node under consideration in the array.
           */
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
              nodes.splice(idx, 1);
              continue;
          }
          for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
              if (nodes.includes(ancestor)) {
                  nodes.splice(idx, 1);
                  break;
              }
          }
      }
      return nodes;
  }
  /**
   * @category Helpers
   * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
   */
  var DocumentPosition;
  (function (DocumentPosition) {
      DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));
  /**
   * Compare the position of one node against another node in any other document,
   * returning a bitmask with the values from {@link DocumentPosition}.
   *
   * Document order:
   * > There is an ordering, document order, defined on all the nodes in the
   * > document corresponding to the order in which the first character of the
   * > XML representation of each node occurs in the XML representation of the
   * > document after expansion of general entities. Thus, the document element
   * > node will be the first node. Element nodes occur before their children.
   * > Thus, document order orders element nodes in order of the occurrence of
   * > their start-tag in the XML (after expansion of entities). The attribute
   * > nodes of an element occur after the element and before its children. The
   * > relative order of attribute nodes is implementation-dependent.
   *
   * Source:
   * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
   *
   * @category Helpers
   * @param nodeA The first node to use in the comparison
   * @param nodeB The second node to use in the comparison
   * @returns A bitmask describing the input nodes' relative position.
   *
   * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
   * a description of these values.
   */
  function compareDocumentPosition(nodeA, nodeB) {
      const aParents = [];
      const bParents = [];
      if (nodeA === nodeB) {
          return 0;
      }
      let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
      while (current) {
          aParents.unshift(current);
          current = current.parent;
      }
      current = hasChildren(nodeB) ? nodeB : nodeB.parent;
      while (current) {
          bParents.unshift(current);
          current = current.parent;
      }
      const maxIdx = Math.min(aParents.length, bParents.length);
      let idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
      }
      if (idx === 0) {
          return DocumentPosition.DISCONNECTED;
      }
      const sharedParent = aParents[idx - 1];
      const siblings = sharedParent.children;
      const aSibling = aParents[idx];
      const bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
              return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
          }
          return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
          return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
  }
  /**
   * Sort an array of nodes based on their relative position in the document,
   * removing any duplicate nodes. If the array contains nodes that do not belong
   * to the same document, sort order is unspecified.
   *
   * @category Helpers
   * @param nodes Array of DOM nodes.
   * @returns Collection of unique nodes, sorted in document order.
   */
  function uniqueSort(nodes) {
      nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
      nodes.sort((a, b) => {
          const relative = compareDocumentPosition(a, b);
          if (relative & DocumentPosition.PRECEDING) {
              return -1;
          }
          else if (relative & DocumentPosition.FOLLOWING) {
              return 1;
          }
          return 0;
      });
      return nodes;
  }

  /**
   * Get the feed object from the root of a DOM tree.
   *
   * @category Feeds
   * @param doc - The DOM to to extract the feed from.
   * @returns The feed.
   */
  function getFeed(doc) {
      const feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot
          ? null
          : feedRoot.name === "feed"
              ? getAtomFeed(feedRoot)
              : getRssFeed(feedRoot);
  }
  /**
   * Parse an Atom feed.
   *
   * @param feedRoot The root of the feed.
   * @returns The parsed feed.
   */
  function getAtomFeed(feedRoot) {
      var _a;
      const childs = feedRoot.children;
      const feed = {
          type: "atom",
          items: getElementsByTagName("entry", childs).map((item) => {
              var _a;
              const { children } = item;
              const entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "id", children);
              addConditionally(entry, "title", "title", children);
              const href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
              if (href) {
                  entry.link = href;
              }
              const description = fetch("summary", children) || fetch("content", children);
              if (description) {
                  entry.description = description;
              }
              const pubDate = fetch("updated", children);
              if (pubDate) {
                  entry.pubDate = new Date(pubDate);
              }
              return entry;
          }),
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
          feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      const updated = fetch("updated", childs);
      if (updated) {
          feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
  }
  /**
   * Parse a RSS feed.
   *
   * @param feedRoot The root of the feed.
   * @returns The parsed feed.
   */
  function getRssFeed(feedRoot) {
      var _a, _b;
      const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      const feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: getElementsByTagName("item", feedRoot.children).map((item) => {
              const { children } = item;
              const entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "guid", children);
              addConditionally(entry, "title", "title", children);
              addConditionally(entry, "link", "link", children);
              addConditionally(entry, "description", "description", children);
              const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
              if (pubDate)
                  entry.pubDate = new Date(pubDate);
              return entry;
          }),
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      const updated = fetch("lastBuildDate", childs);
      if (updated) {
          feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
  }
  const MEDIA_KEYS_STRING = ["url", "type", "lang"];
  const MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width",
  ];
  /**
   * Get all media elements of a feed item.
   *
   * @param where Nodes to search in.
   * @returns Media elements.
   */
  function getMediaElements(where) {
      return getElementsByTagName("media:content", where).map((elem) => {
          const { attribs } = elem;
          const media = {
              medium: attribs["medium"],
              isDefault: !!attribs["isDefault"],
          };
          for (const attrib of MEDIA_KEYS_STRING) {
              if (attribs[attrib]) {
                  media[attrib] = attribs[attrib];
              }
          }
          for (const attrib of MEDIA_KEYS_INT) {
              if (attribs[attrib]) {
                  media[attrib] = parseInt(attribs[attrib], 10);
              }
          }
          if (attribs["expression"]) {
              media.expression = attribs["expression"];
          }
          return media;
      });
  }
  /**
   * Get one element by tag name.
   *
   * @param tagName Tag name to look for
   * @param node Node to search in
   * @returns The element or null
   */
  function getOneElement(tagName, node) {
      return getElementsByTagName(tagName, node, true, 1)[0];
  }
  /**
   * Get the text content of an element with a certain tag name.
   *
   * @param tagName Tag name to look for.
   * @param where Node to search in.
   * @param recurse Whether to recurse into child nodes.
   * @returns The text content of the element.
   */
  function fetch(tagName, where, recurse = false) {
      return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
  }
  /**
   * Adds a property to an object if it has a value.
   *
   * @param obj Object to be extended
   * @param prop Property name
   * @param tagName Tag name that contains the conditionally added property
   * @param where Element to search for the property
   * @param recurse Whether to recurse into child nodes.
   */
  function addConditionally(obj, prop, tagName, where, recurse = false) {
      const val = fetch(tagName, where, recurse);
      if (val)
          obj[prop] = val;
  }
  /**
   * Checks if an element is a feed root node.
   *
   * @param value The name of the element to check.
   * @returns Whether an element is a feed root node.
   */
  function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
  }

  var DomUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get DocumentPosition () { return DocumentPosition; },
    append: append$1,
    appendChild: appendChild,
    compareDocumentPosition: compareDocumentPosition,
    existsOne: existsOne$1,
    filter: filter,
    find: find,
    findAll: findAll$1,
    findOne: findOne$1,
    findOneChild: findOneChild,
    getAttributeValue: getAttributeValue$1,
    getChildren: getChildren$1,
    getElementById: getElementById,
    getElements: getElements,
    getElementsByClassName: getElementsByClassName,
    getElementsByTagName: getElementsByTagName,
    getElementsByTagType: getElementsByTagType,
    getFeed: getFeed,
    getInnerHTML: getInnerHTML,
    getName: getName$1,
    getOuterHTML: getOuterHTML,
    getParent: getParent$1,
    getSiblings: getSiblings$1,
    getText: getText$1,
    hasAttrib: hasAttrib$1,
    hasChildren: hasChildren,
    innerText: innerText,
    isCDATA: isCDATA,
    isComment: isComment,
    isDocument: isDocument,
    isTag: isTag$1,
    isText: isText,
    nextElementSibling: nextElementSibling$1,
    prepend: prepend,
    prependChild: prependChild,
    prevElementSibling: prevElementSibling,
    removeElement: removeElement,
    removeSubsets: removeSubsets$1,
    replaceElement: replaceElement,
    testElement: testElement,
    textContent: textContent,
    uniqueSort: uniqueSort
  });

  // Helper methods
  /**
   * Parses the data, returns the resulting document.
   *
   * @param data The data that should be parsed.
   * @param options Optional options for the parser and DOM handler.
   */
  function parseDocument(data, options) {
      const handler = new DomHandler(undefined, options);
      new Parser$2(handler, options).end(data);
      return handler.root;
  }
  /**
   * Parses data, returns an array of the root nodes.
   *
   * Note that the root nodes still have a `Document` node as their parent.
   * Use `parseDocument` to get the `Document` node instead.
   *
   * @param data The data that should be parsed.
   * @param options Optional options for the parser and DOM handler.
   * @deprecated Use `parseDocument` instead.
   */
  function parseDOM(data, options) {
      return parseDocument(data, options).children;
  }
  /**
   * Creates a parser instance, with an attached DOM handler.
   *
   * @param callback A callback that will be called once parsing has been completed, with the resulting document.
   * @param options Optional options for the parser and DOM handler.
   * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
   */
  function createDocumentStream(callback, options, elementCallback) {
      const handler = new DomHandler((error) => callback(error, handler.root), options, elementCallback);
      return new Parser$2(handler, options);
  }
  /**
   * Creates a parser instance, with an attached DOM handler.
   *
   * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.
   * @param options Optional options for the parser and DOM handler.
   * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
   * @deprecated Use `createDocumentStream` instead.
   */
  function createDomStream(callback, options, elementCallback) {
      const handler = new DomHandler(callback, options, elementCallback);
      return new Parser$2(handler, options);
  }
  const parseFeedDefaultOptions = { xmlMode: true };
  /**
   * Parse a feed.
   *
   * @param feed The feed that should be parsed, as a string.
   * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
   */
  function parseFeed(feed, options = parseFeedDefaultOptions) {
      return getFeed(parseDOM(feed, options));
  }

  var HTMLParser2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DefaultHandler: DomHandler,
    DomHandler: DomHandler,
    DomUtils: DomUtils,
    ElementType: index,
    Parser: Parser$2,
    get QuoteType () { return QuoteType; },
    Tokenizer: Tokenizer,
    createDocumentStream: createDocumentStream,
    createDomStream: createDomStream,
    getFeed: getFeed,
    parseDOM: parseDOM,
    parseDocument: parseDocument,
    parseFeed: parseFeed
  });

  // Internal
  const NODE_END = -1;

  // Node
  const ELEMENT_NODE = 1;
  const ATTRIBUTE_NODE = 2;
  const TEXT_NODE = 3;
  const CDATA_SECTION_NODE = 4;
  const COMMENT_NODE = 8;
  const DOCUMENT_NODE = 9;
  const DOCUMENT_TYPE_NODE = 10;
  const DOCUMENT_FRAGMENT_NODE = 11;

  // Elements
  const BLOCK_ELEMENTS = new Set(['ARTICLE', 'ASIDE', 'BLOCKQUOTE', 'BODY', 'BR', 'BUTTON', 'CANVAS', 'CAPTION', 'COL', 'COLGROUP', 'DD', 'DIV', 'DL', 'DT', 'EMBED', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'UL', 'OL', 'P']);

  // TreeWalker
  const SHOW_ALL = -1;
  const SHOW_ELEMENT = 1;
  const SHOW_TEXT = 4;
  const SHOW_CDATA_SECTION = 8;
  const SHOW_COMMENT = 128;

  // Document position
  const DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const DOCUMENT_POSITION_PRECEDING = 0x02;
  const DOCUMENT_POSITION_FOLLOWING = 0x04;
  const DOCUMENT_POSITION_CONTAINS = 0x08;
  const DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  // SVG
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

  const {
    assign,
    create: create$1,
    defineProperties,
    entries,
    getOwnPropertyDescriptors,
    keys,
    setPrototypeOf
  } = Object;

  const $String = String;

  const getEnd = node => node.nodeType === ELEMENT_NODE ? node[END] : node;

  const ignoreCase = ({ownerDocument}) => ownerDocument[MIME].ignoreCase;

  const knownAdjacent = (prev, next) => {
    prev[NEXT] = next;
    next[PREV] = prev;
  };

  const knownBoundaries = (prev, current, next) => {
    knownAdjacent(prev, current);
    knownAdjacent(getEnd(current), next);
  };

  const knownSegment = (prev, start, end, next) => {
    knownAdjacent(prev, start);
    knownAdjacent(getEnd(end), next);
  };

  const knownSiblings = (prev, current, next) => {
    knownAdjacent(prev, current);
    knownAdjacent(current, next);
  };

  const localCase = ({localName, ownerDocument}) => {
    return ownerDocument[MIME].ignoreCase ? localName.toUpperCase() : localName;
  };

  const setAdjacent = (prev, next) => {
    if (prev)
      prev[NEXT] = next;
    if (next)
      next[PREV] = prev;
  };

  /**
   * @param {import("../interface/document.js").Document} ownerDocument
   * @param {string} html
   * @return {import("../interface/document-fragment.js").DocumentFragment}
   */
  const htmlToFragment = (ownerDocument, html) => {
    const fragment = ownerDocument.createDocumentFragment();

    const elem = ownerDocument.createElement('');
    elem.innerHTML = html;
    const { firstChild, lastChild } = elem;

    if (firstChild) {
      knownSegment(fragment, firstChild, lastChild, fragment[END]);

      let child = firstChild;
      do {
        child.parentNode = fragment;
      } while (child !== lastChild && (child = getEnd(child)[NEXT]));
    }

    return fragment;
  };

  const shadowRoots = new WeakMap;

  let reactive = false;

  const Classes = new WeakMap;

  const customElements = new WeakMap;

  const attributeChangedCallback$1 = (element, attributeName, oldValue, newValue) => {
    if (
      reactive &&
      customElements.has(element) &&
      element.attributeChangedCallback &&
      element.constructor.observedAttributes.includes(attributeName)
    ) {
      element.attributeChangedCallback(attributeName, oldValue, newValue);
    }
  };

  const createTrigger = (method, isConnected) => element => {
    if (customElements.has(element)) {
      const info = customElements.get(element);
      if (info.connected !== isConnected && element.isConnected === isConnected) {
        info.connected = isConnected;
        if (method in element)
          element[method]();
      }
    }
  };

  const triggerConnected = createTrigger('connectedCallback', true);
  const connectedCallback = element => {
    if (reactive) {
      triggerConnected(element);
      if (shadowRoots.has(element))
        element = shadowRoots.get(element).shadowRoot;
      let {[NEXT]: next, [END]: end} = element;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE)
          triggerConnected(next);
        next = next[NEXT];
      }
    }
  };

  const triggerDisconnected = createTrigger('disconnectedCallback', false);
  const disconnectedCallback = element => {
    if (reactive) {
      triggerDisconnected(element);
      if (shadowRoots.has(element))
        element = shadowRoots.get(element).shadowRoot;
      let {[NEXT]: next, [END]: end} = element;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE)
          triggerDisconnected(next);
        next = next[NEXT];
      }
    }
  };

  /**
   * @implements globalThis.CustomElementRegistry
   */
  class CustomElementRegistry {

    /**
     * @param {Document} ownerDocument
     */
    constructor(ownerDocument) {
      /**
       * @private
       */
      this.ownerDocument = ownerDocument;

      /**
       * @private
       */
      this.registry = new Map;

      /**
       * @private
       */
      this.waiting = new Map;

      /**
       * @private
       */
      this.active = false;
    }

    /**
     * @param {string} localName the custom element definition name
     * @param {Function} Class the custom element **Class** definition
     * @param {object?} options the optional object with an `extends` property
     */
    define(localName, Class, options = {}) {
      const {ownerDocument, registry, waiting} = this;

      if (registry.has(localName))
        throw new Error('unable to redefine ' + localName);

      if (Classes.has(Class))
        throw new Error('unable to redefine the same class: ' + Class);

      this.active = (reactive = true);

      const {extends: extend} = options;

      Classes.set(Class, {
        ownerDocument,
        options: {is: extend ? localName : ''},
        localName: extend || localName
      });

      const check = extend ?
        element => {
          return element.localName === extend &&
                 element.getAttribute('is') === localName;
        } :
        element => element.localName === localName;
      registry.set(localName, {Class, check});
      if (waiting.has(localName)) {
        for (const resolve of waiting.get(localName))
          resolve(Class);
        waiting.delete(localName);
      }
      ownerDocument.querySelectorAll(
        extend ? `${extend}[is="${localName}"]` : localName
      ).forEach(this.upgrade, this);
    }

    /**
     * @param {Element} element
     */
    upgrade(element) {
      if (customElements.has(element))
        return;
      const {ownerDocument, registry} = this;
      const ce = element.getAttribute('is') || element.localName;
      if (registry.has(ce)) {
        const {Class, check} = registry.get(ce);
        if (check(element)) {
          const {attributes, isConnected} = element;
          for (const attr of attributes)
            element.removeAttributeNode(attr);

          const values = entries(element);
          for (const [key] of values)
            delete element[key];

          setPrototypeOf(element, Class.prototype);
          ownerDocument[UPGRADE] = {element, values};
          new Class(ownerDocument, ce);

          customElements.set(element, {connected: isConnected});

          for (const attr of attributes)
            element.setAttributeNode(attr);

          if (isConnected && element.connectedCallback)
            element.connectedCallback();
        }
      }
    }

    /**
     * @param {string} localName the custom element definition name
     */
    whenDefined(localName) {
      const {registry, waiting} = this;
      return new Promise(resolve => {
        if (registry.has(localName))
          resolve(registry.get(localName).Class);
        else {
          if (!waiting.has(localName))
            waiting.set(localName, []);
          waiting.get(localName).push(resolve);
        }
      });
    }

    /**
     * @param {string} localName the custom element definition name
     * @returns {Function?} the custom element **Class**, if any
     */
    get(localName) {
      const info = this.registry.get(localName);
      return info && info.Class;
    }

    /**
     * @param {Function} Class **Class** of custom element
     * @returns {string?} found tag name or null
     */
    getName(Class) {
      if (Classes.has(Class)) {
        const { localName } = Classes.get(Class);
        return localName;
      }
      return null;
    }
  }

  const {Parser: Parser$1} = HTMLParser2;

  const append = (self, node, active) => {
    const end = self[END];
    node.parentNode = self;
    knownBoundaries(end[PREV], node, end);
    if (active && node.nodeType === ELEMENT_NODE)
      connectedCallback(node);
    return node;
  };

  const attribute = (element, end, attribute, value, active) => {
    attribute[VALUE] = value;
    attribute.ownerElement = element;
    knownSiblings(end[PREV], attribute, end);
    if (attribute.name === 'class')
      element.className = value;
    if (active)
      attributeChangedCallback$1(element, attribute.name, null, value);
  };

  const parseFromString$1 = (document, isHTML, markupLanguage) => {
    const {active, registry} = document[CUSTOM_ELEMENTS];

    let node = document;
    let ownerSVGElement = null;
    let parsingCData = false;

    const content = new Parser$1({
      // <!DOCTYPE ...>
      onprocessinginstruction(name, data) {
        if (name.toLowerCase() === '!doctype')
          document.doctype = data.slice(name.length).trim();
      },

      // <tagName>
      onopentag(name, attributes) {
        let create = true;
        if (isHTML) {
          if (ownerSVGElement) {
            node = append(node, document.createElementNS(SVG_NAMESPACE, name), active);
            node.ownerSVGElement = ownerSVGElement;
            create = false;
          }
          else if (name === 'svg' || name === 'SVG') {
            ownerSVGElement = document.createElementNS(SVG_NAMESPACE, name);
            node = append(node, ownerSVGElement, active);
            create = false;
          }
          else if (active) {
            const ce = name.includes('-') ? name : (attributes.is || '');
            if (ce && registry.has(ce)) {
              const {Class} = registry.get(ce);
              node = append(node, new Class, active);
              delete attributes.is;
              create = false;
            }
          }
        }

        if (create)
          node = append(node, document.createElement(name), false);

        let end = node[END];
        for (const name of keys(attributes))
          attribute(node, end, document.createAttribute(name), attributes[name], active);
      },

      // #text, #comment
      oncomment(data) { append(node, document.createComment(data), active); },
      ontext(text) {
        if (parsingCData) {
          append(node, document.createCDATASection(text), active);
        } else {
          append(node, document.createTextNode(text), active);
        }
      },

      // #cdata
      oncdatastart() { parsingCData = true; },
      oncdataend() { parsingCData = false; },

      // </tagName>
      onclosetag() {
        if (isHTML && node === ownerSVGElement)
          ownerSVGElement = null;
        node = node.parentNode;
      }
    }, {
      lowerCaseAttributeNames: false,
      decodeEntities: true,
      xmlMode: !isHTML
    });

    content.write(markupLanguage);
    content.end();

    return document;
  };

  const htmlClasses = new Map;

  const registerHTMLClass = (names, Class) => {
    for (const name of [].concat(names)) {
      htmlClasses.set(name, Class);
      htmlClasses.set(name.toUpperCase(), Class);
    }
  };

  const loopSegment = ({[NEXT]: next, [END]: end}, json) => {
    while (next !== end) {
      switch (next.nodeType) {
        case ATTRIBUTE_NODE:
          attrAsJSON(next, json);
          break;
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          characterDataAsJSON(next, json);
          break;
        case ELEMENT_NODE:
          elementAsJSON(next, json);
          next = getEnd(next);
          break;
        case DOCUMENT_TYPE_NODE:
          documentTypeAsJSON(next, json);
          break;
      }
      next = next[NEXT];
    }
    const last = json.length - 1;
    const value = json[last];
    if (typeof value === 'number' && value < 0)
      json[last] += NODE_END;
    else
      json.push(NODE_END);
  };

  const attrAsJSON = (attr, json) => {
    json.push(ATTRIBUTE_NODE, attr.name);
    const value = attr[VALUE].trim();
    if (value)
      json.push(value);
  };

  const characterDataAsJSON = (node, json) => {
    const value = node[VALUE];
    if (value.trim())
      json.push(node.nodeType, value);
  };

  const nonElementAsJSON = (node, json) => {
    json.push(node.nodeType);
    loopSegment(node, json);
  };

  const documentTypeAsJSON = ({name, publicId, systemId}, json) => {
    json.push(DOCUMENT_TYPE_NODE, name);
    if (publicId)
      json.push(publicId);
    if (systemId)
      json.push(systemId);
  };

  const elementAsJSON = (element, json) => {
    json.push(ELEMENT_NODE, element.localName);
    loopSegment(element, json);
  };

  const createRecord =
    (type, target, element, addedNodes, removedNodes, attributeName, oldValue) =>
   ({
    type,
    target,
    addedNodes,
    removedNodes,
    attributeName,
    oldValue,
    previousSibling: element?.previousSibling || null,
    nextSibling: element?.nextSibling || null,
  });

  const queueAttribute = (
    observer, target, attributeName, attributeFilter, attributeOldValue, oldValue
  ) => {
    if ((!attributeFilter || attributeFilter.includes(attributeName))) {
      const {callback, records, scheduled} = observer;
      records.push(createRecord(
        'attributes', target, null,
        [], [],
        attributeName, attributeOldValue ? oldValue : void 0
      ));
      if (!scheduled) {
        observer.scheduled = true;
        Promise.resolve().then(() => {
          observer.scheduled = false;
          callback(records.splice(0), observer);
        });
      }
    }
  };

  const attributeChangedCallback = (element, attributeName, oldValue) => {
    const {ownerDocument} = element;
    const {active, observers} = ownerDocument[MUTATION_OBSERVER];
    if (active) {
      for (const observer of observers) {
        for (const [
          target,
          {
            childList,
            subtree,
            attributes,
            attributeFilter,
            attributeOldValue
          }
        ] of observer.nodes) {
          if (childList) {
            if (
              (subtree && (target === ownerDocument || target.contains(element))) ||
              (!subtree && target.children.includes(element))
            ) {
              queueAttribute(
                observer, element,
                attributeName, attributeFilter, attributeOldValue, oldValue
              );
              break;
            }
          }
          else if (
            attributes &&
            target === element
          ) {
            queueAttribute(
              observer, element,
              attributeName, attributeFilter, attributeOldValue, oldValue
            );
            break;
          }
        }
      }
    }
  };

  const moCallback = (element, parentNode) => {
    const {ownerDocument} = element;
    const {active, observers} = ownerDocument[MUTATION_OBSERVER];
    if (active) {
      for (const observer of observers) {
        for (const [target, {subtree, childList, characterData}] of observer.nodes) {
          if (childList) {
            if (
              (parentNode && (target === parentNode || /* c8 ignore next */(subtree && target.contains(parentNode)))) ||
              (!parentNode && ((subtree && (target === ownerDocument || /* c8 ignore next */target.contains(element))) ||
                              (!subtree && target[characterData ? 'childNodes' : 'children'].includes(element))))
            ) {
              const {callback, records, scheduled} = observer;
              records.push(createRecord(
                'childList', target, element,
                parentNode ? [] : [element], parentNode ? [element] : []
              ));
              if (!scheduled) {
                observer.scheduled = true;
                Promise.resolve().then(() => {
                  observer.scheduled = false;
                  callback(records.splice(0), observer);
                });
              }
              break;
            }
          }
        }
      }
    }
  };

  class MutationObserverClass {
    constructor(ownerDocument) {
      const observers = new Set;
      this.observers = observers;
      this.active = false;

      /**
       * @implements globalThis.MutationObserver
       */
      this.class = class MutationObserver {

        constructor(callback) {
          /**
           * @private
           */
          this.callback = callback;

          /**
           * @private
           */
          this.nodes = new Map;

          /**
           * @private
           */
          this.records = [];

          /**
           * @private
           */
          this.scheduled = false;
        }

        disconnect() {
          this.records.splice(0);
          this.nodes.clear();
          observers.delete(this);
          ownerDocument[MUTATION_OBSERVER].active = !!observers.size;
        }

        /**
         * @param {Element} target
         * @param {MutationObserverInit} options
         */
        observe(target, options = {
          subtree: false,
          childList: false,
          attributes: false,
          attributeFilter: null,
          attributeOldValue: false,
          characterData: false,
          // TODO: not implemented yet
          // characterDataOldValue: false
        }) {
          if (('attributeOldValue' in options) || ('attributeFilter' in options))
            options.attributes = true;
          // if ('characterDataOldValue' in options)
          //   options.characterData = true;
          options.childList = !!options.childList;
          options.subtree = !!options.subtree;
          this.nodes.set(target, options);
          observers.add(this);
          ownerDocument[MUTATION_OBSERVER].active = true;
        }

        /**
         * @returns {MutationRecord[]}
         */
        takeRecords() { return this.records.splice(0); }
      };
    }
  }

  const emptyAttributes = new Set([
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'class',
    'contenteditable',
    'controls',
    'default',
    'defer',
    'disabled',
    'draggable',
    'formnovalidate',
    'hidden',
    'id',
    'ismap',
    'itemscope',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected',
    'style',
    'truespeed'
  ]);

  const setAttribute = (element, attribute) => {
    const {[VALUE]: value, name} = attribute;
    attribute.ownerElement = element;
    knownSiblings(element, attribute, element[NEXT]);
    if (name === 'class')
      element.className = value;
    attributeChangedCallback(element, name, null);
    attributeChangedCallback$1(element, name, null, value);
  };

  const removeAttribute = (element, attribute) => {
    const {[VALUE]: value, name} = attribute;
    knownAdjacent(attribute[PREV], attribute[NEXT]);
    attribute.ownerElement = attribute[PREV] = attribute[NEXT] = null;
    if (name === 'class')
      element[CLASS_LIST] = null;
    attributeChangedCallback(element, name, value);
    attributeChangedCallback$1(element, name, value, null);
  };

  const booleanAttribute = {
    get(element, name) {
      return element.hasAttribute(name);
    },
    set(element, name, value) {
      if (value)
        element.setAttribute(name, '');
      else
        element.removeAttribute(name);
    }
  };

  const numericAttribute = {
    get(element, name) {
      return parseFloat(element.getAttribute(name) || 0);
    },
    set(element, name, value) {
      element.setAttribute(name, value);
    }
  };

  const stringAttribute = {
    get(element, name) {
      return element.getAttribute(name) || '';
    },
    set(element, name, value) {
      element.setAttribute(name, value);
    }
  };

  /* oddly enough, this apparently is not a thing
  export const nullableAttribute = {
    get(element, name) {
      return element.getAttribute(name);
    },
    set(element, name, value) {
      if (value === null)
        element.removeAttribute(name);
      else
        element.setAttribute(name, value);
    }
  };
  */

  // https://dom.spec.whatwg.org/#interface-eventtarget

  const wm = new WeakMap();

  function dispatch(event, listener) {
    if (typeof listener === 'function')
      listener.call(event.target, event);
    else
      listener.handleEvent(event);
    return event._stopImmediatePropagationFlag;
  }

  function invokeListeners({currentTarget, target}) {
    const map = wm.get(currentTarget);
    if (map && map.has(this.type)) {
      const listeners = map.get(this.type);
      if (currentTarget === target) {
        this.eventPhase = this.AT_TARGET;
      } else {
        this.eventPhase = this.BUBBLING_PHASE;
      }

      this.currentTarget = currentTarget;
      this.target = target;
      for (const [listener, options] of listeners) {
        if (options && options.once)
          listeners.delete(listener);
        if (dispatch(this, listener))
          break;
      }
      delete this.currentTarget;
      delete this.target;
      return this.cancelBubble;
    }
  }


  /**
   * @implements globalThis.EventTarget
   */
  class DOMEventTarget {

    constructor() {
      wm.set(this, new Map);
    }

    /**
     * @protected
     */
    _getParent() {
      return null;
    }

    addEventListener(type, listener, options) {
      const map = wm.get(this);
      if (!map.has(type)) 
        map.set(type, new Map);
      map.get(type).set(listener, options);
    }

    removeEventListener(type, listener) {
      const map = wm.get(this);
      if (map.has(type)) {
        const listeners = map.get(type);
        if (listeners.delete(listener) && !listeners.size)
          map.delete(type);
      }
    }

    dispatchEvent(event) {
      let node = this;
      event.eventPhase = event.CAPTURING_PHASE;

      // intentionally simplified, specs imply way more code: https://dom.spec.whatwg.org/#event-path
      while (node) {
        if (node.dispatchEvent)
          event._path.push({currentTarget: node, target: this});
        node = event.bubbles && node._getParent && node._getParent();
      }
      event._path.some(invokeListeners, event);
      event._path = [];
      event.eventPhase = event.NONE;
      return !event.defaultPrevented;
    }

  }

  // https://dom.spec.whatwg.org/#interface-nodelist

  /**
   * @implements globalThis.NodeList
   */
  class NodeList extends Array {
    item(i) { return i < this.length ? this[i] : null; }
  }

  // https://dom.spec.whatwg.org/#node


  const getParentNodeCount = ({parentNode}) => {
    let count = 0;
    while (parentNode) {
      count++;
      parentNode = parentNode.parentNode;
    }
    return count;
  };

  /**
   * @implements globalThis.Node
   */
  let Node$1 = class Node extends DOMEventTarget {

    static get ELEMENT_NODE() { return ELEMENT_NODE; }
    static get ATTRIBUTE_NODE() { return ATTRIBUTE_NODE; }
    static get TEXT_NODE() { return TEXT_NODE; }
    static get CDATA_SECTION_NODE() { return CDATA_SECTION_NODE; }
    static get COMMENT_NODE() { return COMMENT_NODE; }
    static get DOCUMENT_NODE() { return DOCUMENT_NODE; }
    static get DOCUMENT_FRAGMENT_NODE() { return DOCUMENT_FRAGMENT_NODE; }
    static get DOCUMENT_TYPE_NODE() { return DOCUMENT_TYPE_NODE; }

    constructor(ownerDocument, localName, nodeType) {
      super();
      this.ownerDocument = ownerDocument;
      this.localName = localName;
      this.nodeType = nodeType;
      this.parentNode = null;
      this[NEXT] = null;
      this[PREV] = null;
    }

    get ELEMENT_NODE() { return ELEMENT_NODE; }
    get ATTRIBUTE_NODE() { return ATTRIBUTE_NODE; }
    get TEXT_NODE() { return TEXT_NODE; }
    get CDATA_SECTION_NODE() { return CDATA_SECTION_NODE; }
    get COMMENT_NODE() { return COMMENT_NODE; }
    get DOCUMENT_NODE() { return DOCUMENT_NODE; }
    get DOCUMENT_FRAGMENT_NODE() { return DOCUMENT_FRAGMENT_NODE; }
    get DOCUMENT_TYPE_NODE() { return DOCUMENT_TYPE_NODE; }

    get baseURI() {
      const ownerDocument = this.nodeType === DOCUMENT_NODE ?
                              this : this.ownerDocument;
      if (ownerDocument) {
        const base = ownerDocument.querySelector('base');
        if (base)
          return base.getAttribute('href');

        const {location} = ownerDocument.defaultView;
        if (location)
          return location.href;
      }

      return null;
    }

    /* c8 ignore start */
    // mixin: node
    get isConnected() { return false; }
    get nodeName() { return this.localName; }
    get parentElement() { return null; }
    get previousSibling() { return null; }
    get previousElementSibling() { return null; }
    get nextSibling() { return null; }
    get nextElementSibling() { return null; }
    get childNodes() { return new NodeList; }
    get firstChild() { return null; }
    get lastChild() { return null; }

    // default values
    get nodeValue() { return null; }
    set nodeValue(value) {}
    get textContent() { return null; }
    set textContent(value) {}
    normalize() {}
    cloneNode() { return null; }
    contains() { return false; }
    /**
     * Inserts a node before a reference node as a child of this parent node.
     * @param {Node} newNode The node to be inserted.
     * @param {Node} referenceNode The node before which newNode is inserted. If this is null, then newNode is inserted at the end of node's child nodes.
     * @returns The added child
     */
    // eslint-disable-next-line no-unused-vars
    insertBefore(newNode, referenceNode) { return newNode }
    /**
     * Adds a node to the end of the list of children of this node.
     * @param {Node} child The node to append to the given parent node.
     * @returns The appended child.
     */
    appendChild(child) { return child }
    /**
     * Replaces a child node within this node
     * @param {Node} newChild The new node to replace oldChild.
     * @param {Node} oldChild The child to be replaced.
     * @returns The replaced Node. This is the same node as oldChild.
     */
    replaceChild(newChild, oldChild) { return oldChild }
    /**
     * Removes a child node from the DOM.
     * @param {Node} child A Node that is the child node to be removed from the DOM.
     * @returns The removed node.
     */
    removeChild(child) { return child }
    toString() { return ''; }
    /* c8 ignore stop */

    hasChildNodes() { return !!this.lastChild; }
    isSameNode(node) { return this === node; }

    // TODO: attributes?
    compareDocumentPosition(target) {
      let result = 0;
      if (this !== target) {
        let self = getParentNodeCount(this);
        let other = getParentNodeCount(target);
        if (self < other) {
          result += DOCUMENT_POSITION_FOLLOWING;
          if (this.contains(target))
            result += DOCUMENT_POSITION_CONTAINED_BY;
        }
        else if (other < self) {
          result += DOCUMENT_POSITION_PRECEDING;
          if (target.contains(this))
            result += DOCUMENT_POSITION_CONTAINS;
        }
        else if (self && other) {
          const {childNodes} = this.parentNode;
          if (childNodes.indexOf(this) < childNodes.indexOf(target))
            result += DOCUMENT_POSITION_FOLLOWING;
          else
            result += DOCUMENT_POSITION_PRECEDING;
        }
        if (!self || !other) {
          result += DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          result += DOCUMENT_POSITION_DISCONNECTED;
        }
      }
      return result;
    }

    isEqualNode(node) {
      if (this === node)
        return true;
      if (this.nodeType === node.nodeType) {
        switch (this.nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            const aNodes = this.childNodes;
            const bNodes = node.childNodes;
            return aNodes.length === bNodes.length && aNodes.every((node, i) => node.isEqualNode(bNodes[i]));
          }
        }
        return this.toString() === node.toString();
      }
      return false;
    }

    /**
     * @protected
     */
    _getParent() {
      return this.parentNode;
    }

    /**
     * Calling it on an element inside a standard web page will return an HTMLDocument object representing the entire page (or <iframe>).
     * Calling it on an element inside a shadow DOM will return the associated ShadowRoot.
     * @return {ShadowRoot | HTMLDocument}
     */
    getRootNode() {
      let root = this;
      while (root.parentNode)
        root = root.parentNode;
      return root;
    }
  };

  const {replace} = '';

  // escape
  const ca = /[<>&\xA0]/g;

  const esca = {
    '\xA0': '&#160;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
  };

  const pe = m => esca[m];

  /**
   * Safely escape HTML entities such as `&`, `<`, `>` only.
   * @param {string} es the input to safely escape
   * @returns {string} the escaped input, and it **throws** an error if
   *  the input type is unexpected, except for boolean and numbers,
   *  converted as string.
   */
  const escape = es => replace.call(es, ca, pe);

  const QUOTE = /"/g;

  /**
   * @implements globalThis.Attr
   */
  let Attr$1 = class Attr extends Node$1 {
    constructor(ownerDocument, name, value = '') {
      super(ownerDocument, name, ATTRIBUTE_NODE);
      this.ownerElement = null;
      this.name = $String(name);
      this[VALUE] = $String(value);
      this[CHANGED] = false;
    }

    get value() { return this[VALUE]; }
    set value(newValue) {
      const {[VALUE]: oldValue, name, ownerElement} = this;
      this[VALUE] = $String(newValue);
      this[CHANGED] = true;
      if (ownerElement) {
        attributeChangedCallback(ownerElement, name, oldValue);
        attributeChangedCallback$1(ownerElement, name, oldValue, this[VALUE]);
      }
    }

    cloneNode() {
      const {ownerDocument, name, [VALUE]: value} = this;
      return new Attr(ownerDocument, name, value);
    }

    toString() {
      const {name, [VALUE]: value} = this;
      if (emptyAttributes.has(name) && !value) {
        return ignoreCase(this) ? name : `${name}=""`;
      }
      const escapedValue = (ignoreCase(this) ? value : escape(value)).replace(QUOTE, '&quot;');
      return `${name}="${escapedValue}"`;
    }

    toJSON() {
      const json = [];
      attrAsJSON(this, json);
      return json;
    }
  };

  const isConnected = ({ownerDocument, parentNode}) => {
    while (parentNode) {
      if (parentNode === ownerDocument)
        return true;
      parentNode = parentNode.parentNode || parentNode.host;
    }
    return false;
  };

  const parentElement = ({parentNode}) => {
    if (parentNode) {
      switch (parentNode.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          return null;
      }
    }
    return parentNode;
  };

  const previousSibling = ({[PREV]: prev}) => {
    switch (prev ? prev.nodeType : 0) {
      case NODE_END:
        return prev[START];
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        return prev;
    }
    return null;
  };

  const nextSibling = node => {
    const next = getEnd(node)[NEXT];
    return next && (next.nodeType === NODE_END ? null : next);
  };

  // https://dom.spec.whatwg.org/#nondocumenttypechildnode
  // CharacterData, Element


  const nextElementSibling = node => {
    let next = nextSibling(node);
    while (next && next.nodeType !== ELEMENT_NODE)
      next = nextSibling(next);
    return next;
  };

  const previousElementSibling = node => {
    let prev = previousSibling(node);
    while (prev && prev.nodeType !== ELEMENT_NODE)
      prev = previousSibling(prev);
    return prev;
  };

  // https://dom.spec.whatwg.org/#childnode
  // CharacterData, DocumentType, Element


  const asFragment = (ownerDocument, nodes) => {
    const fragment = ownerDocument.createDocumentFragment();
    fragment.append(...nodes);
    return fragment;
  };

  const before = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode)
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        node
      );
  };

  const after = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode)
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        getEnd(node)[NEXT]
      );
  };

  const replaceWith = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode) {
      if (nodes.includes(node))
        replaceWith(node, [node = node.cloneNode()]);
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        node
      );
      node.remove();
    }
  };

  const remove = (prev, current, next) => {
    const {parentNode, nodeType} = current;
    if (prev || next) {
      setAdjacent(prev, next);
      current[PREV] = null;
      getEnd(current)[NEXT] = null;
    }
    if (parentNode) {
      current.parentNode = null;
      moCallback(current, parentNode);
      if (nodeType === ELEMENT_NODE)
        disconnectedCallback(current);
    }
  };

  // https://dom.spec.whatwg.org/#interface-characterdata


  /**
   * @implements globalThis.CharacterData
   */
  let CharacterData$1 = class CharacterData extends Node$1 {

    constructor(ownerDocument, localName, nodeType, data) {
      super(ownerDocument, localName, nodeType);
      this[VALUE] = $String(data);
    }

    // <Mixins>
    get isConnected() { return isConnected(this); }
    get parentElement() { return parentElement(this); }
    get previousSibling() { return previousSibling(this); }
    get nextSibling() { return nextSibling(this); }

    get previousElementSibling() { return previousElementSibling(this); }
    get nextElementSibling() { return nextElementSibling(this); }

    before(...nodes) { before(this, nodes); }
    after(...nodes) { after(this, nodes); }
    replaceWith(...nodes) { replaceWith(this, nodes); }
    remove() { remove(this[PREV], this, this[NEXT]); }
    // </Mixins>

    // CharacterData only
    /* c8 ignore start */
    get data() { return this[VALUE]; }
    set data(value) {
      this[VALUE] = $String(value);
      moCallback(this, this.parentNode);
    }

    get nodeValue() { return this.data; }
    set nodeValue(value) { this.data = value; }

    get textContent() { return this.data; }
    set textContent(value) { this.data = value; }

    get length() { return this.data.length; }

    substringData(offset, count) {
      return this.data.substr(offset, count);
    }

    appendData(data) {
      this.data += data;
    }

    insertData(offset, data) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + data + t.slice(offset);
    }

    deleteData(offset, count) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + t.slice(offset + count);
    }

    replaceData(offset, count, data) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + data + t.slice(offset + count);
    }
    /* c8 ignore stop */

    toJSON() {
      const json = [];
      characterDataAsJSON(this, json);
      return json;
    }
  };

  /**
   * @implements globalThis.CDATASection
   */
  let CDATASection$1 = class CDATASection extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#cdatasection', CDATA_SECTION_NODE, data);
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new CDATASection(ownerDocument, data);
    }

    toString() { return `<![CDATA[${this[VALUE]}]]>`; }
  };

  /**
   * @implements globalThis.Comment
   */
  let Comment$1 = class Comment extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#comment', COMMENT_NODE, data);
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new Comment(ownerDocument, data);
    }

    toString() { return `<!--${this[VALUE]}-->`; }
  };

  var boolbase = {
  	trueFunc: function trueFunc(){
  		return true;
  	},
  	falseFunc: function falseFunc(){
  		return false;
  	}
  };

  var boolbase$1 = /*@__PURE__*/getDefaultExportFromCjs(boolbase);

  var SelectorType;
  (function (SelectorType) {
      SelectorType["Attribute"] = "attribute";
      SelectorType["Pseudo"] = "pseudo";
      SelectorType["PseudoElement"] = "pseudo-element";
      SelectorType["Tag"] = "tag";
      SelectorType["Universal"] = "universal";
      // Traversals
      SelectorType["Adjacent"] = "adjacent";
      SelectorType["Child"] = "child";
      SelectorType["Descendant"] = "descendant";
      SelectorType["Parent"] = "parent";
      SelectorType["Sibling"] = "sibling";
      SelectorType["ColumnCombinator"] = "column-combinator";
  })(SelectorType || (SelectorType = {}));
  var AttributeAction;
  (function (AttributeAction) {
      AttributeAction["Any"] = "any";
      AttributeAction["Element"] = "element";
      AttributeAction["End"] = "end";
      AttributeAction["Equals"] = "equals";
      AttributeAction["Exists"] = "exists";
      AttributeAction["Hyphen"] = "hyphen";
      AttributeAction["Not"] = "not";
      AttributeAction["Start"] = "start";
  })(AttributeAction || (AttributeAction = {}));

  const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
  const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
  const actionTypes = new Map([
      [126 /* Tilde */, AttributeAction.Element],
      [94 /* Circumflex */, AttributeAction.Start],
      [36 /* Dollar */, AttributeAction.End],
      [42 /* Asterisk */, AttributeAction.Any],
      [33 /* ExclamationMark */, AttributeAction.Not],
      [124 /* Pipe */, AttributeAction.Hyphen],
  ]);
  // Pseudos, whose data property is parsed as well.
  const unpackPseudos = new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context",
  ]);
  /**
   * Checks whether a specific selector is a traversal.
   * This is useful eg. in swapping the order of elements that
   * are not traversals.
   *
   * @param selector Selector to check.
   */
  function isTraversal$1(selector) {
      switch (selector.type) {
          case SelectorType.Adjacent:
          case SelectorType.Child:
          case SelectorType.Descendant:
          case SelectorType.Parent:
          case SelectorType.Sibling:
          case SelectorType.ColumnCombinator:
              return true;
          default:
              return false;
      }
  }
  const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
  // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
  function funescape(_, escaped, escapedWhitespace) {
      const high = parseInt(escaped, 16) - 0x10000;
      // NaN means non-codepoint
      return high !== high || escapedWhitespace
          ? escaped
          : high < 0
              ? // BMP codepoint
                  String.fromCharCode(high + 0x10000)
              : // Supplemental Plane codepoint (surrogate pair)
                  String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
  }
  function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
  }
  function isQuote(c) {
      return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
  }
  function isWhitespace(c) {
      return (c === 32 /* Space */ ||
          c === 9 /* Tab */ ||
          c === 10 /* NewLine */ ||
          c === 12 /* FormFeed */ ||
          c === 13 /* CarriageReturn */);
  }
  /**
   * Parses `selector`, optionally with the passed `options`.
   *
   * @param selector Selector to parse.
   * @param options Options for parsing.
   * @returns Returns a two-dimensional array.
   * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
   * the second contains the relevant tokens for that selector.
   */
  function parse$3(selector) {
      const subselects = [];
      const endIndex = parseSelector(subselects, `${selector}`, 0);
      if (endIndex < selector.length) {
          throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
      }
      return subselects;
  }
  function parseSelector(subselects, selector, selectorIndex) {
      let tokens = [];
      function getName(offset) {
          const match = selector.slice(selectorIndex + offset).match(reName);
          if (!match) {
              throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
          }
          const [name] = match;
          selectorIndex += offset + name.length;
          return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
          selectorIndex += offset;
          while (selectorIndex < selector.length &&
              isWhitespace(selector.charCodeAt(selectorIndex))) {
              selectorIndex++;
          }
      }
      function readValueWithParenthesis() {
          selectorIndex += 1;
          const start = selectorIndex;
          let counter = 1;
          for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
              if (selector.charCodeAt(selectorIndex) ===
                  40 /* LeftParenthesis */ &&
                  !isEscaped(selectorIndex)) {
                  counter++;
              }
              else if (selector.charCodeAt(selectorIndex) ===
                  41 /* RightParenthesis */ &&
                  !isEscaped(selectorIndex)) {
                  counter--;
              }
          }
          if (counter) {
              throw new Error("Parenthesis not matched");
          }
          return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
          let slashCount = 0;
          while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
              slashCount++;
          return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
          if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
              throw new Error("Did not expect successive traversals.");
          }
      }
      function addTraversal(type) {
          if (tokens.length > 0 &&
              tokens[tokens.length - 1].type === SelectorType.Descendant) {
              tokens[tokens.length - 1].type = type;
              return;
          }
          ensureNotTraversal();
          tokens.push({ type });
      }
      function addSpecialAttribute(name, action) {
          tokens.push({
              type: SelectorType.Attribute,
              name,
              action,
              value: getName(1),
              namespace: null,
              ignoreCase: "quirks",
          });
      }
      /**
       * We have finished parsing the current part of the selector.
       *
       * Remove descendant tokens at the end if they exist,
       * and return the last index, so that parsing can be
       * picked up from here.
       */
      function finalizeSubselector() {
          if (tokens.length &&
              tokens[tokens.length - 1].type === SelectorType.Descendant) {
              tokens.pop();
          }
          if (tokens.length === 0) {
              throw new Error("Empty sub-selector");
          }
          subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
          return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
          const firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
              // Whitespace
              case 32 /* Space */:
              case 9 /* Tab */:
              case 10 /* NewLine */:
              case 12 /* FormFeed */:
              case 13 /* CarriageReturn */: {
                  if (tokens.length === 0 ||
                      tokens[0].type !== SelectorType.Descendant) {
                      ensureNotTraversal();
                      tokens.push({ type: SelectorType.Descendant });
                  }
                  stripWhitespace(1);
                  break;
              }
              // Traversals
              case 62 /* GreaterThan */: {
                  addTraversal(SelectorType.Child);
                  stripWhitespace(1);
                  break;
              }
              case 60 /* LessThan */: {
                  addTraversal(SelectorType.Parent);
                  stripWhitespace(1);
                  break;
              }
              case 126 /* Tilde */: {
                  addTraversal(SelectorType.Sibling);
                  stripWhitespace(1);
                  break;
              }
              case 43 /* Plus */: {
                  addTraversal(SelectorType.Adjacent);
                  stripWhitespace(1);
                  break;
              }
              // Special attribute selectors: .class, #id
              case 46 /* Period */: {
                  addSpecialAttribute("class", AttributeAction.Element);
                  break;
              }
              case 35 /* Hash */: {
                  addSpecialAttribute("id", AttributeAction.Equals);
                  break;
              }
              case 91 /* LeftSquareBracket */: {
                  stripWhitespace(1);
                  // Determine attribute name and namespace
                  let name;
                  let namespace = null;
                  if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                      // Equivalent to no namespace
                      name = getName(1);
                  }
                  else if (selector.startsWith("*|", selectorIndex)) {
                      namespace = "*";
                      name = getName(2);
                  }
                  else {
                      name = getName(0);
                      if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                          selector.charCodeAt(selectorIndex + 1) !==
                              61 /* Equal */) {
                          namespace = name;
                          name = getName(1);
                      }
                  }
                  stripWhitespace(0);
                  // Determine comparison operation
                  let action = AttributeAction.Exists;
                  const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                  if (possibleAction) {
                      action = possibleAction;
                      if (selector.charCodeAt(selectorIndex + 1) !==
                          61 /* Equal */) {
                          throw new Error("Expected `=`");
                      }
                      stripWhitespace(2);
                  }
                  else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                      action = AttributeAction.Equals;
                      stripWhitespace(1);
                  }
                  // Determine value
                  let value = "";
                  let ignoreCase = null;
                  if (action !== "exists") {
                      if (isQuote(selector.charCodeAt(selectorIndex))) {
                          const quote = selector.charCodeAt(selectorIndex);
                          let sectionEnd = selectorIndex + 1;
                          while (sectionEnd < selector.length &&
                              (selector.charCodeAt(sectionEnd) !== quote ||
                                  isEscaped(sectionEnd))) {
                              sectionEnd += 1;
                          }
                          if (selector.charCodeAt(sectionEnd) !== quote) {
                              throw new Error("Attribute value didn't end");
                          }
                          value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                          selectorIndex = sectionEnd + 1;
                      }
                      else {
                          const valueStart = selectorIndex;
                          while (selectorIndex < selector.length &&
                              ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                  selector.charCodeAt(selectorIndex) !==
                                      93 /* RightSquareBracket */) ||
                                  isEscaped(selectorIndex))) {
                              selectorIndex += 1;
                          }
                          value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                      }
                      stripWhitespace(0);
                      // See if we have a force ignore flag
                      const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                      // If the forceIgnore flag is set (either `i` or `s`), use that value
                      if (forceIgnore === 115 /* LowerS */) {
                          ignoreCase = false;
                          stripWhitespace(1);
                      }
                      else if (forceIgnore === 105 /* LowerI */) {
                          ignoreCase = true;
                          stripWhitespace(1);
                      }
                  }
                  if (selector.charCodeAt(selectorIndex) !==
                      93 /* RightSquareBracket */) {
                      throw new Error("Attribute selector didn't terminate");
                  }
                  selectorIndex += 1;
                  const attributeSelector = {
                      type: SelectorType.Attribute,
                      name,
                      action,
                      value,
                      namespace,
                      ignoreCase,
                  };
                  tokens.push(attributeSelector);
                  break;
              }
              case 58 /* Colon */: {
                  if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                      tokens.push({
                          type: SelectorType.PseudoElement,
                          name: getName(2).toLowerCase(),
                          data: selector.charCodeAt(selectorIndex) ===
                              40 /* LeftParenthesis */
                              ? readValueWithParenthesis()
                              : null,
                      });
                      continue;
                  }
                  const name = getName(1).toLowerCase();
                  let data = null;
                  if (selector.charCodeAt(selectorIndex) ===
                      40 /* LeftParenthesis */) {
                      if (unpackPseudos.has(name)) {
                          if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                          }
                          data = [];
                          selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                          if (selector.charCodeAt(selectorIndex) !==
                              41 /* RightParenthesis */) {
                              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                          }
                          selectorIndex += 1;
                      }
                      else {
                          data = readValueWithParenthesis();
                          if (stripQuotesFromPseudos.has(name)) {
                              const quot = data.charCodeAt(0);
                              if (quot === data.charCodeAt(data.length - 1) &&
                                  isQuote(quot)) {
                                  data = data.slice(1, -1);
                              }
                          }
                          data = unescapeCSS(data);
                      }
                  }
                  tokens.push({ type: SelectorType.Pseudo, name, data });
                  break;
              }
              case 44 /* Comma */: {
                  finalizeSubselector();
                  tokens = [];
                  stripWhitespace(1);
                  break;
              }
              default: {
                  if (selector.startsWith("/*", selectorIndex)) {
                      const endIndex = selector.indexOf("*/", selectorIndex + 2);
                      if (endIndex < 0) {
                          throw new Error("Comment was not terminated");
                      }
                      selectorIndex = endIndex + 2;
                      // Remove leading whitespace
                      if (tokens.length === 0) {
                          stripWhitespace(0);
                      }
                      break;
                  }
                  let namespace = null;
                  let name;
                  if (firstChar === 42 /* Asterisk */) {
                      selectorIndex += 1;
                      name = "*";
                  }
                  else if (firstChar === 124 /* Pipe */) {
                      name = "";
                      if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                          addTraversal(SelectorType.ColumnCombinator);
                          stripWhitespace(2);
                          break;
                      }
                  }
                  else if (reName.test(selector.slice(selectorIndex))) {
                      name = getName(0);
                  }
                  else {
                      break loop;
                  }
                  if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                      selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                      namespace = name;
                      if (selector.charCodeAt(selectorIndex + 1) ===
                          42 /* Asterisk */) {
                          name = "*";
                          selectorIndex += 2;
                      }
                      else {
                          name = getName(1);
                      }
                  }
                  tokens.push(name === "*"
                      ? { type: SelectorType.Universal, namespace }
                      : { type: SelectorType.Tag, name, namespace });
              }
          }
      }
      finalizeSubselector();
      return selectorIndex;
  }

  const procedure = new Map([
      [SelectorType.Universal, 50],
      [SelectorType.Tag, 30],
      [SelectorType.Attribute, 1],
      [SelectorType.Pseudo, 0],
  ]);
  function isTraversal(token) {
      return !procedure.has(token.type);
  }
  const attributes = new Map([
      [AttributeAction.Exists, 10],
      [AttributeAction.Equals, 8],
      [AttributeAction.Not, 7],
      [AttributeAction.Start, 6],
      [AttributeAction.End, 6],
      [AttributeAction.Any, 5],
  ]);
  /**
   * Sort the parts of the passed selector,
   * as there is potential for optimization
   * (some types of selectors are faster than others)
   *
   * @param arr Selector to sort
   */
  function sortByProcedure(arr) {
      const procs = arr.map(getProcedure);
      for (let i = 1; i < arr.length; i++) {
          const procNew = procs[i];
          if (procNew < 0)
              continue;
          for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
              const token = arr[j + 1];
              arr[j + 1] = arr[j];
              arr[j] = token;
              procs[j + 1] = procs[j];
              procs[j] = procNew;
          }
      }
  }
  function getProcedure(token) {
      var _a, _b;
      let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === SelectorType.Attribute) {
          proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
          if (token.action === AttributeAction.Equals && token.name === "id") {
              // Prefer ID selectors (eg. #ID)
              proc = 9;
          }
          if (token.ignoreCase) {
              /*
               * IgnoreCase adds some overhead, prefer "normal" token
               * this is a binary operation, to ensure it's still an int
               */
              proc >>= 1;
          }
      }
      else if (token.type === SelectorType.Pseudo) {
          if (!token.data) {
              proc = 3;
          }
          else if (token.name === "has" || token.name === "contains") {
              proc = 0; // Expensive in any case
          }
          else if (Array.isArray(token.data)) {
              // Eg. :matches, :not
              proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
              // If we have traversals, try to avoid executing this selector
              if (proc < 0) {
                  proc = 0;
              }
          }
          else {
              proc = 2;
          }
      }
      return proc;
  }

  /**
   * All reserved characters in a regex, used for escaping.
   *
   * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
   * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
   */
  const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
  }
  /**
   * Attributes that are case-insensitive in HTML.
   *
   * @private
   * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
   */
  const caseInsensitiveAttributes = new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink",
  ]);
  function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean"
          ? selector.ignoreCase
          : selector.ignoreCase === "quirks"
              ? !!options.quirksMode
              : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
  }
  /**
   * Attribute selectors
   */
  const attributeRules = {
      equals(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length === value.length &&
                      attr.toLowerCase() === value &&
                      next(elem));
              };
          }
          return (elem) => adapter.getAttributeValue(elem, name) === value && next(elem);
      },
      hyphen(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = value.length;
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return function hyphenIC(elem) {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      (attr.length === len || attr.charAt(len) === "-") &&
                      attr.substr(0, len).toLowerCase() === value &&
                      next(elem));
              };
          }
          return function hyphen(elem) {
              const attr = adapter.getAttributeValue(elem, name);
              return (attr != null &&
                  (attr.length === len || attr.charAt(len) === "-") &&
                  attr.substr(0, len) === value &&
                  next(elem));
          };
      },
      element(next, data, options) {
          const { adapter } = options;
          const { name, value } = data;
          if (/\s/.test(value)) {
              return boolbase$1.falseFunc;
          }
          const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
          return function element(elem) {
              const attr = adapter.getAttributeValue(elem, name);
              return (attr != null &&
                  attr.length >= value.length &&
                  regex.test(attr) &&
                  next(elem));
          };
      },
      exists(next, { name }, { adapter }) {
          return (elem) => adapter.hasAttrib(elem, name) && next(elem);
      },
      start(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = value.length;
          if (len === 0) {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length >= len &&
                      attr.substr(0, len).toLowerCase() === value &&
                      next(elem));
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                  next(elem);
          };
      },
      end(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = -value.length;
          if (len === 0) {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  var _a;
                  return ((_a = adapter
                      .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                  next(elem);
          };
      },
      any(next, data, options) {
          const { adapter } = options;
          const { name, value } = data;
          if (value === "") {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              const regex = new RegExp(escapeRegex(value), "i");
              return function anyIC(elem) {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length >= value.length &&
                      regex.test(attr) &&
                      next(elem));
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                  next(elem);
          };
      },
      not(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          if (value === "") {
              return (elem) => !!adapter.getAttributeValue(elem, name) && next(elem);
          }
          else if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return ((attr == null ||
                      attr.length !== value.length ||
                      attr.toLowerCase() !== value) &&
                      next(elem));
              };
          }
          return (elem) => adapter.getAttributeValue(elem, name) !== value && next(elem);
      },
  };

  // Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
  // Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
  const whitespace = new Set([9, 10, 12, 13, 32]);
  const ZERO = "0".charCodeAt(0);
  const NINE = "9".charCodeAt(0);
  /**
   * Parses an expression.
   *
   * @throws An `Error` if parsing fails.
   * @returns An array containing the integer step size and the integer offset of the nth rule.
   * @example nthCheck.parse("2n+3"); // returns [2, 3]
   */
  function parse$2(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
          return [2, 0];
      }
      else if (formula === "odd") {
          return [2, 1];
      }
      // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
      let idx = 0;
      let a = 0;
      let sign = readSign();
      let number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
          idx++;
          a = sign * (number !== null && number !== void 0 ? number : 1);
          skipWhitespace();
          if (idx < formula.length) {
              sign = readSign();
              skipWhitespace();
              number = readNumber();
          }
          else {
              sign = number = 0;
          }
      }
      // Throw if there is anything else
      if (number === null || idx < formula.length) {
          throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
      }
      return [a, sign * number];
      function readSign() {
          if (formula.charAt(idx) === "-") {
              idx++;
              return -1;
          }
          if (formula.charAt(idx) === "+") {
              idx++;
          }
          return 1;
      }
      function readNumber() {
          const start = idx;
          let value = 0;
          while (idx < formula.length &&
              formula.charCodeAt(idx) >= ZERO &&
              formula.charCodeAt(idx) <= NINE) {
              value = value * 10 + (formula.charCodeAt(idx) - ZERO);
              idx++;
          }
          // Return `null` if we didn't read anything.
          return idx === start ? null : value;
      }
      function skipWhitespace() {
          while (idx < formula.length &&
              whitespace.has(formula.charCodeAt(idx))) {
              idx++;
          }
      }
  }

  /**
   * Returns a function that checks if an elements index matches the given rule
   * highly optimized to return the fastest solution.
   *
   * @param parsed A tuple [a, b], as returned by `parse`.
   * @returns A highly optimized function that returns whether an index matches the nth-check.
   * @example
   *
   * ```js
   * const check = nthCheck.compile([2, 3]);
   *
   * check(0); // `false`
   * check(1); // `false`
   * check(2); // `true`
   * check(3); // `false`
   * check(4); // `true`
   * check(5); // `false`
   * check(6); // `true`
   * ```
   */
  function compile$2(parsed) {
      const a = parsed[0];
      // Subtract 1 from `b`, to convert from one- to zero-indexed.
      const b = parsed[1] - 1;
      /*
       * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
       * Besides, the specification states that no elements are
       * matched when `a` and `b` are 0.
       *
       * `b < 0` here as we subtracted 1 from `b` above.
       */
      if (b < 0 && a <= 0)
          return boolbase$1.falseFunc;
      // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
      if (a === -1)
          return (index) => index <= b;
      if (a === 0)
          return (index) => index === b;
      // When `b <= 0` and `a === 1`, they match any element.
      if (a === 1)
          return b < 0 ? boolbase$1.trueFunc : (index) => index >= b;
      /*
       * Otherwise, modulo can be used to check if there is a match.
       *
       * Modulo doesn't care about the sign, so let's use `a`s absolute value.
       */
      const absA = Math.abs(a);
      // Get `b mod a`, + a if this is negative.
      const bMod = ((b % absA) + absA) % absA;
      return a > 1
          ? (index) => index >= b && index % absA === bMod
          : (index) => index <= b && index % absA === bMod;
  }

  /**
   * Parses and compiles a formula to a highly optimized function.
   * Combination of {@link parse} and {@link compile}.
   *
   * If the formula doesn't match any elements,
   * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
   * Otherwise, a function accepting an _index_ is returned, which returns
   * whether or not the passed _index_ matches the formula.
   *
   * Note: The nth-rule starts counting at `1`, the returned function at `0`.
   *
   * @param formula The formula to compile.
   * @example
   * const check = nthCheck("2n+3");
   *
   * check(0); // `false`
   * check(1); // `false`
   * check(2); // `true`
   * check(3); // `false`
   * check(4); // `true`
   * check(5); // `false`
   * check(6); // `true`
   */
  function nthCheck(formula) {
      return compile$2(parse$2(formula));
  }

  function getChildFunc(next, adapter) {
      return (elem) => {
          const parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(elem);
      };
  }
  const filters = {
      contains(next, text, { adapter }) {
          return function contains(elem) {
              return next(elem) && adapter.getText(elem).includes(text);
          };
      },
      icontains(next, text, { adapter }) {
          const itext = text.toLowerCase();
          return function icontains(elem) {
              return (next(elem) &&
                  adapter.getText(elem).toLowerCase().includes(itext));
          };
      },
      // Location specific methods
      "nth-child"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthChild(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = 0; i < siblings.length; i++) {
                  if (equals(elem, siblings[i]))
                      break;
                  if (adapter.isTag(siblings[i])) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-last-child"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthLastChild(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = siblings.length - 1; i >= 0; i--) {
                  if (equals(elem, siblings[i]))
                      break;
                  if (adapter.isTag(siblings[i])) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-of-type"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthOfType(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = 0; i < siblings.length; i++) {
                  const currentSibling = siblings[i];
                  if (equals(elem, currentSibling))
                      break;
                  if (adapter.isTag(currentSibling) &&
                      adapter.getName(currentSibling) === adapter.getName(elem)) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-last-of-type"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthLastOfType(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = siblings.length - 1; i >= 0; i--) {
                  const currentSibling = siblings[i];
                  if (equals(elem, currentSibling))
                      break;
                  if (adapter.isTag(currentSibling) &&
                      adapter.getName(currentSibling) === adapter.getName(elem)) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      // TODO determine the actual root element
      root(next, _rule, { adapter }) {
          return (elem) => {
              const parent = adapter.getParent(elem);
              return (parent == null || !adapter.isTag(parent)) && next(elem);
          };
      },
      scope(next, rule, options, context) {
          const { equals } = options;
          if (!context || context.length === 0) {
              // Equivalent to :root
              return filters["root"](next, rule, options);
          }
          if (context.length === 1) {
              // NOTE: can't be unpacked, as :has uses this for side-effects
              return (elem) => equals(context[0], elem) && next(elem);
          }
          return (elem) => context.includes(elem) && next(elem);
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive"),
  };
  /**
   * Dynamic state pseudos. These depend on optional Adapter methods.
   *
   * @param name The name of the adapter method to call.
   * @returns Pseudo for the `filters` object.
   */
  function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, { adapter }) {
          const func = adapter[name];
          if (typeof func !== "function") {
              return boolbase$1.falseFunc;
          }
          return function active(elem) {
              return func(elem) && next(elem);
          };
      };
  }

  // While filters are precompiled, pseudos get called when they are needed
  const pseudos = {
      empty(elem, { adapter }) {
          return !adapter.getChildren(elem).some((elem) => 
          // FIXME: `getText` call is potentially expensive.
          adapter.isTag(elem) || adapter.getText(elem) !== "");
      },
      "first-child"(elem, { adapter, equals }) {
          if (adapter.prevElementSibling) {
              return adapter.prevElementSibling(elem) == null;
          }
          const firstChild = adapter
              .getSiblings(elem)
              .find((elem) => adapter.isTag(elem));
          return firstChild != null && equals(elem, firstChild);
      },
      "last-child"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          for (let i = siblings.length - 1; i >= 0; i--) {
              if (equals(elem, siblings[i]))
                  return true;
              if (adapter.isTag(siblings[i]))
                  break;
          }
          return false;
      },
      "first-of-type"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          const elemName = adapter.getName(elem);
          for (let i = 0; i < siblings.length; i++) {
              const currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                  return true;
              if (adapter.isTag(currentSibling) &&
                  adapter.getName(currentSibling) === elemName) {
                  break;
              }
          }
          return false;
      },
      "last-of-type"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          const elemName = adapter.getName(elem);
          for (let i = siblings.length - 1; i >= 0; i--) {
              const currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                  return true;
              if (adapter.isTag(currentSibling) &&
                  adapter.getName(currentSibling) === elemName) {
                  break;
              }
          }
          return false;
      },
      "only-of-type"(elem, { adapter, equals }) {
          const elemName = adapter.getName(elem);
          return adapter
              .getSiblings(elem)
              .every((sibling) => equals(elem, sibling) ||
              !adapter.isTag(sibling) ||
              adapter.getName(sibling) !== elemName);
      },
      "only-child"(elem, { adapter, equals }) {
          return adapter
              .getSiblings(elem)
              .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
      },
  };
  function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
          if (func.length > argIndex) {
              throw new Error(`Pseudo-class :${name} requires an argument`);
          }
      }
      else if (func.length === argIndex) {
          throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
      }
  }

  /**
   * Aliases are pseudos that are expressed as selectors.
   */
  const aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])",
  };

  /** Used as a placeholder for :has. Will be replaced with the actual element. */
  const PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
      if (next === boolbase$1.falseFunc)
          return boolbase$1.falseFunc;
      return (elem) => adapter.isTag(elem) && next(elem);
  }
  function getNextSiblings(elem, adapter) {
      const siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
          return [];
      const elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
          return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
  }
  function copyOptions(options) {
      // Not copied: context, rootFunc
      return {
          xmlMode: !!options.xmlMode,
          lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
          lowerCaseTags: !!options.lowerCaseTags,
          quirksMode: !!options.quirksMode,
          cacheResults: !!options.cacheResults,
          pseudos: options.pseudos,
          adapter: options.adapter,
          equals: options.equals,
      };
  }
  const is$1 = (next, token, options, context, compileToken) => {
      const func = compileToken(token, copyOptions(options), context);
      return func === boolbase$1.trueFunc
          ? next
          : func === boolbase$1.falseFunc
              ? boolbase$1.falseFunc
              : (elem) => func(elem) && next(elem);
  };
  /*
   * :not, :has, :is, :matches and :where have to compile selectors
   * doing this in src/pseudos.ts would lead to circular dependencies,
   * so we add them here
   */
  const subselects = {
      is: is$1,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is$1,
      where: is$1,
      not(next, token, options, context, compileToken) {
          const func = compileToken(token, copyOptions(options), context);
          return func === boolbase$1.falseFunc
              ? next
              : func === boolbase$1.trueFunc
                  ? boolbase$1.falseFunc
                  : (elem) => !func(elem) && next(elem);
      },
      has(next, subselect, options, _context, compileToken) {
          const { adapter } = options;
          const opts = copyOptions(options);
          opts.relativeSelector = true;
          const context = subselect.some((s) => s.some(isTraversal))
              ? // Used as a placeholder. Will be replaced with the actual element.
                  [PLACEHOLDER_ELEMENT]
              : undefined;
          const compiled = compileToken(subselect, opts, context);
          if (compiled === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          const hasElement = ensureIsTag(compiled, adapter);
          // If `compiled` is `trueFunc`, we can skip this.
          if (context && compiled !== boolbase$1.trueFunc) {
              /*
               * `shouldTestNextSiblings` will only be true if the query starts with
               * a traversal (sibling or adjacent). That means we will always have a context.
               */
              const { shouldTestNextSiblings = false } = compiled;
              return (elem) => {
                  if (!next(elem))
                      return false;
                  context[0] = elem;
                  const childs = adapter.getChildren(elem);
                  const nextElements = shouldTestNextSiblings
                      ? [...childs, ...getNextSiblings(elem, adapter)]
                      : childs;
                  return adapter.existsOne(hasElement, nextElements);
              };
          }
          return (elem) => next(elem) &&
              adapter.existsOne(hasElement, adapter.getChildren(elem));
      },
  };

  function compilePseudoSelector(next, selector, options, context, compileToken) {
      var _a;
      const { name, data } = selector;
      if (Array.isArray(data)) {
          if (!(name in subselects)) {
              throw new Error(`Unknown pseudo-class :${name}(${data})`);
          }
          return subselects[name](next, data, options, context, compileToken);
      }
      const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
      if (typeof stringPseudo === "string") {
          if (data != null) {
              throw new Error(`Pseudo ${name} doesn't have any arguments`);
          }
          // The alias has to be parsed here, to make sure options are respected.
          const alias = parse$3(stringPseudo);
          return subselects["is"](next, alias, options, context, compileToken);
      }
      if (typeof userPseudo === "function") {
          verifyPseudoArgs(userPseudo, name, data, 1);
          return (elem) => userPseudo(elem, data) && next(elem);
      }
      if (name in filters) {
          return filters[name](next, data, options, context);
      }
      if (name in pseudos) {
          const pseudo = pseudos[name];
          verifyPseudoArgs(pseudo, name, data, 2);
          return (elem) => pseudo(elem, options, data) && next(elem);
      }
      throw new Error(`Unknown pseudo-class :${name}`);
  }

  function getElementParent(node, adapter) {
      const parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
          return parent;
      }
      return null;
  }
  /*
   * All available rules
   */
  function compileGeneralSelector(next, selector, options, context, compileToken) {
      const { adapter, equals } = options;
      switch (selector.type) {
          case SelectorType.PseudoElement: {
              throw new Error("Pseudo-elements are not supported by css-select");
          }
          case SelectorType.ColumnCombinator: {
              throw new Error("Column combinators are not yet supported by css-select");
          }
          case SelectorType.Attribute: {
              if (selector.namespace != null) {
                  throw new Error("Namespaced attributes are not yet supported by css-select");
              }
              if (!options.xmlMode || options.lowerCaseAttributeNames) {
                  selector.name = selector.name.toLowerCase();
              }
              return attributeRules[selector.action](next, selector, options);
          }
          case SelectorType.Pseudo: {
              return compilePseudoSelector(next, selector, options, context, compileToken);
          }
          // Tags
          case SelectorType.Tag: {
              if (selector.namespace != null) {
                  throw new Error("Namespaced tag names are not yet supported by css-select");
              }
              let { name } = selector;
              if (!options.xmlMode || options.lowerCaseTags) {
                  name = name.toLowerCase();
              }
              return function tag(elem) {
                  return adapter.getName(elem) === name && next(elem);
              };
          }
          // Traversal
          case SelectorType.Descendant: {
              if (options.cacheResults === false ||
                  typeof WeakSet === "undefined") {
                  return function descendant(elem) {
                      let current = elem;
                      while ((current = getElementParent(current, adapter))) {
                          if (next(current)) {
                              return true;
                          }
                      }
                      return false;
                  };
              }
              // @ts-expect-error `ElementNode` is not extending object
              const isFalseCache = new WeakSet();
              return function cachedDescendant(elem) {
                  let current = elem;
                  while ((current = getElementParent(current, adapter))) {
                      if (!isFalseCache.has(current)) {
                          if (adapter.isTag(current) && next(current)) {
                              return true;
                          }
                          isFalseCache.add(current);
                      }
                  }
                  return false;
              };
          }
          case "_flexibleDescendant": {
              // Include element itself, only used while querying an array
              return function flexibleDescendant(elem) {
                  let current = elem;
                  do {
                      if (next(current))
                          return true;
                  } while ((current = getElementParent(current, adapter)));
                  return false;
              };
          }
          case SelectorType.Parent: {
              return function parent(elem) {
                  return adapter
                      .getChildren(elem)
                      .some((elem) => adapter.isTag(elem) && next(elem));
              };
          }
          case SelectorType.Child: {
              return function child(elem) {
                  const parent = adapter.getParent(elem);
                  return parent != null && adapter.isTag(parent) && next(parent);
              };
          }
          case SelectorType.Sibling: {
              return function sibling(elem) {
                  const siblings = adapter.getSiblings(elem);
                  for (let i = 0; i < siblings.length; i++) {
                      const currentSibling = siblings[i];
                      if (equals(elem, currentSibling))
                          break;
                      if (adapter.isTag(currentSibling) && next(currentSibling)) {
                          return true;
                      }
                  }
                  return false;
              };
          }
          case SelectorType.Adjacent: {
              if (adapter.prevElementSibling) {
                  return function adjacent(elem) {
                      const previous = adapter.prevElementSibling(elem);
                      return previous != null && next(previous);
                  };
              }
              return function adjacent(elem) {
                  const siblings = adapter.getSiblings(elem);
                  let lastElement;
                  for (let i = 0; i < siblings.length; i++) {
                      const currentSibling = siblings[i];
                      if (equals(elem, currentSibling))
                          break;
                      if (adapter.isTag(currentSibling)) {
                          lastElement = currentSibling;
                      }
                  }
                  return !!lastElement && next(lastElement);
              };
          }
          case SelectorType.Universal: {
              if (selector.namespace != null && selector.namespace !== "*") {
                  throw new Error("Namespaced universal selectors are not yet supported by css-select");
              }
              return next;
          }
      }
  }

  /**
   * Compiles a selector to an executable function.
   *
   * @param selector Selector to compile.
   * @param options Compilation options.
   * @param context Optional context for the selector.
   */
  function compile$1(selector, options, context) {
      const next = compileUnsafe(selector, options, context);
      return ensureIsTag(next, options.adapter);
  }
  function compileUnsafe(selector, options, context) {
      const token = typeof selector === "string" ? parse$3(selector) : selector;
      return compileToken(token, options, context);
  }
  function includesScopePseudo(t) {
      return (t.type === SelectorType.Pseudo &&
          (t.name === "scope" ||
              (Array.isArray(t.data) &&
                  t.data.some((data) => data.some(includesScopePseudo)))));
  }
  const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
  const FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant",
  };
  const SCOPE_TOKEN = {
      type: SelectorType.Pseudo,
      name: "scope",
      data: null,
  };
  /*
   * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
   * http://www.w3.org/TR/selectors4/#absolutizing
   */
  function absolutize(token, { adapter }, context) {
      // TODO Use better check if the context is a document
      const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
          const parent = adapter.isTag(e) && adapter.getParent(e);
          return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
      }));
      for (const t of token) {
          if (t.length > 0 &&
              isTraversal(t[0]) &&
              t[0].type !== SelectorType.Descendant) ;
          else if (hasContext && !t.some(includesScopePseudo)) {
              t.unshift(DESCENDANT_TOKEN);
          }
          else {
              continue;
          }
          t.unshift(SCOPE_TOKEN);
      }
  }
  function compileToken(token, options, context) {
      var _a;
      token.forEach(sortByProcedure);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      const isArrayContext = Array.isArray(context);
      const finalContext = context && (Array.isArray(context) ? context : [context]);
      // Check if the selector is relative
      if (options.relativeSelector !== false) {
          absolutize(token, options, finalContext);
      }
      else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
          throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      let shouldTestNextSiblings = false;
      const query = token
          .map((rules) => {
          if (rules.length >= 2) {
              const [first, second] = rules;
              if (first.type !== SelectorType.Pseudo ||
                  first.name !== "scope") ;
              else if (isArrayContext &&
                  second.type === SelectorType.Descendant) {
                  rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
              }
              else if (second.type === SelectorType.Adjacent ||
                  second.type === SelectorType.Sibling) {
                  shouldTestNextSiblings = true;
              }
          }
          return compileRules(rules, options, finalContext);
      })
          .reduce(reduceRules, boolbase$1.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
  }
  function compileRules(rules, options, context) {
      var _a;
      return rules.reduce((previous, rule) => previous === boolbase$1.falseFunc
          ? boolbase$1.falseFunc
          : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase$1.trueFunc);
  }
  function reduceRules(a, b) {
      if (b === boolbase$1.falseFunc || a === boolbase$1.trueFunc) {
          return a;
      }
      if (a === boolbase$1.falseFunc || b === boolbase$1.trueFunc) {
          return b;
      }
      return function combine(elem) {
          return a(elem) || b(elem);
      };
  }

  const defaultEquals = (a, b) => a === b;
  const defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals,
  };
  function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      /*
       * We force one format of options to the other one.
       */
      // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
      const opts = options !== null && options !== void 0 ? options : defaultOptions;
      // @ts-expect-error Same as above.
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
      // @ts-expect-error `equals` does not exist on `Options`
      (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
      return opts;
  }
  function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
          const opts = convertOptionFormats(options);
          return func(selector, opts, context);
      };
  }
  /**
   * Compiles the query, returns a function.
   */
  const compile = wrapCompile(compile$1);
  /**
   * Tests whether or not an element is matched by query.
   *
   * @template Node The generic Node type for the DOM adapter being used.
   * @template ElementNode The Node type for elements for the DOM adapter being used.
   * @param elem The element to test if it matches the query.
   * @param query can be either a CSS selector string or a compiled query function.
   * @param [options] options for querying the document.
   * @see compile for supported selector queries.
   * @returns
   */
  function is(elem, query, options) {
      const opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : compile$1(query, opts))(elem);
  }

  const {isArray} = Array;

  /* c8 ignore start */
  const isTag = ({nodeType}) => nodeType === ELEMENT_NODE;

  const existsOne = (test, elements) => elements.some(
    element => isTag(element) && (
      test(element) ||
      existsOne(test, getChildren(element))
    )
  );

  const getAttributeValue = (element, name) => name === 'class' ?
                              element.classList.value : element.getAttribute(name);

  const getChildren = ({childNodes}) => childNodes;

  const getName = (element) => {
    const {localName} = element;
    return ignoreCase(element) ? localName.toLowerCase() : localName;
  };

  const getParent = ({parentNode}) => parentNode;

  const getSiblings = element => {
    const {parentNode} = element;
    return parentNode ? getChildren(parentNode) : element;
  };

  const getText = node => {
    if (isArray(node))
      return node.map(getText).join('');
    if (isTag(node))
      return getText(getChildren(node));
    if (node.nodeType === TEXT_NODE)
      return node.data;
    return '';
  };

  const hasAttrib = (element, name) => element.hasAttribute(name);

  const removeSubsets = nodes => {
    let {length} = nodes;
    while (length--) {
      const node = nodes[length];
      if (length && -1 < nodes.lastIndexOf(node, length - 1)) {
        nodes.splice(length, 1);
        continue;
      }
      for (let {parentNode} = node; parentNode; parentNode = parentNode.parentNode) {
        if (nodes.includes(parentNode)) {
          nodes.splice(length, 1);
          break;
        }
      }
    }
    return nodes;
  };

  const findAll = (test, nodes) => {
    const matches = [];
    for (const node of nodes) {
      if (isTag(node)) {
        if (test(node))
          matches.push(node);
        matches.push(...findAll(test, getChildren(node)));
      }
    }
    return matches;
  };

  const findOne = (test, nodes) => {
    for (let node of nodes)
      if (test(node) || (node = findOne(test, getChildren(node))))
        return node;
    return null;
  };
  /* c8 ignore stop */

  const adapter = {
    isTag,
    existsOne,
    getAttributeValue,
    getChildren,
    getName,
    getParent,
    getSiblings,
    getText,
    hasAttrib,
    removeSubsets,
    findAll,
    findOne
  };

  const prepareMatch = (element, selectors) => compile(
    selectors,
    {
      context: selectors.includes(':scope') ? element : void 0,
      xmlMode: !ignoreCase(element),
      adapter
    }
  );

  const matches = (element, selectors) => is(
    element,
    selectors,
    {
      strict: true,
      context: selectors.includes(':scope') ? element : void 0,
      xmlMode: !ignoreCase(element),
      adapter
    }
  );

  /**
   * @implements globalThis.Text
   */
  let Text$1 = class Text extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#text', TEXT_NODE, data);
    }

    get wholeText() {
      const text = [];
      let {previousSibling, nextSibling} = this;
      while (previousSibling) {
        if (previousSibling.nodeType === TEXT_NODE)
          text.unshift(previousSibling[VALUE]);
        else
          break;
        previousSibling = previousSibling.previousSibling;
      }
      text.push(this[VALUE]);
      while (nextSibling) {
        if (nextSibling.nodeType === TEXT_NODE)
          text.push(nextSibling[VALUE]);
        else
          break;
        nextSibling = nextSibling.nextSibling;
      }
      return text.join('');
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new Text(ownerDocument, data);
    }

    toString() { return escape(this[VALUE]); }
  };

  // https://dom.spec.whatwg.org/#interface-parentnode
  // Document, DocumentFragment, Element


  const isNode = node => node instanceof Node$1;

  const insert = (parentNode, child, nodes) => {
    const {ownerDocument} = parentNode;
    for (const node of nodes)
      parentNode.insertBefore(
        isNode(node) ? node : new Text$1(ownerDocument, node),
        child
      );
  };

  /** @typedef { import('../interface/element.js').Element & {
      [typeof NEXT]: NodeStruct,
      [typeof PREV]: NodeStruct,
      [typeof START]: NodeStruct,
      nodeType: typeof ATTRIBUTE_NODE | typeof DOCUMENT_FRAGMENT_NODE | typeof ELEMENT_NODE | typeof TEXT_NODE | typeof NODE_END | typeof COMMENT_NODE | typeof CDATA_SECTION_NODE,
      ownerDocument: Document,
      parentNode: ParentNode,
  }} NodeStruct */

  class ParentNode extends Node$1 {
    constructor(ownerDocument, localName, nodeType) {
      super(ownerDocument, localName, nodeType);
      this[PRIVATE] = null;
      /** @type {NodeStruct} */
      this[NEXT] = this[END] = {
        [NEXT]: null,
        [PREV]: this,
        [START]: this,
        nodeType: NODE_END,
        ownerDocument: this.ownerDocument,
        parentNode: null
      };
    }

    get childNodes() {
      const childNodes = new NodeList;
      let {firstChild} = this;
      while (firstChild) {
        childNodes.push(firstChild);
        firstChild = nextSibling(firstChild);
      }
      return childNodes;
    }

    get children() {
      const children = new NodeList;
      let {firstElementChild} = this;
      while (firstElementChild) {
        children.push(firstElementChild);
        firstElementChild = nextElementSibling(firstElementChild);
      }
      return children;
    }

    /**
     * @returns {NodeStruct | null}
     */
    get firstChild() {
      let {[NEXT]: next, [END]: end} = this;
      while (next.nodeType === ATTRIBUTE_NODE)
        next = next[NEXT];
      return next === end ? null : next;
    }

    /**
     * @returns {NodeStruct | null}
     */
    get firstElementChild() {
      let {firstChild} = this;
      while (firstChild) {
        if (firstChild.nodeType === ELEMENT_NODE)
          return firstChild;
        firstChild = nextSibling(firstChild);
      }
      return null;
    }

    get lastChild() {
      const prev = this[END][PREV];
      switch (prev.nodeType) {
        case NODE_END:
          return prev[START];
        case ATTRIBUTE_NODE:
          return null;
      }
      return prev === this ? null : prev;
    }

    get lastElementChild() {
      let {lastChild} = this;
      while (lastChild) {
        if (lastChild.nodeType === ELEMENT_NODE)
          return lastChild;
        lastChild = previousSibling(lastChild);
      }
      return null;
    }

    get childElementCount() {
      return this.children.length;
    }

    prepend(...nodes) {
      insert(this, this.firstChild, nodes);
    }

    append(...nodes) {
      insert(this, this[END], nodes);
    }

    replaceChildren(...nodes) {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end && next.nodeType === ATTRIBUTE_NODE)
        next = next[NEXT];
      while (next !== end) {
        const after = getEnd(next)[NEXT];
        next.remove();
        next = after;
      }
      if (nodes.length)
        insert(this, end, nodes);
    }

    getElementsByClassName(className) {
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (
          next.nodeType === ELEMENT_NODE &&
          next.hasAttribute('class') &&
          next.classList.has(className)
        )
          elements.push(next);
        next = next[NEXT];
      }
      return elements;
    }

    getElementsByTagName(tagName) {
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && (
          next.localName === tagName ||
          localCase(next) === tagName
        ))
          elements.push(next);
        next = next[NEXT];
      }
      return elements;
    }

    querySelector(selectors) {
      const matches = prepareMatch(this, selectors);
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && matches(next))
          return next;
        next = next.nodeType === ELEMENT_NODE && next.localName === 'template' ? next[END] : next[NEXT];
      }
      return null;
    }

    querySelectorAll(selectors) {
      const matches = prepareMatch(this, selectors);
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && matches(next))
          elements.push(next);
        next = next.nodeType === ELEMENT_NODE && next.localName === 'template' ? next[END] : next[NEXT];
      }
      return elements;
    }

    appendChild(node) {
      return this.insertBefore(node, this[END]);
    }

    contains(node) {
      let parentNode = node;
      while (parentNode && parentNode !== this)
        parentNode = parentNode.parentNode;
      return parentNode === this;
    }

    insertBefore(node, before = null) {
      if (node === before)
        return node;
      if (node === this)
        throw new Error('unable to append a node to itself');
      const next = before || this[END];
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node.remove();
          node.parentNode = this;
          knownBoundaries(next[PREV], node, next);
          moCallback(node, null);
          connectedCallback(node);
          break;
        case DOCUMENT_FRAGMENT_NODE: {
          let {[PRIVATE]: parentNode, firstChild, lastChild} = node;
          if (firstChild) {
            knownSegment(next[PREV], firstChild, lastChild, next);
            knownAdjacent(node, node[END]);
            if (parentNode)
              parentNode.replaceChildren();
            do {
              firstChild.parentNode = this;
              moCallback(firstChild, null);
              if (firstChild.nodeType === ELEMENT_NODE)
                connectedCallback(firstChild);
            } while (
              firstChild !== lastChild &&
              (firstChild = nextSibling(firstChild))
            );
          }
          break;
        }
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          node.remove();
        /* eslint no-fallthrough:0 */
        // this covers DOCUMENT_TYPE_NODE too
        default:
          node.parentNode = this;
          knownSiblings(next[PREV], node, next);
          moCallback(node, null);
          break;
      }
      return node;
    }

    normalize() {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        const {[NEXT]: $next, [PREV]: $prev, nodeType} = next;
        if (nodeType === TEXT_NODE) {
          if (!next[VALUE])
            next.remove();
          else if ($prev && $prev.nodeType === TEXT_NODE) {
            $prev.textContent += next.textContent;
            next.remove();
          }
        }
        next = $next;
      }
    }

    removeChild(node) {
      if (node.parentNode !== this)
        throw new Error('node is not a child');
      node.remove();
      return node;
    }

    replaceChild(node, replaced) {
      const next = getEnd(replaced)[NEXT];
      replaced.remove();
      this.insertBefore(node, next);
      return replaced;
    }
  }

  // https://dom.spec.whatwg.org/#interface-nonelementparentnode
  // Document, DocumentFragment


  class NonElementParentNode extends ParentNode {
    getElementById(id) {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && next.id === id)
          return next;
        next = next[NEXT];
      }
      return null;
    }

    cloneNode(deep) {
      const {ownerDocument, constructor} = this;
      const nonEPN = new constructor(ownerDocument);
      if (deep) {
        const {[END]: end} = nonEPN;
        for (const node of this.childNodes)
          nonEPN.insertBefore(node.cloneNode(deep), end);
      }
      return nonEPN; 
    }

    toString() {
      const {childNodes, localName} = this;
      return `<${localName}>${childNodes.join('')}</${localName}>`;
    }

    toJSON() {
      const json = [];
      nonElementAsJSON(this, json);
      return json;
    }
  }

  /**
   * @implements globalThis.DocumentFragment
   */
  let DocumentFragment$1 = class DocumentFragment extends NonElementParentNode {
    constructor(ownerDocument) {
      super(ownerDocument, '#document-fragment', DOCUMENT_FRAGMENT_NODE);
    }
  };

  /**
   * @implements globalThis.DocumentType
   */
  let DocumentType$1 = class DocumentType extends Node$1 {
    constructor(ownerDocument, name, publicId = '', systemId = '') {
      super(ownerDocument, '#document-type', DOCUMENT_TYPE_NODE);
      this.name = name;
      this.publicId = publicId;
      this.systemId = systemId;
    }

    cloneNode() {
      const {ownerDocument, name, publicId, systemId} = this;
      return new DocumentType(ownerDocument, name, publicId, systemId);
    }

    toString() {
      const {name, publicId, systemId} = this;
      const hasPublic = 0 < publicId.length;
      const str = [name];
      if (hasPublic)
        str.push('PUBLIC', `"${publicId}"`);
      if (systemId.length) {
        if (!hasPublic)
          str.push('SYSTEM');
        str.push(`"${systemId}"`);
      }
      return `<!DOCTYPE ${str.join(' ')}>`;
    }

    toJSON() {
      const json = [];
      documentTypeAsJSON(this, json);
      return json;
    }
  };

  /**
   * @param {Node} node
   * @returns {String}
   */
  const getInnerHtml = node => node.childNodes.join('');

  /**
   * @param {Node} node
   * @param {String} html
   */
  const setInnerHtml = (node, html) => {
    const {ownerDocument} = node;
    const {constructor} = ownerDocument;
    const document = new constructor;
    document[CUSTOM_ELEMENTS] = ownerDocument[CUSTOM_ELEMENTS];
    const {childNodes} = parseFromString$1(document, ignoreCase(node), html);

    node.replaceChildren(...childNodes.map(setOwnerDocument, ownerDocument));
  };

  function setOwnerDocument(node) {
    node.ownerDocument = this;
    switch (node.nodeType) {
      case ELEMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        node.childNodes.forEach(setOwnerDocument, this);
        break;
    }
    return node;
  }

  var uhyphen = camel => camel.replace(/(([A-Z0-9])([A-Z0-9][a-z]))|(([a-z0-9]+)([A-Z]))/g, '$2$5-$3$6')
                               .toLowerCase();

  const refs$1 = new WeakMap;

  const key = name => `data-${uhyphen(name)}`;
  const prop = name => name.slice(5).replace(/-([a-z])/g, (_, $1) => $1.toUpperCase());

  const handler$2 = {
    get(dataset, name) {
      if (name in dataset)
        return refs$1.get(dataset).getAttribute(key(name));
    },

    set(dataset, name, value) {
      dataset[name] = value;
      refs$1.get(dataset).setAttribute(key(name), value);
      return true;
    },

    deleteProperty(dataset, name) {
      if (name in dataset)
        refs$1.get(dataset).removeAttribute(key(name));
      return delete dataset[name];
    }
  };

  /**
   * @implements globalThis.DOMStringMap
   */
  class DOMStringMap {
    /**
     * @param {Element} ref
     */
    constructor(ref) {
      for (const {name, value} of ref.attributes) {
        if (/^data-/.test(name))
          this[prop(name)] = value;
      }
      refs$1.set(this, ref);
      return new Proxy(this, handler$2);
    }
  }

  setPrototypeOf(DOMStringMap.prototype, null);

  const {add} = Set.prototype;
  const addTokens = (self, tokens) => {
    for (const token of tokens) {
      if (token)
        add.call(self, token);
    }
  };

  const update = ({[OWNER_ELEMENT]: ownerElement, value}) => {
    const attribute = ownerElement.getAttributeNode('class');
    if (attribute)
      attribute.value = value;
    else
      setAttribute(
        ownerElement,
        new Attr$1(ownerElement.ownerDocument, 'class', value)
      );
  };

  /**
   * @implements globalThis.DOMTokenList
   */
  class DOMTokenList extends Set {

    constructor(ownerElement) {
      super();
      this[OWNER_ELEMENT] = ownerElement;
      const attribute = ownerElement.getAttributeNode('class');
      if (attribute)
        addTokens(this, attribute.value.split(/\s+/));
    }

    get length() { return this.size; }

    get value() { return [...this].join(' '); }

    /**
     * @param  {...string} tokens
     */
    add(...tokens) {
      addTokens(this, tokens);
      update(this);
    }

    /**
     * @param {string} token
     */
    contains(token) { return this.has(token); }

    /**
     * @param  {...string} tokens
     */
    remove(...tokens) {
      for (const token of tokens)
        this.delete(token);
      update(this);
    }

    /**
     * @param {string} token
     * @param {boolean?} force
     */
    toggle(token, force) {
      if (this.has(token)) {
        if (force)
          return true;
        this.delete(token);
        update(this);
      }
      else if (force || arguments.length === 1) {
        super.add(token);
        update(this);
        return true;
      }
      return false;
    }

    /**
     * @param {string} token
     * @param {string} newToken
     */
    replace(token, newToken) {
      if (this.has(token)) {
        this.delete(token);
        super.add(newToken);
        update(this);
        return true;
      }
      return false;
    }

    /**
     * @param {string} token
     */
    supports() { return true; }
  }

  const refs = new WeakMap;

  const getKeys = style => [...style.keys()].filter(key => key !== PRIVATE);

  const updateKeys = style => {
    const attr = refs.get(style).getAttributeNode('style');
    if (!attr || attr[CHANGED] || style.get(PRIVATE) !== attr) {
      style.clear();
      if (attr) {
        style.set(PRIVATE, attr);
        for (const rule of attr[VALUE].split(/\s*;\s*/)) {
          let [key, ...rest] = rule.split(':');
          if (rest.length > 0) {
            key = key.trim();
            const value = rest.join(':').trim();
            if (key && value)
              style.set(key, value);
          }
        }
      }
    }
    return attr;
  };

  const handler$1 = {
    get(style, name) {
      if (name in prototype)
        return style[name];
      updateKeys(style);
      if (name === 'length')
        return getKeys(style).length;
      if (/^\d+$/.test(name))
        return getKeys(style)[name];
      return style.get(uhyphen(name));
    },

    set(style, name, value) {
      if (name === 'cssText')
        style[name] = value;
      else {
        let attr = updateKeys(style);
        if (value == null)
          style.delete(uhyphen(name));
        else
          style.set(uhyphen(name), value);
        if (!attr) {
          const element = refs.get(style);
          attr = element.ownerDocument.createAttribute('style');
          element.setAttributeNode(attr);
          style.set(PRIVATE, attr);
        }
        attr[CHANGED] = false;
        attr[VALUE] = style.toString();
      }
      return true;
    }
  };

  /**
   * @implements globalThis.CSSStyleDeclaration
   */
  let CSSStyleDeclaration$1 = class CSSStyleDeclaration extends Map {
    constructor(element) {
      super();
      refs.set(this, element);
      /* c8 ignore start */
      return new Proxy(this, handler$1);
      /* c8 ignore stop */
    }

    get cssText() {
      return this.toString();
    }

    set cssText(value) {
      refs.get(this).setAttribute('style', value);
    }

    getPropertyValue(name) {
      const self = this[PRIVATE];
      return handler$1.get(self, name);
    }

    setProperty(name, value) {
      const self = this[PRIVATE];
      handler$1.set(self, name, value);
    }

    removeProperty(name) {
      const self = this[PRIVATE];
      handler$1.set(self, name, null);
    }

    [Symbol.iterator]() {
      const self = this[PRIVATE];
      updateKeys(self);
      const keys = getKeys(self);
      const {length} = keys;
      let i = 0;
      return {
        next() {
          const done = i === length;
          return {done, value: done ? null : keys[i++]};
        }
      };
    }

    get[PRIVATE]() { return this; }

    toString() {
      const self = this[PRIVATE];
      updateKeys(self);
      const cssText = [];
      self.forEach(push, cssText);
      return cssText.join(';');
    }
  };

  const {prototype} = CSSStyleDeclaration$1;

  function push(value, key) {
    if (key !== PRIVATE)
      this.push(`${key}:${value}`);
  }

  // https://dom.spec.whatwg.org/#interface-event

  /* c8 ignore start */

  // Node 15 has Event but 14 and 12 don't
  const BUBBLING_PHASE = 3;
  const AT_TARGET = 2;
  const CAPTURING_PHASE = 1;
  const NONE = 0;

  function getCurrentTarget(ev) {
    return ev.currentTarget;
  }

  /**
   * @implements globalThis.Event
   */
  class GlobalEvent {
      static get BUBBLING_PHASE() { return BUBBLING_PHASE; }
      static get AT_TARGET() { return AT_TARGET; }
      static get CAPTURING_PHASE() { return CAPTURING_PHASE; }
      static get NONE() { return NONE; }

      constructor(type, eventInitDict = {}) {
        this.type = type;
        this.bubbles = !!eventInitDict.bubbles;
        this.cancelBubble = false;
        this._stopImmediatePropagationFlag = false;
        this.cancelable = !!eventInitDict.cancelable;
        this.eventPhase = this.NONE;
        this.timeStamp = Date.now();
        this.defaultPrevented = false;
        this.originalTarget = null;
        this.returnValue = null;
        this.srcElement = null;
        this.target = null;
        this._path = [];
      }

      get BUBBLING_PHASE() { return BUBBLING_PHASE; }
      get AT_TARGET() { return AT_TARGET; }
      get CAPTURING_PHASE() { return CAPTURING_PHASE; }
      get NONE() { return NONE; }

      preventDefault() { this.defaultPrevented = true; }

      // simplified implementation, should be https://dom.spec.whatwg.org/#dom-event-composedpath
      composedPath() {
        return this._path.map(getCurrentTarget);
      }

      stopPropagation() {
        this.cancelBubble = true;
      }
      
      stopImmediatePropagation() {
        this.stopPropagation();
        this._stopImmediatePropagationFlag = true;
      }
    }

  /* c8 ignore stop */

  /**
   * @implements globalThis.NamedNodeMap
   */
  class NamedNodeMap extends Array {
    constructor(ownerElement) {
      super();
      this.ownerElement = ownerElement;
    }

    getNamedItem(name) {
      return this.ownerElement.getAttributeNode(name);
    }

    setNamedItem(attr) {
      this.ownerElement.setAttributeNode(attr);
      this.unshift(attr);
    }

    removeNamedItem(name) {
      const item = this.getNamedItem(name);
      this.ownerElement.removeAttribute(name);
      this.splice(this.indexOf(item), 1);
    }

    item(index) {
      return index < this.length ? this[index] : null;
    }

    /* c8 ignore start */
    getNamedItemNS(_, name) {
      return this.getNamedItem(name);
    }

    setNamedItemNS(_, attr) {
      return this.setNamedItem(attr);
    }

    removeNamedItemNS(_, name) {
      return this.removeNamedItem(name);
    }
    /* c8 ignore stop */
  }

  /**
   * @implements globalThis.ShadowRoot
   */
  let ShadowRoot$1 = class ShadowRoot extends NonElementParentNode {
    constructor(host) {
      super(host.ownerDocument, '#shadow-root', DOCUMENT_FRAGMENT_NODE);
      this.host = host;
    }

    get innerHTML() {
      return getInnerHtml(this);
    }
    set innerHTML(html) {
      setInnerHtml(this, html);
    }
  };

  // https://dom.spec.whatwg.org/#interface-element


  // <utils>
  const attributesHandler = {
    get(target, key) {
      return key in target ? target[key] : target.find(({name}) => name === key);
    }
  };

  const create = (ownerDocument, element, localName)  => {
    if ('ownerSVGElement' in element) {
      const svg = ownerDocument.createElementNS(SVG_NAMESPACE, localName);
      svg.ownerSVGElement = element.ownerSVGElement;
      return svg;
    }
    return ownerDocument.createElement(localName);
  };

  const isVoid = ({localName, ownerDocument}) => {
    return ownerDocument[MIME].voidElements.test(localName);
  };

  // </utils>

  /**
   * @implements globalThis.Element
   */
  let Element$1 = class Element extends ParentNode {
    constructor(ownerDocument, localName) {
      super(ownerDocument, localName, ELEMENT_NODE);
      this[CLASS_LIST] = null;
      this[DATASET] = null;
      this[STYLE] = null;
    }

    // <Mixins>
    get isConnected() { return isConnected(this); }
    get parentElement() { return parentElement(this); }
    get previousSibling() { return previousSibling(this); }
    get nextSibling() { return nextSibling(this); }
    get namespaceURI() {
      return 'http://www.w3.org/1999/xhtml';
    }

    get previousElementSibling() { return previousElementSibling(this); }
    get nextElementSibling() { return nextElementSibling(this); }

    before(...nodes) { before(this, nodes); }
    after(...nodes) { after(this, nodes); }
    replaceWith(...nodes) { replaceWith(this, nodes); }
    remove() { remove(this[PREV], this, this[END][NEXT]); }
    // </Mixins>

    // <specialGetters>
    get id() { return stringAttribute.get(this, 'id'); }
    set id(value) { stringAttribute.set(this, 'id', value); }

    get className() { return this.classList.value; }
    set className(value) {
      const {classList} = this;
      classList.clear();
      classList.add(...($String(value).split(/\s+/)));
    }

    get nodeName() { return localCase(this); }
    get tagName() { return localCase(this); }

    get classList() {
      return this[CLASS_LIST] || (
        this[CLASS_LIST] = new DOMTokenList(this)
      );
    }

    get dataset() {
      return this[DATASET] || (
        this[DATASET] = new DOMStringMap(this)
      );
    }

    getBoundingClientRect() {
      return {
        x: 0,
        y: 0,
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      };
    }

    get nonce() { return stringAttribute.get(this, 'nonce'); }
    set nonce(value) { stringAttribute.set(this, 'nonce', value); }

    get style() {
      return this[STYLE] || (
        this[STYLE] = new CSSStyleDeclaration$1(this)
      );
    }

    get tabIndex() { return numericAttribute.get(this, 'tabindex') || -1; }
    set tabIndex(value) { numericAttribute.set(this, 'tabindex', value); }

    get slot() { return stringAttribute.get(this, 'slot'); }
    set slot(value) { stringAttribute.set(this, 'slot', value); }
    // </specialGetters>


    // <contentRelated>
    get innerText() {
      const text = [];
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === TEXT_NODE) {
          text.push(next.textContent.replace(/\s+/g, ' '));
        } else if(
          text.length && next[NEXT] != end &&
          BLOCK_ELEMENTS.has(next.tagName)
        ) {
          text.push('\n');
        }
        next = next[NEXT];
      }
      return text.join('');
    }

    /**
     * @returns {String}
     */
    get textContent() {
      const text = [];
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        const nodeType = next.nodeType;
        if (nodeType === TEXT_NODE || nodeType === CDATA_SECTION_NODE)
          text.push(next.textContent);
        next = next[NEXT];
      }
      return text.join('');
    }

    set textContent(text) {
      this.replaceChildren();
      if (text != null && text !== '')
        this.appendChild(new Text$1(this.ownerDocument, text));
    }

    get innerHTML() {
      return getInnerHtml(this);
    }
    set innerHTML(html) {
      setInnerHtml(this, html);
    }

    get outerHTML() { return this.toString(); }
    set outerHTML(html) {
      const template = this.ownerDocument.createElement('');
      template.innerHTML = html;
      this.replaceWith(...template.childNodes);
    }
    // </contentRelated>

    // <attributes>
    get attributes() {
      const attributes = new NamedNodeMap(this);
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        attributes.push(next);
        next = next[NEXT];
      }
      return new Proxy(attributes, attributesHandler);
    }

    focus() { this.dispatchEvent(new GlobalEvent('focus')); }

    getAttribute(name) {
      if (name === 'class')
        return this.className;
      const attribute = this.getAttributeNode(name);
      return attribute && (ignoreCase(this) ? attribute.value : escape(attribute.value));
    }

    getAttributeNode(name) {
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next.name === name)
          return next;
        next = next[NEXT];
      }
      return null;
    }

    getAttributeNames() {
      const attributes = new NodeList;
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        attributes.push(next.name);
        next = next[NEXT];
      }
      return attributes;
    }

    hasAttribute(name) { return !!this.getAttributeNode(name); }
    hasAttributes() { return this[NEXT].nodeType === ATTRIBUTE_NODE; }

    removeAttribute(name) {
      if (name === 'class' && this[CLASS_LIST])
          this[CLASS_LIST].clear();
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next.name === name) {
          removeAttribute(this, next);
          return;
        }
        next = next[NEXT];
      }
    }

    removeAttributeNode(attribute) {
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next === attribute) {
          removeAttribute(this, next);
          return;
        }
        next = next[NEXT];
      }
    }

    setAttribute(name, value) {
      if (name === 'class')
        this.className = value;
      else {
        const attribute = this.getAttributeNode(name);
        if (attribute)
          attribute.value = value;
        else
          setAttribute(this, new Attr$1(this.ownerDocument, name, value));
      }
    }

    setAttributeNode(attribute) {
      const {name} = attribute;
      const previously = this.getAttributeNode(name);
      if (previously !== attribute) {
        if (previously)
          this.removeAttributeNode(previously);
        const {ownerElement} = attribute;
        if (ownerElement)
          ownerElement.removeAttributeNode(attribute);
        setAttribute(this, attribute);
      }
      return previously;
    }

    toggleAttribute(name, force) {
      if (this.hasAttribute(name)) {
        if (!force) {
          this.removeAttribute(name);
          return false;
        }
        return true;
      }
      else if (force || arguments.length === 1) {
        this.setAttribute(name, '');
        return true;
      }
      return false;
    }
    // </attributes>

    // <ShadowDOM>
    get shadowRoot() {
      if (shadowRoots.has(this)) {
        const {mode, shadowRoot} = shadowRoots.get(this);
        if (mode === 'open')
          return shadowRoot;
      }
      return null;
    }

    attachShadow(init) {
      if (shadowRoots.has(this))
        throw new Error('operation not supported');
      // TODO: shadowRoot should be likely a specialized class that extends DocumentFragment
      //       but until DSD is out, I am not sure I should spend time on this.
      const shadowRoot = new ShadowRoot$1(this);
      shadowRoots.set(this, {
        mode: init.mode,
        shadowRoot
      });
      return shadowRoot;
    }
    // </ShadowDOM>

    // <selectors>
    matches(selectors) { return matches(this, selectors); }
    closest(selectors) {
      let parentElement = this;
      const matches = prepareMatch(parentElement, selectors);
      while (parentElement && !matches(parentElement))
        parentElement = parentElement.parentElement;
      return parentElement;
    }
    // </selectors>

    // <insertAdjacent>
    insertAdjacentElement(position, element) {
      const {parentElement} = this;
      switch (position) {
        case 'beforebegin':
          if (parentElement) {
            parentElement.insertBefore(element, this);
            break;
          }
          return null;
        case 'afterbegin':
          this.insertBefore(element, this.firstChild);
          break;
        case 'beforeend':
          this.insertBefore(element, null);
          break;
        case 'afterend':
          if (parentElement) {
            parentElement.insertBefore(element, this.nextSibling);
            break;
          }
          return null;
      }
      return element;
    }

    insertAdjacentHTML(position, html) {
      this.insertAdjacentElement(position, htmlToFragment(this.ownerDocument, html));
    }

    insertAdjacentText(position, text) {
      const node = this.ownerDocument.createTextNode(text);
      this.insertAdjacentElement(position, node);
    }
    // </insertAdjacent>

    cloneNode(deep = false) {
      const {ownerDocument, localName} = this;
      const addNext = next => {
        next.parentNode = parentNode;
        knownAdjacent($next, next);
        $next = next;
      };
      const clone = create(ownerDocument, this, localName);
      let parentNode = clone, $next = clone;
      let {[NEXT]: next, [END]: prev} = this;
      while (next !== prev && (deep || next.nodeType === ATTRIBUTE_NODE)) {
        switch (next.nodeType) {
          case NODE_END:
            knownAdjacent($next, parentNode[END]);
            $next = parentNode[END];
            parentNode = parentNode.parentNode;
            break;
          case ELEMENT_NODE: {
            const node = create(ownerDocument, next, next.localName);
            addNext(node);
            parentNode = node;
            break;
          }
          case ATTRIBUTE_NODE: {
            const attr = next.cloneNode(deep);
            attr.ownerElement = parentNode;
            addNext(attr);
            break;
          }
          case TEXT_NODE:
          case COMMENT_NODE:
          case CDATA_SECTION_NODE:
            addNext(next.cloneNode(deep));
            break;
        }
        next = next[NEXT];
      }
      knownAdjacent($next, clone[END]);
      return clone;
    }

    // <custom>
    toString() {
      const out = [];
      const {[END]: end} = this;
      let next = {[NEXT]: this};
      let isOpened = false;
      do {
        next = next[NEXT];
        switch (next.nodeType) {
          case ATTRIBUTE_NODE: {
            const attr = ' ' + next;
            switch (attr) {
              case ' id':
              case ' class':
              case ' style':
                break;
              default:
                out.push(attr);
            }
            break;
          }
          case NODE_END: {
            const start = next[START];
            if (isOpened) {
              if ('ownerSVGElement' in start)
                out.push(' />');
              else if (isVoid(start))
                out.push(ignoreCase(start) ? '>' : ' />');
              else
                out.push(`></${start.localName}>`);
              isOpened = false;
            }
            else
              out.push(`</${start.localName}>`);
            break;
          }
          case ELEMENT_NODE:
            if (isOpened)
              out.push('>');
            if (next.toString !== this.toString) {
              out.push(next.toString());
              next = next[END];
              isOpened = false;
            }
            else {
              out.push(`<${next.localName}`);
              isOpened = true;
            }
            break;
          case TEXT_NODE:
          case COMMENT_NODE:
          case CDATA_SECTION_NODE:
            out.push((isOpened ? '>' : '') + next);
            isOpened = false;
            break;
        }
      } while (next !== end);
      return out.join('');
    }

    toJSON() {
      const json = [];
      elementAsJSON(this, json);
      return json;
    }
    // </custom>


    /* c8 ignore start */
    getAttributeNS(_, name) { return this.getAttribute(name); }
    getElementsByTagNameNS(_, name) { return this.getElementsByTagName(name); }
    hasAttributeNS(_, name) { return this.hasAttribute(name); }
    removeAttributeNS(_, name) { this.removeAttribute(name); }
    setAttributeNS(_, name, value) { this.setAttribute(name, value); }
    setAttributeNodeNS(attr) { return this.setAttributeNode(attr); }
    /* c8 ignore stop */
  };

  const classNames = new WeakMap;

  const handler = {
    get(target, name) {
      return target[name];
    },
    set(target, name, value) {
      target[name] = value;
      return true;
    }
  };

  /**
   * @implements globalThis.SVGElement
   */
  let SVGElement$1 = class SVGElement extends Element$1 {
    constructor(ownerDocument, localName, ownerSVGElement = null) {
      super(ownerDocument, localName);
      this.ownerSVGElement = ownerSVGElement;
    }

    get className() {
      if (!classNames.has(this))
        classNames.set(this, new Proxy({baseVal: '', animVal: ''}, handler));
      return classNames.get(this);
    }

    /* c8 ignore start */
    set className(value) {
      const {classList} = this;
      classList.clear();
      classList.add(...($String(value).split(/\s+/)));
    }
    /* c8 ignore stop */

    get namespaceURI() {
      return 'http://www.w3.org/2000/svg';
    }

    getAttribute(name) {
      return name === 'class' ?
        [...this.classList].join(' ') :
        super.getAttribute(name);
    }

    setAttribute(name, value) {
      if (name === 'class')
        this.className = value;
      else if (name === 'style') {
        const {className} = this;
        className.baseVal = className.animVal = value;
      }
      super.setAttribute(name, value);
    }
  };

  /* c8 ignore start */
  const illegalConstructor = () => {
    throw new TypeError('Illegal constructor');
  };

  function Attr() { illegalConstructor(); }
  setPrototypeOf(Attr, Attr$1);
  Attr.prototype = Attr$1.prototype;

  function CDATASection() { illegalConstructor(); }
  setPrototypeOf(CDATASection, CDATASection$1);
  CDATASection.prototype = CDATASection$1.prototype;

  function CharacterData() { illegalConstructor(); }
  setPrototypeOf(CharacterData, CharacterData$1);
  CharacterData.prototype = CharacterData$1.prototype;

  function Comment() { illegalConstructor(); }
  setPrototypeOf(Comment, Comment$1);
  Comment.prototype = Comment$1.prototype;

  function DocumentFragment() { illegalConstructor(); }
  setPrototypeOf(DocumentFragment, DocumentFragment$1);
  DocumentFragment.prototype = DocumentFragment$1.prototype;

  function DocumentType() { illegalConstructor(); }
  setPrototypeOf(DocumentType, DocumentType$1);
  DocumentType.prototype = DocumentType$1.prototype;

  function Element() { illegalConstructor(); }
  setPrototypeOf(Element, Element$1);
  Element.prototype = Element$1.prototype;

  function Node() { illegalConstructor(); }
  setPrototypeOf(Node, Node$1);
  Node.prototype = Node$1.prototype;

  function ShadowRoot() { illegalConstructor(); }
  setPrototypeOf(ShadowRoot, ShadowRoot$1);
  ShadowRoot.prototype = ShadowRoot$1.prototype;

  function Text() { illegalConstructor(); }
  setPrototypeOf(Text, Text$1);
  Text.prototype = Text$1.prototype;

  function SVGElement() { illegalConstructor(); }
  setPrototypeOf(SVGElement, SVGElement$1);
  SVGElement.prototype = SVGElement$1.prototype;
  /* c8 ignore stop */

  const Facades = {
    Attr,
    CDATASection,
    CharacterData,
    Comment,
    DocumentFragment,
    DocumentType,
    Element,
    Node,
    ShadowRoot,
    Text,
    SVGElement
  };

  const Level0 = new WeakMap;
  const level0 = {
    get(element, name) {
      return Level0.has(element) && Level0.get(element)[name] || null;
    },
    set(element, name, value) {
      if (!Level0.has(element))
        Level0.set(element, {});
      const handlers = Level0.get(element);
      const type = name.slice(2);
      if (handlers[name])
        element.removeEventListener(type, handlers[name], false);
      if ((handlers[name] = value))
        element.addEventListener(type, value, false);
    }
  };

  /**
   * @implements globalThis.HTMLElement
   */
  let HTMLElement$1 = class HTMLElement extends Element$1 {

    static get observedAttributes() { return []; }

    constructor(ownerDocument = null, localName = '') {
      super(ownerDocument, localName);

      const ownerLess = !ownerDocument;
      let options;

      if (ownerLess) {
        const {constructor: Class} = this;
        if (!Classes.has(Class))
          throw new Error('unable to initialize this Custom Element');
        ({ownerDocument, localName, options} = Classes.get(Class));
      }

      if (ownerDocument[UPGRADE]) {
        const {element, values} = ownerDocument[UPGRADE];
        ownerDocument[UPGRADE] = null;
        for (const [key, value] of values)
          element[key] = value;
        return element;
      }

      if (ownerLess) {
        this.ownerDocument = this[END].ownerDocument = ownerDocument;
        this.localName = localName;
        customElements.set(this, {connected: false});
        if (options.is)
          this.setAttribute('is', options.is);
      }
    }

    /* c8 ignore start */

    /* TODO: what about these?
    offsetHeight
    offsetLeft
    offsetParent
    offsetTop
    offsetWidth
    */

    blur() { this.dispatchEvent(new GlobalEvent('blur')); }
    click() {
      const clickEvent = new GlobalEvent('click', {bubbles: true, cancelable: true});
      clickEvent.button = 0;

      this.dispatchEvent(clickEvent);
    }

    // Boolean getters
    get accessKeyLabel() {
      const {accessKey} = this;
      return accessKey && `Alt+Shift+${accessKey}`;
    }
    get isContentEditable() { return this.hasAttribute('contenteditable'); }

    // Boolean Accessors
    get contentEditable() { return booleanAttribute.get(this, 'contenteditable'); }
    set contentEditable(value) { booleanAttribute.set(this, 'contenteditable', value); }
    get draggable() { return booleanAttribute.get(this, 'draggable'); }
    set draggable(value) { booleanAttribute.set(this, 'draggable', value); }
    get hidden() { return booleanAttribute.get(this, 'hidden'); }
    set hidden(value) { booleanAttribute.set(this, 'hidden', value); }
    get spellcheck() { return booleanAttribute.get(this, 'spellcheck'); }
    set spellcheck(value) { booleanAttribute.set(this, 'spellcheck', value); }

    // String Accessors
    get accessKey() { return stringAttribute.get(this, 'accesskey'); }
    set accessKey(value) { stringAttribute.set(this, 'accesskey', value); }
    get dir() { return stringAttribute.get(this, 'dir'); }
    set dir(value) { stringAttribute.set(this, 'dir', value); }
    get lang() { return stringAttribute.get(this, 'lang'); }
    set lang(value) { stringAttribute.set(this, 'lang', value); }
    get title() { return stringAttribute.get(this, 'title'); }
    set title(value) { stringAttribute.set(this, 'title', value); }

    // DOM Level 0
    get onabort() { return level0.get(this, 'onabort'); }
    set onabort(value) { level0.set(this, 'onabort', value); }

    get onblur() { return level0.get(this, 'onblur'); }
    set onblur(value) { level0.set(this, 'onblur', value); }

    get oncancel() { return level0.get(this, 'oncancel'); }
    set oncancel(value) { level0.set(this, 'oncancel', value); }

    get oncanplay() { return level0.get(this, 'oncanplay'); }
    set oncanplay(value) { level0.set(this, 'oncanplay', value); }

    get oncanplaythrough() { return level0.get(this, 'oncanplaythrough'); }
    set oncanplaythrough(value) { level0.set(this, 'oncanplaythrough', value); }

    get onchange() { return level0.get(this, 'onchange'); }
    set onchange(value) { level0.set(this, 'onchange', value); }

    get onclick() { return level0.get(this, 'onclick'); }
    set onclick(value) { level0.set(this, 'onclick', value); }

    get onclose() { return level0.get(this, 'onclose'); }
    set onclose(value) { level0.set(this, 'onclose', value); }

    get oncontextmenu() { return level0.get(this, 'oncontextmenu'); }
    set oncontextmenu(value) { level0.set(this, 'oncontextmenu', value); }

    get oncuechange() { return level0.get(this, 'oncuechange'); }
    set oncuechange(value) { level0.set(this, 'oncuechange', value); }

    get ondblclick() { return level0.get(this, 'ondblclick'); }
    set ondblclick(value) { level0.set(this, 'ondblclick', value); }

    get ondrag() { return level0.get(this, 'ondrag'); }
    set ondrag(value) { level0.set(this, 'ondrag', value); }

    get ondragend() { return level0.get(this, 'ondragend'); }
    set ondragend(value) { level0.set(this, 'ondragend', value); }

    get ondragenter() { return level0.get(this, 'ondragenter'); }
    set ondragenter(value) { level0.set(this, 'ondragenter', value); }

    get ondragleave() { return level0.get(this, 'ondragleave'); }
    set ondragleave(value) { level0.set(this, 'ondragleave', value); }

    get ondragover() { return level0.get(this, 'ondragover'); }
    set ondragover(value) { level0.set(this, 'ondragover', value); }

    get ondragstart() { return level0.get(this, 'ondragstart'); }
    set ondragstart(value) { level0.set(this, 'ondragstart', value); }

    get ondrop() { return level0.get(this, 'ondrop'); }
    set ondrop(value) { level0.set(this, 'ondrop', value); }

    get ondurationchange() { return level0.get(this, 'ondurationchange'); }
    set ondurationchange(value) { level0.set(this, 'ondurationchange', value); }

    get onemptied() { return level0.get(this, 'onemptied'); }
    set onemptied(value) { level0.set(this, 'onemptied', value); }

    get onended() { return level0.get(this, 'onended'); }
    set onended(value) { level0.set(this, 'onended', value); }

    get onerror() { return level0.get(this, 'onerror'); }
    set onerror(value) { level0.set(this, 'onerror', value); }

    get onfocus() { return level0.get(this, 'onfocus'); }
    set onfocus(value) { level0.set(this, 'onfocus', value); }

    get oninput() { return level0.get(this, 'oninput'); }
    set oninput(value) { level0.set(this, 'oninput', value); }

    get oninvalid() { return level0.get(this, 'oninvalid'); }
    set oninvalid(value) { level0.set(this, 'oninvalid', value); }

    get onkeydown() { return level0.get(this, 'onkeydown'); }
    set onkeydown(value) { level0.set(this, 'onkeydown', value); }

    get onkeypress() { return level0.get(this, 'onkeypress'); }
    set onkeypress(value) { level0.set(this, 'onkeypress', value); }

    get onkeyup() { return level0.get(this, 'onkeyup'); }
    set onkeyup(value) { level0.set(this, 'onkeyup', value); }

    get onload() { return level0.get(this, 'onload'); }
    set onload(value) { level0.set(this, 'onload', value); }

    get onloadeddata() { return level0.get(this, 'onloadeddata'); }
    set onloadeddata(value) { level0.set(this, 'onloadeddata', value); }

    get onloadedmetadata() { return level0.get(this, 'onloadedmetadata'); }
    set onloadedmetadata(value) { level0.set(this, 'onloadedmetadata', value); }

    get onloadstart() { return level0.get(this, 'onloadstart'); }
    set onloadstart(value) { level0.set(this, 'onloadstart', value); }

    get onmousedown() { return level0.get(this, 'onmousedown'); }
    set onmousedown(value) { level0.set(this, 'onmousedown', value); }

    get onmouseenter() { return level0.get(this, 'onmouseenter'); }
    set onmouseenter(value) { level0.set(this, 'onmouseenter', value); }

    get onmouseleave() { return level0.get(this, 'onmouseleave'); }
    set onmouseleave(value) { level0.set(this, 'onmouseleave', value); }

    get onmousemove() { return level0.get(this, 'onmousemove'); }
    set onmousemove(value) { level0.set(this, 'onmousemove', value); }

    get onmouseout() { return level0.get(this, 'onmouseout'); }
    set onmouseout(value) { level0.set(this, 'onmouseout', value); }

    get onmouseover() { return level0.get(this, 'onmouseover'); }
    set onmouseover(value) { level0.set(this, 'onmouseover', value); }

    get onmouseup() { return level0.get(this, 'onmouseup'); }
    set onmouseup(value) { level0.set(this, 'onmouseup', value); }

    get onmousewheel() { return level0.get(this, 'onmousewheel'); }
    set onmousewheel(value) { level0.set(this, 'onmousewheel', value); }

    get onpause() { return level0.get(this, 'onpause'); }
    set onpause(value) { level0.set(this, 'onpause', value); }

    get onplay() { return level0.get(this, 'onplay'); }
    set onplay(value) { level0.set(this, 'onplay', value); }

    get onplaying() { return level0.get(this, 'onplaying'); }
    set onplaying(value) { level0.set(this, 'onplaying', value); }

    get onprogress() { return level0.get(this, 'onprogress'); }
    set onprogress(value) { level0.set(this, 'onprogress', value); }

    get onratechange() { return level0.get(this, 'onratechange'); }
    set onratechange(value) { level0.set(this, 'onratechange', value); }

    get onreset() { return level0.get(this, 'onreset'); }
    set onreset(value) { level0.set(this, 'onreset', value); }

    get onresize() { return level0.get(this, 'onresize'); }
    set onresize(value) { level0.set(this, 'onresize', value); }

    get onscroll() { return level0.get(this, 'onscroll'); }
    set onscroll(value) { level0.set(this, 'onscroll', value); }

    get onseeked() { return level0.get(this, 'onseeked'); }
    set onseeked(value) { level0.set(this, 'onseeked', value); }

    get onseeking() { return level0.get(this, 'onseeking'); }
    set onseeking(value) { level0.set(this, 'onseeking', value); }

    get onselect() { return level0.get(this, 'onselect'); }
    set onselect(value) { level0.set(this, 'onselect', value); }

    get onshow() { return level0.get(this, 'onshow'); }
    set onshow(value) { level0.set(this, 'onshow', value); }

    get onstalled() { return level0.get(this, 'onstalled'); }
    set onstalled(value) { level0.set(this, 'onstalled', value); }

    get onsubmit() { return level0.get(this, 'onsubmit'); }
    set onsubmit(value) { level0.set(this, 'onsubmit', value); }

    get onsuspend() { return level0.get(this, 'onsuspend'); }
    set onsuspend(value) { level0.set(this, 'onsuspend', value); }

    get ontimeupdate() { return level0.get(this, 'ontimeupdate'); }
    set ontimeupdate(value) { level0.set(this, 'ontimeupdate', value); }

    get ontoggle() { return level0.get(this, 'ontoggle'); }
    set ontoggle(value) { level0.set(this, 'ontoggle', value); }

    get onvolumechange() { return level0.get(this, 'onvolumechange'); }
    set onvolumechange(value) { level0.set(this, 'onvolumechange', value); }

    get onwaiting() { return level0.get(this, 'onwaiting'); }
    set onwaiting(value) { level0.set(this, 'onwaiting', value); }

    get onauxclick() { return level0.get(this, 'onauxclick'); }
    set onauxclick(value) { level0.set(this, 'onauxclick', value); }

    get ongotpointercapture() { return level0.get(this, 'ongotpointercapture'); }
    set ongotpointercapture(value) { level0.set(this, 'ongotpointercapture', value); }

    get onlostpointercapture() { return level0.get(this, 'onlostpointercapture'); }
    set onlostpointercapture(value) { level0.set(this, 'onlostpointercapture', value); }

    get onpointercancel() { return level0.get(this, 'onpointercancel'); }
    set onpointercancel(value) { level0.set(this, 'onpointercancel', value); }

    get onpointerdown() { return level0.get(this, 'onpointerdown'); }
    set onpointerdown(value) { level0.set(this, 'onpointerdown', value); }

    get onpointerenter() { return level0.get(this, 'onpointerenter'); }
    set onpointerenter(value) { level0.set(this, 'onpointerenter', value); }

    get onpointerleave() { return level0.get(this, 'onpointerleave'); }
    set onpointerleave(value) { level0.set(this, 'onpointerleave', value); }

    get onpointermove() { return level0.get(this, 'onpointermove'); }
    set onpointermove(value) { level0.set(this, 'onpointermove', value); }

    get onpointerout() { return level0.get(this, 'onpointerout'); }
    set onpointerout(value) { level0.set(this, 'onpointerout', value); }

    get onpointerover() { return level0.get(this, 'onpointerover'); }
    set onpointerover(value) { level0.set(this, 'onpointerover', value); }

    get onpointerup() { return level0.get(this, 'onpointerup'); }
    set onpointerup(value) { level0.set(this, 'onpointerup', value); }
    /* c8 ignore stop */

  };

  const tagName$h = 'template';

  /**
   * @implements globalThis.HTMLTemplateElement
   */
  class HTMLTemplateElement extends HTMLElement$1 {
    constructor(ownerDocument) {
      super(ownerDocument, tagName$h);
      const content = this.ownerDocument.createDocumentFragment();
      (this[CONTENT] = content)[PRIVATE] = this;
    }

    get content() {
      if (this.hasChildNodes() && !this[CONTENT].hasChildNodes()) {
        for (const node of this.childNodes)
          this[CONTENT].appendChild(node.cloneNode(true));
      }
      return this[CONTENT];
    }
  }

  registerHTMLClass(tagName$h, HTMLTemplateElement);

  /**
   * @implements globalThis.HTMLHtmlElement
   */
  class HTMLHtmlElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'html') {
      super(ownerDocument, localName);
    }
  }

  const {toString} = HTMLElement$1.prototype;

  class TextElement extends HTMLElement$1 {

    get innerHTML() { return this.textContent; }
    set innerHTML(html) { this.textContent = html; }

    toString() {
      const outerHTML = toString.call(this.cloneNode());
      return outerHTML.replace('><', () => `>${this.textContent}<`);
    }
  }

  const tagName$g = 'script';

  /**
   * @implements globalThis.HTMLScriptElement
   */
  class HTMLScriptElement extends TextElement {
    constructor(ownerDocument, localName = tagName$g) {
      super(ownerDocument, localName);
    }

    get type() {
      return stringAttribute.get(this, 'type');
    }
    set type(value) {
      stringAttribute.set(this, 'type', value);
    }

    get src() {
      return stringAttribute.get(this, 'src');
    }
    set src(value) {
      stringAttribute.set(this, 'src', value);
    }

    get defer() {
      return booleanAttribute.get(this, 'defer');
    }

    set defer(value) {
      booleanAttribute.set(this, 'defer', value);
    }

    get crossOrigin() {
      return stringAttribute.get(this, 'crossorigin');
    }
    set crossOrigin(value) {
      stringAttribute.set(this, 'crossorigin', value);
    }

    get nomodule() {
      return booleanAttribute.get(this, 'nomodule');
    }
    set nomodule(value) {
      booleanAttribute.set(this, 'nomodule', value);
    }

    get referrerPolicy() {
      return stringAttribute.get(this, 'referrerpolicy');
    }
    set referrerPolicy(value) {
      stringAttribute.set(this, 'referrerpolicy', value);
    }

    get nonce() {
      return stringAttribute.get(this, 'nonce');
    }
    set nonce(value) {
      stringAttribute.set(this, 'nonce', value);
    }

    get async() {
      return booleanAttribute.get(this, 'async');
    }
    set async(value) {
      booleanAttribute.set(this, 'async', value);
    }

    get text() { return this.textContent; }
    set text(content) { this.textContent = content; }
  }

  registerHTMLClass(tagName$g, HTMLScriptElement);

  /**
   * @implements globalThis.HTMLFrameElement
   */
  class HTMLFrameElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'frame') {
      super(ownerDocument, localName);
    }
  }

  const tagName$f = 'iframe';

  /**
   * @implements globalThis.HTMLIFrameElement
   */
  class HTMLIFrameElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$f) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcdoc() { return stringAttribute.get(this, "srcdoc"); }
    set srcdoc(value) { stringAttribute.set(this, "srcdoc", value); }

    get name() { return stringAttribute.get(this, "name"); }
    set name(value) { stringAttribute.set(this, "name", value); }

    get allow() { return stringAttribute.get(this, "allow"); }
    set allow(value) { stringAttribute.set(this, "allow", value); }

    get allowFullscreen() { return booleanAttribute.get(this, "allowfullscreen"); }
    set allowFullscreen(value) { booleanAttribute.set(this, "allowfullscreen", value); }
    
    get referrerPolicy() { return stringAttribute.get(this, "referrerpolicy"); }
    set referrerPolicy(value) { stringAttribute.set(this, "referrerpolicy", value); }
    
    get loading() { return stringAttribute.get(this, "loading"); }
    set loading(value) { stringAttribute.set(this, "loading", value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$f, HTMLIFrameElement);

  /**
   * @implements globalThis.HTMLObjectElement
   */
  class HTMLObjectElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'object') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLHeadElement
   */
  class HTMLHeadElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'head') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLBodyElement
   */
  class HTMLBodyElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'body') {
      super(ownerDocument, localName);
    }
  }

  var CSSStyleDeclaration = {};

  var parse$1 = {};

  var CSSStyleSheet = {};

  var StyleSheet = {};

  //.CommonJS
  var CSSOM$c = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-stylesheet-interface
   */
  CSSOM$c.StyleSheet = function StyleSheet() {
  	this.parentStyleSheet = null;
  };


  //.CommonJS
  StyleSheet.StyleSheet = CSSOM$c.StyleSheet;

  var CSSStyleRule = {};

  var CSSRule = {};

  //.CommonJS
  var CSSOM$b = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-cssrule-interface
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSRule
   */
  CSSOM$b.CSSRule = function CSSRule() {
  	this.parentRule = null;
  	this.parentStyleSheet = null;
  };

  CSSOM$b.CSSRule.UNKNOWN_RULE = 0;                 // obsolete
  CSSOM$b.CSSRule.STYLE_RULE = 1;
  CSSOM$b.CSSRule.CHARSET_RULE = 2;                 // obsolete
  CSSOM$b.CSSRule.IMPORT_RULE = 3;
  CSSOM$b.CSSRule.MEDIA_RULE = 4;
  CSSOM$b.CSSRule.FONT_FACE_RULE = 5;
  CSSOM$b.CSSRule.PAGE_RULE = 6;
  CSSOM$b.CSSRule.KEYFRAMES_RULE = 7;
  CSSOM$b.CSSRule.KEYFRAME_RULE = 8;
  CSSOM$b.CSSRule.MARGIN_RULE = 9;
  CSSOM$b.CSSRule.NAMESPACE_RULE = 10;
  CSSOM$b.CSSRule.COUNTER_STYLE_RULE = 11;
  CSSOM$b.CSSRule.SUPPORTS_RULE = 12;
  CSSOM$b.CSSRule.DOCUMENT_RULE = 13;
  CSSOM$b.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
  CSSOM$b.CSSRule.VIEWPORT_RULE = 15;
  CSSOM$b.CSSRule.REGION_STYLE_RULE = 16;


  CSSOM$b.CSSRule.prototype = {
  	constructor: CSSOM$b.CSSRule
  	//FIXME
  };


  //.CommonJS
  CSSRule.CSSRule = CSSOM$b.CSSRule;

  var hasRequiredCSSStyleRule;

  function requireCSSStyleRule () {
  	if (hasRequiredCSSStyleRule) return CSSStyleRule;
  	hasRequiredCSSStyleRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  		CSSRule: CSSRule.CSSRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#cssstylerule
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleRule
  	 */
  	CSSOM.CSSStyleRule = function CSSStyleRule() {
  		CSSOM.CSSRule.call(this);
  		this.selectorText = "";
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
  	CSSOM.CSSStyleRule.prototype.type = 1;

  	Object.defineProperty(CSSOM.CSSStyleRule.prototype, "cssText", {
  		get: function() {
  			var text;
  			if (this.selectorText) {
  				text = this.selectorText + " {" + this.style.cssText + "}";
  			} else {
  				text = "";
  			}
  			return text;
  		},
  		set: function(cssText) {
  			var rule = CSSOM.CSSStyleRule.parse(cssText);
  			this.style = rule.style;
  			this.selectorText = rule.selectorText;
  		}
  	});


  	/**
  	 * NON-STANDARD
  	 * lightweight version of parse.js.
  	 * @param {string} ruleText
  	 * @return CSSStyleRule
  	 */
  	CSSOM.CSSStyleRule.parse = function(ruleText) {
  		var i = 0;
  		var state = "selector";
  		var index;
  		var j = i;
  		var buffer = "";

  		var SIGNIFICANT_WHITESPACE = {
  			"selector": true,
  			"value": true
  		};

  		var styleRule = new CSSOM.CSSStyleRule();
  		var name, priority="";

  		for (var character; (character = ruleText.charAt(i)); i++) {

  			switch (character) {

  			case " ":
  			case "\t":
  			case "\r":
  			case "\n":
  			case "\f":
  				if (SIGNIFICANT_WHITESPACE[state]) {
  					// Squash 2 or more white-spaces in the row into 1
  					switch (ruleText.charAt(i - 1)) {
  						case " ":
  						case "\t":
  						case "\r":
  						case "\n":
  						case "\f":
  							break;
  						default:
  							buffer += " ";
  							break;
  					}
  				}
  				break;

  			// String
  			case '"':
  				j = i + 1;
  				index = ruleText.indexOf('"', j) + 1;
  				if (!index) {
  					throw '" is missing';
  				}
  				buffer += ruleText.slice(i, index);
  				i = index - 1;
  				break;

  			case "'":
  				j = i + 1;
  				index = ruleText.indexOf("'", j) + 1;
  				if (!index) {
  					throw "' is missing";
  				}
  				buffer += ruleText.slice(i, index);
  				i = index - 1;
  				break;

  			// Comment
  			case "/":
  				if (ruleText.charAt(i + 1) === "*") {
  					i += 2;
  					index = ruleText.indexOf("*/", i);
  					if (index === -1) {
  						throw new SyntaxError("Missing */");
  					} else {
  						i = index + 1;
  					}
  				} else {
  					buffer += character;
  				}
  				break;

  			case "{":
  				if (state === "selector") {
  					styleRule.selectorText = buffer.trim();
  					buffer = "";
  					state = "name";
  				}
  				break;

  			case ":":
  				if (state === "name") {
  					name = buffer.trim();
  					buffer = "";
  					state = "value";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "!":
  				if (state === "value" && ruleText.indexOf("!important", i) === i) {
  					priority = "important";
  					i += "important".length;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ";":
  				if (state === "value") {
  					styleRule.style.setProperty(name, buffer.trim(), priority);
  					priority = "";
  					buffer = "";
  					state = "name";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "}":
  				if (state === "value") {
  					styleRule.style.setProperty(name, buffer.trim(), priority);
  					priority = "";
  					buffer = "";
  				} else if (state === "name") {
  					break;
  				} else {
  					buffer += character;
  				}
  				state = "selector";
  				break;

  			default:
  				buffer += character;
  				break;

  			}
  		}

  		return styleRule;

  	};


  	//.CommonJS
  	CSSStyleRule.CSSStyleRule = CSSOM.CSSStyleRule;
  	///CommonJS
  	return CSSStyleRule;
  }

  var hasRequiredCSSStyleSheet;

  function requireCSSStyleSheet () {
  	if (hasRequiredCSSStyleSheet) return CSSStyleSheet;
  	hasRequiredCSSStyleSheet = 1;
  	//.CommonJS
  	var CSSOM = {
  		StyleSheet: StyleSheet.StyleSheet,
  		CSSStyleRule: requireCSSStyleRule().CSSStyleRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet
  	 */
  	CSSOM.CSSStyleSheet = function CSSStyleSheet() {
  		CSSOM.StyleSheet.call(this);
  		this.cssRules = [];
  	};


  	CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
  	CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;


  	/**
  	 * Used to insert a new rule into the style sheet. The new rule now becomes part of the cascade.
  	 *
  	 *   sheet = new Sheet("body {margin: 0}")
  	 *   sheet.toString()
  	 *   -> "body{margin:0;}"
  	 *   sheet.insertRule("img {border: none}", 0)
  	 *   -> 0
  	 *   sheet.toString()
  	 *   -> "img{border:none;}body{margin:0;}"
  	 *
  	 * @param {string} rule
  	 * @param {number} index
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-insertRule
  	 * @return {number} The index within the style sheet's rule collection of the newly inserted rule.
  	 */
  	CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
  		if (index < 0 || index > this.cssRules.length) {
  			throw new RangeError("INDEX_SIZE_ERR");
  		}
  		var cssRule = CSSOM.parse(rule).cssRules[0];
  		cssRule.parentStyleSheet = this;
  		this.cssRules.splice(index, 0, cssRule);
  		return index;
  	};


  	/**
  	 * Used to delete a rule from the style sheet.
  	 *
  	 *   sheet = new Sheet("img{border:none} body{margin:0}")
  	 *   sheet.toString()
  	 *   -> "img{border:none;}body{margin:0;}"
  	 *   sheet.deleteRule(0)
  	 *   sheet.toString()
  	 *   -> "body{margin:0;}"
  	 *
  	 * @param {number} index within the style sheet's rule list of the rule to remove.
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-deleteRule
  	 */
  	CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
  		if (index < 0 || index >= this.cssRules.length) {
  			throw new RangeError("INDEX_SIZE_ERR");
  		}
  		this.cssRules.splice(index, 1);
  	};


  	/**
  	 * NON-STANDARD
  	 * @return {string} serialize stylesheet
  	 */
  	CSSOM.CSSStyleSheet.prototype.toString = function() {
  		var result = "";
  		var rules = this.cssRules;
  		for (var i=0; i<rules.length; i++) {
  			result += rules[i].cssText + "\n";
  		}
  		return result;
  	};


  	//.CommonJS
  	CSSStyleSheet.CSSStyleSheet = CSSOM.CSSStyleSheet;
  	CSSOM.parse = requireParse().parse; // Cannot be included sooner due to the mutual dependency between parse.js and CSSStyleSheet.js
  	///CommonJS
  	return CSSStyleSheet;
  }

  var CSSImportRule = {};

  var MediaList = {};

  //.CommonJS
  var CSSOM$a = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-medialist-interface
   */
  CSSOM$a.MediaList = function MediaList(){
  	this.length = 0;
  };

  CSSOM$a.MediaList.prototype = {

  	constructor: CSSOM$a.MediaList,

  	/**
  	 * @return {string}
  	 */
  	get mediaText() {
  		return Array.prototype.join.call(this, ", ");
  	},

  	/**
  	 * @param {string} value
  	 */
  	set mediaText(value) {
  		var values = value.split(",");
  		var length = this.length = values.length;
  		for (var i=0; i<length; i++) {
  			this[i] = values[i].trim();
  		}
  	},

  	/**
  	 * @param {string} medium
  	 */
  	appendMedium: function(medium) {
  		if (Array.prototype.indexOf.call(this, medium) === -1) {
  			this[this.length] = medium;
  			this.length++;
  		}
  	},

  	/**
  	 * @param {string} medium
  	 */
  	deleteMedium: function(medium) {
  		var index = Array.prototype.indexOf.call(this, medium);
  		if (index !== -1) {
  			Array.prototype.splice.call(this, index, 1);
  		}
  	}

  };


  //.CommonJS
  MediaList.MediaList = CSSOM$a.MediaList;

  var hasRequiredCSSImportRule;

  function requireCSSImportRule () {
  	if (hasRequiredCSSImportRule) return CSSImportRule;
  	hasRequiredCSSImportRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSRule: CSSRule.CSSRule,
  		CSSStyleSheet: requireCSSStyleSheet().CSSStyleSheet,
  		MediaList: MediaList.MediaList
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#cssimportrule
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSImportRule
  	 */
  	CSSOM.CSSImportRule = function CSSImportRule() {
  		CSSOM.CSSRule.call(this);
  		this.href = "";
  		this.media = new CSSOM.MediaList();
  		this.styleSheet = new CSSOM.CSSStyleSheet();
  	};

  	CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
  	CSSOM.CSSImportRule.prototype.type = 3;

  	Object.defineProperty(CSSOM.CSSImportRule.prototype, "cssText", {
  	  get: function() {
  	    var mediaText = this.media.mediaText;
  	    return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
  	  },
  	  set: function(cssText) {
  	    var i = 0;

  	    /**
  	     * @import url(partial.css) screen, handheld;
  	     *        ||               |
  	     *        after-import     media
  	     *         |
  	     *         url
  	     */
  	    var state = '';

  	    var buffer = '';
  	    var index;
  	    for (var character; (character = cssText.charAt(i)); i++) {

  	      switch (character) {
  	        case ' ':
  	        case '\t':
  	        case '\r':
  	        case '\n':
  	        case '\f':
  	          if (state === 'after-import') {
  	            state = 'url';
  	          } else {
  	            buffer += character;
  	          }
  	          break;

  	        case '@':
  	          if (!state && cssText.indexOf('@import', i) === i) {
  	            state = 'after-import';
  	            i += 'import'.length;
  	            buffer = '';
  	          }
  	          break;

  	        case 'u':
  	          if (state === 'url' && cssText.indexOf('url(', i) === i) {
  	            index = cssText.indexOf(')', i + 1);
  	            if (index === -1) {
  	              throw i + ': ")" not found';
  	            }
  	            i += 'url('.length;
  	            var url = cssText.slice(i, index);
  	            if (url[0] === url[url.length - 1]) {
  	              if (url[0] === '"' || url[0] === "'") {
  	                url = url.slice(1, -1);
  	              }
  	            }
  	            this.href = url;
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case '"':
  	          if (state === 'url') {
  	            index = cssText.indexOf('"', i + 1);
  	            if (!index) {
  	              throw i + ": '\"' not found";
  	            }
  	            this.href = cssText.slice(i + 1, index);
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case "'":
  	          if (state === 'url') {
  	            index = cssText.indexOf("'", i + 1);
  	            if (!index) {
  	              throw i + ': "\'" not found';
  	            }
  	            this.href = cssText.slice(i + 1, index);
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case ';':
  	          if (state === 'media') {
  	            if (buffer) {
  	              this.media.mediaText = buffer.trim();
  	            }
  	          }
  	          break;

  	        default:
  	          if (state === 'media') {
  	            buffer += character;
  	          }
  	          break;
  	      }
  	    }
  	  }
  	});


  	//.CommonJS
  	CSSImportRule.CSSImportRule = CSSOM.CSSImportRule;
  	///CommonJS
  	return CSSImportRule;
  }

  var CSSGroupingRule = {};

  //.CommonJS
  var CSSOM$9 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://drafts.csswg.org/cssom/#the-cssgroupingrule-interface
   */
  CSSOM$9.CSSGroupingRule = function CSSGroupingRule() {
  	CSSOM$9.CSSRule.call(this);
  	this.cssRules = [];
  };

  CSSOM$9.CSSGroupingRule.prototype = new CSSOM$9.CSSRule();
  CSSOM$9.CSSGroupingRule.prototype.constructor = CSSOM$9.CSSGroupingRule;


  /**
   * Used to insert a new CSS rule to a list of CSS rules.
   *
   * @example
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}"
   *   cssGroupingRule.insertRule("img{border:none;}", 1)
   *   -> 1
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}img{border:none;}"
   *
   * @param {string} rule
   * @param {number} [index]
   * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-insertrule
   * @return {number} The index within the grouping rule's collection of the newly inserted rule.
   */
   CSSOM$9.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
  	if (index < 0 || index > this.cssRules.length) {
  		throw new RangeError("INDEX_SIZE_ERR");
  	}
  	var cssRule = CSSOM$9.parse(rule).cssRules[0];
  	cssRule.parentRule = this;
  	this.cssRules.splice(index, 0, cssRule);
  	return index;
  };

  /**
   * Used to delete a rule from the grouping rule.
   *
   *   cssGroupingRule.cssText
   *   -> "img{border:none;}body{margin:0;}"
   *   cssGroupingRule.deleteRule(0)
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}"
   *
   * @param {number} index within the grouping rule's rule list of the rule to remove.
   * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-deleterule
   */
   CSSOM$9.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
  	if (index < 0 || index >= this.cssRules.length) {
  		throw new RangeError("INDEX_SIZE_ERR");
  	}
  	this.cssRules.splice(index, 1)[0].parentRule = null;
  };

  //.CommonJS
  CSSGroupingRule.CSSGroupingRule = CSSOM$9.CSSGroupingRule;

  var CSSMediaRule = {};

  var CSSConditionRule = {};

  //.CommonJS
  var CSSOM$8 = {
    CSSRule: CSSRule.CSSRule,
    CSSGroupingRule: CSSGroupingRule.CSSGroupingRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://www.w3.org/TR/css-conditional-3/#the-cssconditionrule-interface
   */
  CSSOM$8.CSSConditionRule = function CSSConditionRule() {
    CSSOM$8.CSSGroupingRule.call(this);
    this.cssRules = [];
  };

  CSSOM$8.CSSConditionRule.prototype = new CSSOM$8.CSSGroupingRule();
  CSSOM$8.CSSConditionRule.prototype.constructor = CSSOM$8.CSSConditionRule;
  CSSOM$8.CSSConditionRule.prototype.conditionText = '';
  CSSOM$8.CSSConditionRule.prototype.cssText = '';

  //.CommonJS
  CSSConditionRule.CSSConditionRule = CSSOM$8.CSSConditionRule;

  //.CommonJS
  var CSSOM$7 = {
  	CSSRule: CSSRule.CSSRule,
  	CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
  	CSSConditionRule: CSSConditionRule.CSSConditionRule,
  	MediaList: MediaList.MediaList
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#cssmediarule
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSMediaRule
   */
  CSSOM$7.CSSMediaRule = function CSSMediaRule() {
  	CSSOM$7.CSSConditionRule.call(this);
  	this.media = new CSSOM$7.MediaList();
  };

  CSSOM$7.CSSMediaRule.prototype = new CSSOM$7.CSSConditionRule();
  CSSOM$7.CSSMediaRule.prototype.constructor = CSSOM$7.CSSMediaRule;
  CSSOM$7.CSSMediaRule.prototype.type = 4;

  // https://opensource.apple.com/source/WebCore/WebCore-7611.1.21.161.3/css/CSSMediaRule.cpp
  Object.defineProperties(CSSOM$7.CSSMediaRule.prototype, {
    "conditionText": {
      get: function() {
        return this.media.mediaText;
      },
      set: function(value) {
        this.media.mediaText = value;
      },
      configurable: true,
      enumerable: true
    },
    "cssText": {
      get: function() {
        var cssTexts = [];
        for (var i=0, length=this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
      },
      configurable: true,
      enumerable: true
    }
  });


  //.CommonJS
  CSSMediaRule.CSSMediaRule = CSSOM$7.CSSMediaRule;

  var CSSSupportsRule = {};

  //.CommonJS
  var CSSOM$6 = {
    CSSRule: CSSRule.CSSRule,
    CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
    CSSConditionRule: CSSConditionRule.CSSConditionRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://drafts.csswg.org/css-conditional-3/#the-csssupportsrule-interface
   */
  CSSOM$6.CSSSupportsRule = function CSSSupportsRule() {
    CSSOM$6.CSSConditionRule.call(this);
  };

  CSSOM$6.CSSSupportsRule.prototype = new CSSOM$6.CSSConditionRule();
  CSSOM$6.CSSSupportsRule.prototype.constructor = CSSOM$6.CSSSupportsRule;
  CSSOM$6.CSSSupportsRule.prototype.type = 12;

  Object.defineProperty(CSSOM$6.CSSSupportsRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];

      for (var i = 0, length = this.cssRules.length; i < length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
      }

      return "@supports " + this.conditionText + " {" + cssTexts.join("") + "}";
    }
  });

  //.CommonJS
  CSSSupportsRule.CSSSupportsRule = CSSOM$6.CSSSupportsRule;

  var CSSFontFaceRule = {};

  var hasRequiredCSSFontFaceRule;

  function requireCSSFontFaceRule () {
  	if (hasRequiredCSSFontFaceRule) return CSSFontFaceRule;
  	hasRequiredCSSFontFaceRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  		CSSRule: CSSRule.CSSRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#css-font-face-rule
  	 */
  	CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
  		CSSOM.CSSRule.call(this);
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
  	CSSOM.CSSFontFaceRule.prototype.type = 5;
  	//FIXME
  	//CSSOM.CSSFontFaceRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  	//CSSOM.CSSFontFaceRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  	// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSFontFaceRule.cpp
  	Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, "cssText", {
  	  get: function() {
  	    return "@font-face {" + this.style.cssText + "}";
  	  }
  	});


  	//.CommonJS
  	CSSFontFaceRule.CSSFontFaceRule = CSSOM.CSSFontFaceRule;
  	///CommonJS
  	return CSSFontFaceRule;
  }

  var CSSHostRule = {};

  //.CommonJS
  var CSSOM$5 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/shadow-dom/#host-at-rule
   */
  CSSOM$5.CSSHostRule = function CSSHostRule() {
  	CSSOM$5.CSSRule.call(this);
  	this.cssRules = [];
  };

  CSSOM$5.CSSHostRule.prototype = new CSSOM$5.CSSRule();
  CSSOM$5.CSSHostRule.prototype.constructor = CSSOM$5.CSSHostRule;
  CSSOM$5.CSSHostRule.prototype.type = 1001;
  //FIXME
  //CSSOM.CSSHostRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSHostRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  Object.defineProperty(CSSOM$5.CSSHostRule.prototype, "cssText", {
  	get: function() {
  		var cssTexts = [];
  		for (var i=0, length=this.cssRules.length; i < length; i++) {
  			cssTexts.push(this.cssRules[i].cssText);
  		}
  		return "@host {" + cssTexts.join("") + "}";
  	}
  });


  //.CommonJS
  CSSHostRule.CSSHostRule = CSSOM$5.CSSHostRule;

  var CSSKeyframeRule = {};

  var hasRequiredCSSKeyframeRule;

  function requireCSSKeyframeRule () {
  	if (hasRequiredCSSKeyframeRule) return CSSKeyframeRule;
  	hasRequiredCSSKeyframeRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSRule: CSSRule.CSSRule,
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframeRule
  	 */
  	CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
  		CSSOM.CSSRule.call(this);
  		this.keyText = '';
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
  	CSSOM.CSSKeyframeRule.prototype.type = 8;
  	//FIXME
  	//CSSOM.CSSKeyframeRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  	//CSSOM.CSSKeyframeRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  	// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframeRule.cpp
  	Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, "cssText", {
  	  get: function() {
  	    return this.keyText + " {" + this.style.cssText + "} ";
  	  }
  	});


  	//.CommonJS
  	CSSKeyframeRule.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
  	///CommonJS
  	return CSSKeyframeRule;
  }

  var CSSKeyframesRule = {};

  //.CommonJS
  var CSSOM$4 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframesRule
   */
  CSSOM$4.CSSKeyframesRule = function CSSKeyframesRule() {
  	CSSOM$4.CSSRule.call(this);
  	this.name = '';
  	this.cssRules = [];
  };

  CSSOM$4.CSSKeyframesRule.prototype = new CSSOM$4.CSSRule();
  CSSOM$4.CSSKeyframesRule.prototype.constructor = CSSOM$4.CSSKeyframesRule;
  CSSOM$4.CSSKeyframesRule.prototype.type = 7;
  //FIXME
  //CSSOM.CSSKeyframesRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSKeyframesRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  // http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframesRule.cpp
  Object.defineProperty(CSSOM$4.CSSKeyframesRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i < length; i++) {
        cssTexts.push("  " + this.cssRules[i].cssText);
      }
      return "@" + (this._vendorPrefix || '') + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
    }
  });


  //.CommonJS
  CSSKeyframesRule.CSSKeyframesRule = CSSOM$4.CSSKeyframesRule;

  var CSSValueExpression = {};

  var CSSValue = {};

  //.CommonJS
  var CSSOM$3 = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
   *
   * TODO: add if needed
   */
  CSSOM$3.CSSValue = function CSSValue() {
  };

  CSSOM$3.CSSValue.prototype = {
  	constructor: CSSOM$3.CSSValue,

  	// @see: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
  	set cssText(text) {
  		var name = this._getConstructorName();

  		throw new Error('DOMException: property "cssText" of "' + name + '" is readonly and can not be replaced with "' + text + '"!');
  	},

  	get cssText() {
  		var name = this._getConstructorName();

  		throw new Error('getter "cssText" of "' + name + '" is not implemented!');
  	},

  	_getConstructorName: function() {
  		var s = this.constructor.toString(),
  				c = s.match(/function\s([^\(]+)/),
  				name = c[1];

  		return name;
  	}
  };


  //.CommonJS
  CSSValue.CSSValue = CSSOM$3.CSSValue;

  //.CommonJS
  var CSSOM$2 = {
  	CSSValue: CSSValue.CSSValue
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://msdn.microsoft.com/en-us/library/ms537634(v=vs.85).aspx
   *
   */
  CSSOM$2.CSSValueExpression = function CSSValueExpression(token, idx) {
  	this._token = token;
  	this._idx = idx;
  };

  CSSOM$2.CSSValueExpression.prototype = new CSSOM$2.CSSValue();
  CSSOM$2.CSSValueExpression.prototype.constructor = CSSOM$2.CSSValueExpression;

  /**
   * parse css expression() value
   *
   * @return {Object}
   *         - error:
   *         or
   *         - idx:
   *         - expression:
   *
   * Example:
   *
   * .selector {
   *		zoom: expression(documentElement.clientWidth > 1000 ? '1000px' : 'auto');
   * }
   */
  CSSOM$2.CSSValueExpression.prototype.parse = function() {
  	var token = this._token,
  			idx = this._idx;

  	var character = '',
  			expression = '',
  			error = '',
  			info,
  			paren = [];


  	for (; ; ++idx) {
  		character = token.charAt(idx);

  		// end of token
  		if (character === '') {
  			error = 'css expression error: unfinished expression!';
  			break;
  		}

  		switch(character) {
  			case '(':
  				paren.push(character);
  				expression += character;
  				break;

  			case ')':
  				paren.pop(character);
  				expression += character;
  				break;

  			case '/':
  				if ((info = this._parseJSComment(token, idx))) { // comment?
  					if (info.error) {
  						error = 'css expression error: unfinished comment in expression!';
  					} else {
  						idx = info.idx;
  						// ignore the comment
  					}
  				} else if ((info = this._parseJSRexExp(token, idx))) { // regexp
  					idx = info.idx;
  					expression += info.text;
  				} else { // other
  					expression += character;
  				}
  				break;

  			case "'":
  			case '"':
  				info = this._parseJSString(token, idx, character);
  				if (info) { // string
  					idx = info.idx;
  					expression += info.text;
  				} else {
  					expression += character;
  				}
  				break;

  			default:
  				expression += character;
  				break;
  		}

  		if (error) {
  			break;
  		}

  		// end of expression
  		if (paren.length === 0) {
  			break;
  		}
  	}

  	var ret;
  	if (error) {
  		ret = {
  			error: error
  		};
  	} else {
  		ret = {
  			idx: idx,
  			expression: expression
  		};
  	}

  	return ret;
  };


  /**
   *
   * @return {Object|false}
   *          - idx:
   *          - text:
   *          or
   *          - error:
   *          or
   *          false
   *
   */
  CSSOM$2.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
  	var nextChar = token.charAt(idx + 1),
  			text;

  	if (nextChar === '/' || nextChar === '*') {
  		var startIdx = idx,
  				endIdx,
  				commentEndChar;

  		if (nextChar === '/') { // line comment
  			commentEndChar = '\n';
  		} else if (nextChar === '*') { // block comment
  			commentEndChar = '*/';
  		}

  		endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
  		if (endIdx !== -1) {
  			endIdx = endIdx + commentEndChar.length - 1;
  			text = token.substring(idx, endIdx + 1);
  			return {
  				idx: endIdx,
  				text: text
  			};
  		} else {
  			var error = 'css expression error: unfinished comment in expression!';
  			return {
  				error: error
  			};
  		}
  	} else {
  		return false;
  	}
  };


  /**
   *
   * @return {Object|false}
   *					- idx:
   *					- text:
   *					or 
   *					false
   *
   */
  CSSOM$2.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
  	var endIdx = this._findMatchedIdx(token, idx, sep),
  			text;

  	if (endIdx === -1) {
  		return false;
  	} else {
  		text = token.substring(idx, endIdx + sep.length);

  		return {
  			idx: endIdx,
  			text: text
  		};
  	}
  };


  /**
   * parse regexp in css expression
   *
   * @return {Object|false}
   *				- idx:
   *				- regExp:
   *				or 
   *				false
   */

  /*

  all legal RegExp
   
  /a/
  (/a/)
  [/a/]
  [12, /a/]

  !/a/

  +/a/
  -/a/
  * /a/
  / /a/
  %/a/

  ===/a/
  !==/a/
  ==/a/
  !=/a/
  >/a/
  >=/a/
  </a/
  <=/a/

  &/a/
  |/a/
  ^/a/
  ~/a/
  <</a/
  >>/a/
  >>>/a/

  &&/a/
  ||/a/
  ?/a/
  =/a/
  ,/a/

  		delete /a/
  				in /a/
  instanceof /a/
  				new /a/
  		typeof /a/
  			void /a/

  */
  CSSOM$2.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
  	var before = token.substring(0, idx).replace(/\s+$/, ""),
  			legalRegx = [
  				/^$/,
  				/\($/,
  				/\[$/,
  				/\!$/,
  				/\+$/,
  				/\-$/,
  				/\*$/,
  				/\/\s+/,
  				/\%$/,
  				/\=$/,
  				/\>$/,
  				/<$/,
  				/\&$/,
  				/\|$/,
  				/\^$/,
  				/\~$/,
  				/\?$/,
  				/\,$/,
  				/delete$/,
  				/in$/,
  				/instanceof$/,
  				/new$/,
  				/typeof$/,
  				/void$/
  			];

  	var isLegal = legalRegx.some(function(reg) {
  		return reg.test(before);
  	});

  	if (!isLegal) {
  		return false;
  	} else {
  		var sep = '/';

  		// same logic as string
  		return this._parseJSString(token, idx, sep);
  	}
  };


  /**
   *
   * find next sep(same line) index in `token`
   *
   * @return {Number}
   *
   */
  CSSOM$2.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
  	var startIdx = idx,
  			endIdx;

  	var NOT_FOUND = -1;

  	while(true) {
  		endIdx = token.indexOf(sep, startIdx + 1);

  		if (endIdx === -1) { // not found
  			endIdx = NOT_FOUND;
  			break;
  		} else {
  			var text = token.substring(idx + 1, endIdx),
  					matched = text.match(/\\+$/);
  			if (!matched || matched[0] % 2 === 0) { // not escaped
  				break;
  			} else {
  				startIdx = endIdx;
  			}
  		}
  	}

  	// boundary must be in the same line(js sting or regexp)
  	var nextNewLineIdx = token.indexOf('\n', idx + 1);
  	if (nextNewLineIdx < endIdx) {
  		endIdx = NOT_FOUND;
  	}


  	return endIdx;
  };




  //.CommonJS
  CSSValueExpression.CSSValueExpression = CSSOM$2.CSSValueExpression;

  var CSSDocumentRule = {};

  var MatcherList = {};

  //.CommonJS
  var CSSOM$1 = {};
  ///CommonJS


  /**
   * @constructor
   * @see https://developer.mozilla.org/en/CSS/@-moz-document
   */
  CSSOM$1.MatcherList = function MatcherList(){
      this.length = 0;
  };

  CSSOM$1.MatcherList.prototype = {

      constructor: CSSOM$1.MatcherList,

      /**
       * @return {string}
       */
      get matcherText() {
          return Array.prototype.join.call(this, ", ");
      },

      /**
       * @param {string} value
       */
      set matcherText(value) {
          // just a temporary solution, actually it may be wrong by just split the value with ',', because a url can include ','.
          var values = value.split(",");
          var length = this.length = values.length;
          for (var i=0; i<length; i++) {
              this[i] = values[i].trim();
          }
      },

      /**
       * @param {string} matcher
       */
      appendMatcher: function(matcher) {
          if (Array.prototype.indexOf.call(this, matcher) === -1) {
              this[this.length] = matcher;
              this.length++;
          }
      },

      /**
       * @param {string} matcher
       */
      deleteMatcher: function(matcher) {
          var index = Array.prototype.indexOf.call(this, matcher);
          if (index !== -1) {
              Array.prototype.splice.call(this, index, 1);
          }
      }

  };


  //.CommonJS
  MatcherList.MatcherList = CSSOM$1.MatcherList;

  //.CommonJS
  var CSSOM = {
      CSSRule: CSSRule.CSSRule,
      MatcherList: MatcherList.MatcherList
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://developer.mozilla.org/en/CSS/@-moz-document
   */
  CSSOM.CSSDocumentRule = function CSSDocumentRule() {
      CSSOM.CSSRule.call(this);
      this.matcher = new CSSOM.MatcherList();
      this.cssRules = [];
  };

  CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
  CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
  CSSOM.CSSDocumentRule.prototype.type = 10;
  //FIXME
  //CSSOM.CSSDocumentRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSDocumentRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  Object.defineProperty(CSSOM.CSSDocumentRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
      }
      return "@-moz-document " + this.matcher.matcherText + " {" + cssTexts.join("") + "}";
    }
  });


  //.CommonJS
  CSSDocumentRule.CSSDocumentRule = CSSOM.CSSDocumentRule;

  var hasRequiredParse;

  function requireParse () {
  	if (hasRequiredParse) return parse$1;
  	hasRequiredParse = 1;
  	//.CommonJS
  	var CSSOM = {};
  	///CommonJS


  	/**
  	 * @param {string} token
  	 */
  	CSSOM.parse = function parse(token) {

  		var i = 0;

  		/**
  			"before-selector" or
  			"selector" or
  			"atRule" or
  			"atBlock" or
  			"conditionBlock" or
  			"before-name" or
  			"name" or
  			"before-value" or
  			"value"
  		*/
  		var state = "before-selector";

  		var index;
  		var buffer = "";
  		var valueParenthesisDepth = 0;

  		var SIGNIFICANT_WHITESPACE = {
  			"selector": true,
  			"value": true,
  			"value-parenthesis": true,
  			"atRule": true,
  			"importRule-begin": true,
  			"importRule": true,
  			"atBlock": true,
  			"conditionBlock": true,
  			'documentRule-begin': true
  		};

  		var styleSheet = new CSSOM.CSSStyleSheet();

  		// @type CSSStyleSheet|CSSMediaRule|CSSSupportsRule|CSSFontFaceRule|CSSKeyframesRule|CSSDocumentRule
  		var currentScope = styleSheet;

  		// @type CSSMediaRule|CSSSupportsRule|CSSKeyframesRule|CSSDocumentRule
  		var parentRule;

  		var ancestorRules = [];
  		var hasAncestors = false;
  		var prevScope;

  		var name, priority="", styleRule, mediaRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule;

  		var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

  		var parseError = function(message) {
  			var lines = token.substring(0, i).split('\n');
  			var lineCount = lines.length;
  			var charCount = lines.pop().length + 1;
  			var error = new Error(message + ' (line ' + lineCount + ', char ' + charCount + ')');
  			error.line = lineCount;
  			/* jshint sub : true */
  			error['char'] = charCount;
  			error.styleSheet = styleSheet;
  			throw error;
  		};

  		for (var character; (character = token.charAt(i)); i++) {

  			switch (character) {

  			case " ":
  			case "\t":
  			case "\r":
  			case "\n":
  			case "\f":
  				if (SIGNIFICANT_WHITESPACE[state]) {
  					buffer += character;
  				}
  				break;

  			// String
  			case '"':
  				index = i + 1;
  				do {
  					index = token.indexOf('"', index) + 1;
  					if (!index) {
  						parseError('Unmatched "');
  					}
  				} while (token[index - 2] === '\\');
  				buffer += token.slice(i, index);
  				i = index - 1;
  				switch (state) {
  					case 'before-value':
  						state = 'value';
  						break;
  					case 'importRule-begin':
  						state = 'importRule';
  						break;
  				}
  				break;

  			case "'":
  				index = i + 1;
  				do {
  					index = token.indexOf("'", index) + 1;
  					if (!index) {
  						parseError("Unmatched '");
  					}
  				} while (token[index - 2] === '\\');
  				buffer += token.slice(i, index);
  				i = index - 1;
  				switch (state) {
  					case 'before-value':
  						state = 'value';
  						break;
  					case 'importRule-begin':
  						state = 'importRule';
  						break;
  				}
  				break;

  			// Comment
  			case "/":
  				if (token.charAt(i + 1) === "*") {
  					i += 2;
  					index = token.indexOf("*/", i);
  					if (index === -1) {
  						parseError("Missing */");
  					} else {
  						i = index + 1;
  					}
  				} else {
  					buffer += character;
  				}
  				if (state === "importRule-begin") {
  					buffer += " ";
  					state = "importRule";
  				}
  				break;

  			// At-rule
  			case "@":
  				if (token.indexOf("@-moz-document", i) === i) {
  					state = "documentRule-begin";
  					documentRule = new CSSOM.CSSDocumentRule();
  					documentRule.__starts = i;
  					i += "-moz-document".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@media", i) === i) {
  					state = "atBlock";
  					mediaRule = new CSSOM.CSSMediaRule();
  					mediaRule.__starts = i;
  					i += "media".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@supports", i) === i) {
  					state = "conditionBlock";
  					supportsRule = new CSSOM.CSSSupportsRule();
  					supportsRule.__starts = i;
  					i += "supports".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@host", i) === i) {
  					state = "hostRule-begin";
  					i += "host".length;
  					hostRule = new CSSOM.CSSHostRule();
  					hostRule.__starts = i;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@import", i) === i) {
  					state = "importRule-begin";
  					i += "import".length;
  					buffer += "@import";
  					break;
  				} else if (token.indexOf("@font-face", i) === i) {
  					state = "fontFaceRule-begin";
  					i += "font-face".length;
  					fontFaceRule = new CSSOM.CSSFontFaceRule();
  					fontFaceRule.__starts = i;
  					buffer = "";
  					break;
  				} else {
  					atKeyframesRegExp.lastIndex = i;
  					var matchKeyframes = atKeyframesRegExp.exec(token);
  					if (matchKeyframes && matchKeyframes.index === i) {
  						state = "keyframesRule-begin";
  						keyframesRule = new CSSOM.CSSKeyframesRule();
  						keyframesRule.__starts = i;
  						keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
  						i += matchKeyframes[0].length - 1;
  						buffer = "";
  						break;
  					} else if (state === "selector") {
  						state = "atRule";
  					}
  				}
  				buffer += character;
  				break;

  			case "{":
  				if (state === "selector" || state === "atRule") {
  					styleRule.selectorText = buffer.trim();
  					styleRule.style.__starts = i;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "atBlock") {
  					mediaRule.media.mediaText = buffer.trim();

  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = mediaRule;
  					mediaRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "conditionBlock") {
  					supportsRule.conditionText = buffer.trim();

  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = supportsRule;
  					supportsRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "hostRule-begin") {
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = hostRule;
  					hostRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "fontFaceRule-begin") {
  					if (parentRule) {
  						fontFaceRule.parentRule = parentRule;
  					}
  					fontFaceRule.parentStyleSheet = styleSheet;
  					styleRule = fontFaceRule;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "keyframesRule-begin") {
  					keyframesRule.name = buffer.trim();
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  						keyframesRule.parentRule = parentRule;
  					}
  					keyframesRule.parentStyleSheet = styleSheet;
  					currentScope = parentRule = keyframesRule;
  					buffer = "";
  					state = "keyframeRule-begin";
  				} else if (state === "keyframeRule-begin") {
  					styleRule = new CSSOM.CSSKeyframeRule();
  					styleRule.keyText = buffer.trim();
  					styleRule.__starts = i;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "documentRule-begin") {
  					// FIXME: what if this '{' is in the url text of the match function?
  					documentRule.matcher.matcherText = buffer.trim();
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  						documentRule.parentRule = parentRule;
  					}
  					currentScope = parentRule = documentRule;
  					documentRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				}
  				break;

  			case ":":
  				if (state === "name") {
  					name = buffer.trim();
  					buffer = "";
  					state = "before-value";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "(":
  				if (state === 'value') {
  					// ie css expression mode
  					if (buffer.trim() === 'expression') {
  						var info = (new CSSOM.CSSValueExpression(token, i)).parse();

  						if (info.error) {
  							parseError(info.error);
  						} else {
  							buffer += info.expression;
  							i = info.idx;
  						}
  					} else {
  						state = 'value-parenthesis';
  						//always ensure this is reset to 1 on transition
  						//from value to value-parenthesis
  						valueParenthesisDepth = 1;
  						buffer += character;
  					}
  				} else if (state === 'value-parenthesis') {
  					valueParenthesisDepth++;
  					buffer += character;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ")":
  				if (state === 'value-parenthesis') {
  					valueParenthesisDepth--;
  					if (valueParenthesisDepth === 0) state = 'value';
  				}
  				buffer += character;
  				break;

  			case "!":
  				if (state === "value" && token.indexOf("!important", i) === i) {
  					priority = "important";
  					i += "important".length;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ";":
  				switch (state) {
  					case "value":
  						styleRule.style.setProperty(name, buffer.trim(), priority);
  						priority = "";
  						buffer = "";
  						state = "before-name";
  						break;
  					case "atRule":
  						buffer = "";
  						state = "before-selector";
  						break;
  					case "importRule":
  						importRule = new CSSOM.CSSImportRule();
  						importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
  						importRule.cssText = buffer + character;
  						styleSheet.cssRules.push(importRule);
  						buffer = "";
  						state = "before-selector";
  						break;
  					default:
  						buffer += character;
  						break;
  				}
  				break;

  			case "}":
  				switch (state) {
  					case "value":
  						styleRule.style.setProperty(name, buffer.trim(), priority);
  						priority = "";
  						/* falls through */
  					case "before-name":
  					case "name":
  						styleRule.__ends = i + 1;
  						if (parentRule) {
  							styleRule.parentRule = parentRule;
  						}
  						styleRule.parentStyleSheet = styleSheet;
  						currentScope.cssRules.push(styleRule);
  						buffer = "";
  						if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
  							state = "keyframeRule-begin";
  						} else {
  							state = "before-selector";
  						}
  						break;
  					case "keyframeRule-begin":
  					case "before-selector":
  					case "selector":
  						// End of media/supports/document rule.
  						if (!parentRule) {
  							parseError("Unexpected }");
  						}

  						// Handle rules nested in @media or @supports
  						hasAncestors = ancestorRules.length > 0;

  						while (ancestorRules.length > 0) {
  							parentRule = ancestorRules.pop();

  							if (
  								parentRule.constructor.name === "CSSMediaRule"
  								|| parentRule.constructor.name === "CSSSupportsRule"
  							) {
  								prevScope = currentScope;
  								currentScope = parentRule;
  								currentScope.cssRules.push(prevScope);
  								break;
  							}

  							if (ancestorRules.length === 0) {
  								hasAncestors = false;
  							}
  						}
  						
  						if (!hasAncestors) {
  							currentScope.__ends = i + 1;
  							styleSheet.cssRules.push(currentScope);
  							currentScope = styleSheet;
  							parentRule = null;
  						}

  						buffer = "";
  						state = "before-selector";
  						break;
  				}
  				break;

  			default:
  				switch (state) {
  					case "before-selector":
  						state = "selector";
  						styleRule = new CSSOM.CSSStyleRule();
  						styleRule.__starts = i;
  						break;
  					case "before-name":
  						state = "name";
  						break;
  					case "before-value":
  						state = "value";
  						break;
  					case "importRule-begin":
  						state = "importRule";
  						break;
  				}
  				buffer += character;
  				break;
  			}
  		}

  		return styleSheet;
  	};


  	//.CommonJS
  	parse$1.parse = CSSOM.parse;
  	// The following modules cannot be included sooner due to the mutual dependency with parse.js
  	CSSOM.CSSStyleSheet = requireCSSStyleSheet().CSSStyleSheet;
  	CSSOM.CSSStyleRule = requireCSSStyleRule().CSSStyleRule;
  	CSSOM.CSSImportRule = requireCSSImportRule().CSSImportRule;
  	CSSOM.CSSGroupingRule = CSSGroupingRule.CSSGroupingRule;
  	CSSOM.CSSMediaRule = CSSMediaRule.CSSMediaRule;
  	CSSOM.CSSConditionRule = CSSConditionRule.CSSConditionRule;
  	CSSOM.CSSSupportsRule = CSSSupportsRule.CSSSupportsRule;
  	CSSOM.CSSFontFaceRule = requireCSSFontFaceRule().CSSFontFaceRule;
  	CSSOM.CSSHostRule = CSSHostRule.CSSHostRule;
  	CSSOM.CSSStyleDeclaration = requireCSSStyleDeclaration().CSSStyleDeclaration;
  	CSSOM.CSSKeyframeRule = requireCSSKeyframeRule().CSSKeyframeRule;
  	CSSOM.CSSKeyframesRule = CSSKeyframesRule.CSSKeyframesRule;
  	CSSOM.CSSValueExpression = CSSValueExpression.CSSValueExpression;
  	CSSOM.CSSDocumentRule = CSSDocumentRule.CSSDocumentRule;
  	///CommonJS
  	return parse$1;
  }

  var hasRequiredCSSStyleDeclaration;

  function requireCSSStyleDeclaration () {
  	if (hasRequiredCSSStyleDeclaration) return CSSStyleDeclaration;
  	hasRequiredCSSStyleDeclaration = 1;
  	//.CommonJS
  	var CSSOM = {};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
  	 */
  	CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration(){
  		this.length = 0;
  		this.parentRule = null;

  		// NON-STANDARD
  		this._importants = {};
  	};


  	CSSOM.CSSStyleDeclaration.prototype = {

  		constructor: CSSOM.CSSStyleDeclaration,

  		/**
  		 *
  		 * @param {string} name
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
  		 * @return {string} the value of the property if it has been explicitly set for this declaration block.
  		 * Returns the empty string if the property has not been set.
  		 */
  		getPropertyValue: function(name) {
  			return this[name] || "";
  		},

  		/**
  		 *
  		 * @param {string} name
  		 * @param {string} value
  		 * @param {string} [priority=null] "important" or null
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
  		 */
  		setProperty: function(name, value, priority) {
  			if (this[name]) {
  				// Property already exist. Overwrite it.
  				var index = Array.prototype.indexOf.call(this, name);
  				if (index < 0) {
  					this[this.length] = name;
  					this.length++;
  				}
  			} else {
  				// New property.
  				this[this.length] = name;
  				this.length++;
  			}
  			this[name] = value + "";
  			this._importants[name] = priority;
  		},

  		/**
  		 *
  		 * @param {string} name
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
  		 * @return {string} the value of the property if it has been explicitly set for this declaration block.
  		 * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
  		 */
  		removeProperty: function(name) {
  			if (!(name in this)) {
  				return "";
  			}
  			var index = Array.prototype.indexOf.call(this, name);
  			if (index < 0) {
  				return "";
  			}
  			var prevValue = this[name];
  			this[name] = "";

  			// That's what WebKit and Opera do
  			Array.prototype.splice.call(this, index, 1);

  			// That's what Firefox does
  			//this[index] = ""

  			return prevValue;
  		},

  		getPropertyCSSValue: function() {
  			//FIXME
  		},

  		/**
  		 *
  		 * @param {String} name
  		 */
  		getPropertyPriority: function(name) {
  			return this._importants[name] || "";
  		},


  		/**
  		 *   element.style.overflow = "auto"
  		 *   element.style.getPropertyShorthand("overflow-x")
  		 *   -> "overflow"
  		 */
  		getPropertyShorthand: function() {
  			//FIXME
  		},

  		isPropertyImplicit: function() {
  			//FIXME
  		},

  		// Doesn't work in IE < 9
  		get cssText(){
  			var properties = [];
  			for (var i=0, length=this.length; i < length; ++i) {
  				var name = this[i];
  				var value = this.getPropertyValue(name);
  				var priority = this.getPropertyPriority(name);
  				if (priority) {
  					priority = " !" + priority;
  				}
  				properties[i] = name + ": " + value + priority + ";";
  			}
  			return properties.join(" ");
  		},

  		set cssText(text){
  			var i, name;
  			for (i = this.length; i--;) {
  				name = this[i];
  				this[name] = "";
  			}
  			Array.prototype.splice.call(this, 0, this.length);
  			this._importants = {};

  			var dummyRule = CSSOM.parse('#bogus{' + text + '}').cssRules[0].style;
  			var length = dummyRule.length;
  			for (i = 0; i < length; ++i) {
  				name = dummyRule[i];
  				this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
  			}
  		}
  	};


  	//.CommonJS
  	CSSStyleDeclaration.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
  	CSSOM.parse = requireParse().parse; // Cannot be included sooner due to the mutual dependency between parse.js and CSSStyleDeclaration.js
  	///CommonJS
  	return CSSStyleDeclaration;
  }

  //.CommonJS
  ({
  	CSSStyleSheet: requireCSSStyleSheet().CSSStyleSheet,
  	CSSRule: CSSRule.CSSRule,
  	CSSStyleRule: requireCSSStyleRule().CSSStyleRule,
  	CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
  	CSSConditionRule: CSSConditionRule.CSSConditionRule,
  	CSSMediaRule: CSSMediaRule.CSSMediaRule,
  	CSSSupportsRule: CSSSupportsRule.CSSSupportsRule,
  	CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  	CSSKeyframeRule: requireCSSKeyframeRule().CSSKeyframeRule,
  	CSSKeyframesRule: CSSKeyframesRule.CSSKeyframesRule
  });

  requireCSSStyleDeclaration().CSSStyleDeclaration;
  requireCSSStyleRule().CSSStyleRule;
  requireCSSImportRule().CSSImportRule;
  requireCSSFontFaceRule().CSSFontFaceRule;
  requireCSSStyleSheet().CSSStyleSheet;
  requireCSSKeyframeRule().CSSKeyframeRule;
  var parse = requireParse().parse;

  const tagName$e = 'style';

  /**
   * @implements globalThis.HTMLStyleElement
   */
  class HTMLStyleElement extends TextElement {
    constructor(ownerDocument, localName = tagName$e) {
      super(ownerDocument, localName);
      this[SHEET] = null;
    }

    get sheet() {
      const sheet = this[SHEET];
      if (sheet !== null) {
        return sheet;
      }
      return this[SHEET] = parse(this.textContent);
    }

    get innerHTML() {
      return super.innerHTML || '';
    }
    set innerHTML(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
    get innerText() {
      return super.innerText || '';
    }
    set innerText(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
    get textContent() {
      return super.textContent || '';
    }
    set textContent(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
  }

  registerHTMLClass(tagName$e, HTMLStyleElement);

  /**
   * @implements globalThis.HTMLTimeElement
   */
  class HTMLTimeElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'time') {
      super(ownerDocument, localName);
    }

    /**
     * @type {string}
     */
    get dateTime() { return stringAttribute.get(this, 'datetime'); }
    set dateTime(value) { stringAttribute.set(this, 'datetime', value); }
  }

  registerHTMLClass('time', HTMLTimeElement);

  /**
   * @implements globalThis.HTMLFieldSetElement
   */
  class HTMLFieldSetElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'fieldset') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLEmbedElement
   */
  class HTMLEmbedElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'embed') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLHRElement
   */
  class HTMLHRElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'hr') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLProgressElement
   */
  class HTMLProgressElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'progress') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLParagraphElement
   */
  class HTMLParagraphElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'p') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableElement
   */
  class HTMLTableElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'table') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLFrameSetElement
   */
  class HTMLFrameSetElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'frameset') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLLIElement
   */
  class HTMLLIElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'li') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLBaseElement
   */
  class HTMLBaseElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'base') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDataListElement
   */
  class HTMLDataListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'datalist') {
      super(ownerDocument, localName);
    }
  }

  const tagName$d = 'input';

  /**
   * @implements globalThis.HTMLInputElement
   */
  class HTMLInputElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$d) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get autofocus() { return booleanAttribute.get(this, 'autofocus') || -1; }
    set autofocus(value) { booleanAttribute.set(this, 'autofocus', value); }

    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get placeholder() { return this.getAttribute('placeholder'); }
    set placeholder(value) { this.setAttribute('placeholder', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }

    get value() { return stringAttribute.get(this, 'value'); }
    set value(value) { stringAttribute.set(this, 'value', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$d, HTMLInputElement);

  /**
   * @implements globalThis.HTMLParamElement
   */
  class HTMLParamElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'param') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMediaElement
   */
  class HTMLMediaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'media') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLAudioElement
   */
  class HTMLAudioElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'audio') {
      super(ownerDocument, localName);
    }
  }

  const tagName$c = 'h1';

  /**
   * @implements globalThis.HTMLHeadingElement
   */
  class HTMLHeadingElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$c) {
      super(ownerDocument, localName);
    }
  }

  registerHTMLClass([tagName$c, 'h2', 'h3', 'h4', 'h5', 'h6'], HTMLHeadingElement);

  /**
   * @implements globalThis.HTMLDirectoryElement
   */
  class HTMLDirectoryElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'dir') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLQuoteElement
   */
  class HTMLQuoteElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'quote') {
      super(ownerDocument, localName);
    }
  }

  var canvas = {exports: {}};

  var canvasShim;
  var hasRequiredCanvasShim;

  function requireCanvasShim () {
  	if (hasRequiredCanvasShim) return canvasShim;
  	hasRequiredCanvasShim = 1;
  	class Canvas {
  	  constructor(width, height) {
  	    this.width = width;
  	    this.height = height;
  	  }
  	  getContext() {
  	    return null;
  	  }
  	  toDataURL() {
  	    return '';
  	  }
  	}

  	canvasShim = {
  	  createCanvas: (width, height) => new Canvas(width, height),
  	};
  	return canvasShim;
  }

  /* c8 ignore start */

  try {
    canvas.exports = require('canvas');
  } catch (fallback) {
    canvas.exports = requireCanvasShim();
  }
  /* c8 ignore stop */

  var canvasExports = canvas.exports;
  var Canvas = /*@__PURE__*/getDefaultExportFromCjs(canvasExports);

  const {createCanvas} = Canvas;

  const tagName$b = 'canvas';

  /**
   * @implements globalThis.HTMLCanvasElement
   */
  class HTMLCanvasElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$b) {
      super(ownerDocument, localName);
      this[IMAGE] = createCanvas(300, 150);
    }

    get width() {
      return this[IMAGE].width;
    }

    set width(value) {
      numericAttribute.set(this, 'width', value);
      this[IMAGE].width = value;
    }

    get height() {
      return this[IMAGE].height;
    }

    set height(value) {
      numericAttribute.set(this, 'height', value);
      this[IMAGE].height = value;
    }

    getContext(type) {
      return this[IMAGE].getContext(type);
    }

    toDataURL(...args) {
      return this[IMAGE].toDataURL(...args);
    }
  }

  registerHTMLClass(tagName$b, HTMLCanvasElement);

  /**
   * @implements globalThis.HTMLLegendElement
   */
  class HTMLLegendElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'legend') {
      super(ownerDocument, localName);
    }
  }

  const tagName$a = 'option';

  /**
   * @implements globalThis.HTMLOptionElement
   */
  class HTMLOptionElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$a) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get value() { return stringAttribute.get(this, 'value'); }
    set value(value) { stringAttribute.set(this, 'value', value); }
    /* c8 ignore stop */

    get selected() { return booleanAttribute.get(this, 'selected'); }
    set selected(value) {
      const option = this.parentElement?.querySelector('option[selected]');
      if (option && option !== this)
        option.selected = false;
      booleanAttribute.set(this, 'selected', value);
    }
  }

  registerHTMLClass(tagName$a, HTMLOptionElement);

  /**
   * @implements globalThis.HTMLSpanElement
   */
  class HTMLSpanElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'span') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMeterElement
   */
  class HTMLMeterElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'meter') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLVideoElement
   */
  class HTMLVideoElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'video') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableCellElement
   */
  class HTMLTableCellElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'td') {
      super(ownerDocument, localName);
    }
  }

  const tagName$9 = 'title';

  /**
   * @implements globalThis.HTMLTitleElement
   */
  class HTMLTitleElement extends TextElement {
    constructor(ownerDocument, localName = tagName$9) {
      super(ownerDocument, localName);
    }
  }

  registerHTMLClass(tagName$9, HTMLTitleElement);

  /**
   * @implements globalThis.HTMLOutputElement
   */
  class HTMLOutputElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'output') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableRowElement
   */
  class HTMLTableRowElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'tr') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDataElement
   */
  class HTMLDataElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'data') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMenuElement
   */
  class HTMLMenuElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'menu') {
      super(ownerDocument, localName);
    }
  }

  const tagName$8 = 'select';

  /**
   * @implements globalThis.HTMLSelectElement
   */
  class HTMLSelectElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$8) {
      super(ownerDocument, localName);
    }

    get options() {
      let children = new NodeList;
      let {firstElementChild} = this;
      while (firstElementChild) {
        if (firstElementChild.tagName === 'OPTGROUP')
          children.push(...firstElementChild.children);
        else
          children.push(firstElementChild);
        firstElementChild = firstElementChild.nextElementSibling;
      }
      return children;
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }
    /* c8 ignore stop */

    get value() { return this.querySelector('option[selected]')?.value; }
  }

  registerHTMLClass(tagName$8, HTMLSelectElement);

  /**
   * @implements globalThis.HTMLBRElement
   */
  class HTMLBRElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'br') {
      super(ownerDocument, localName);
    }
  }

  const tagName$7 = 'button';

  /**
   * @implements globalThis.HTMLButtonElement
   */
  class HTMLButtonElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$7) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$7, HTMLButtonElement);

  /**
   * @implements globalThis.HTMLMapElement
   */
  class HTMLMapElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'map') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLOptGroupElement
   */
  class HTMLOptGroupElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'optgroup') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDListElement
   */
  class HTMLDListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'dl') {
      super(ownerDocument, localName);
    }
  }

  const tagName$6 = 'textarea';

  /**
   * @implements globalThis.HTMLTextAreaElement
   */
  class HTMLTextAreaElement extends TextElement {
    constructor(ownerDocument, localName = tagName$6) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get placeholder() { return this.getAttribute('placeholder'); }
    set placeholder(value) { this.setAttribute('placeholder', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }

    get value() { return this.textContent; }
    set value(content) { this.textContent = content; }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$6, HTMLTextAreaElement);

  /**
   * @implements globalThis.HTMLFontElement
   */
  class HTMLFontElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'font') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDivElement
   */
  class HTMLDivElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'div') {
      super(ownerDocument, localName);
    }
  }

  const tagName$5 = 'link';

  /**
   * @implements globalThis.HTMLLinkElement
   */
  class HTMLLinkElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$5) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */ // copy paste from img.src, already covered
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get href() { return stringAttribute.get(this, 'href').trim(); }
    set href(value) { stringAttribute.set(this, 'href', value); }

    get hreflang() { return stringAttribute.get(this, 'hreflang'); }
    set hreflang(value) { stringAttribute.set(this, 'hreflang', value); }

    get media() { return stringAttribute.get(this, 'media'); }
    set media(value) { stringAttribute.set(this, 'media', value); }

    get rel() { return stringAttribute.get(this, 'rel'); }
    set rel(value) { stringAttribute.set(this, 'rel', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$5, HTMLLinkElement);

  const tagName$4 = 'slot';

  /**
   * @implements globalThis.HTMLSlotElement
   */
  class HTMLSlotElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$4) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    assign() {}

    assignedNodes(options) {
      const isNamedSlot = !!this.name;
      const hostChildNodes = this.getRootNode().host?.childNodes ?? [];
      let slottables;

      if (isNamedSlot) {
        slottables = [...hostChildNodes].filter(node => node.slot === this.name);
      } else {
        slottables = [...hostChildNodes].filter(node => !node.slot);
      }

      if (options?.flatten) {
        const result = [];

        // Element and Text nodes are slottables. A slot can be a slottable.
        for (let slottable of slottables) {
          if (slottable.localName === 'slot') {
            result.push(...slottable.assignedNodes({ flatten: true }));
          } else {
            result.push(slottable);
          }
        }

        slottables = result;
      }

      // If no assigned nodes are found, it returns the slot's fallback content.
      return slottables.length ? slottables : [...this.childNodes];
    }

    assignedElements(options) {
      const slottables = this.assignedNodes(options).filter(n => n.nodeType === 1);

      // If no assigned elements are found, it returns the slot's fallback content.
      return slottables.length ? slottables : [...this.children];
    }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$4, HTMLSlotElement);

  /**
   * @implements globalThis.HTMLFormElement
   */
  class HTMLFormElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'form') {
      super(ownerDocument, localName);
    }
  }

  const tagName$3 = 'img';

  /**
   * @implements globalThis.HTMLImageElement
   */
  class HTMLImageElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$3) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get alt() { return stringAttribute.get(this, 'alt'); }
    set alt(value) { stringAttribute.set(this, 'alt', value); }

    get sizes() { return stringAttribute.get(this, 'sizes'); }
    set sizes(value) { stringAttribute.set(this, 'sizes', value); }

    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcset() { return stringAttribute.get(this, 'srcset'); }
    set srcset(value) { stringAttribute.set(this, 'srcset', value); }

    get title() { return stringAttribute.get(this, 'title'); }
    set title(value) { stringAttribute.set(this, 'title', value); }

    get width() { return numericAttribute.get(this, 'width'); }
    set width(value) { numericAttribute.set(this, 'width', value); }

    get height() { return numericAttribute.get(this, 'height'); }
    set height(value) { numericAttribute.set(this, 'height', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$3, HTMLImageElement);

  /**
   * @implements globalThis.HTMLPreElement
   */
  class HTMLPreElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'pre') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLUListElement
   */
  class HTMLUListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'ul') {
      super(ownerDocument, localName);
    }
  }

  const tagName$2 = 'meta';
  /**
   * @implements globalThis.HTMLMetaElement
   */
  class HTMLMetaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName =tagName$2) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get name() { return stringAttribute.get(this, 'name'); }
    set name(value) { stringAttribute.set(this, 'name', value); }

    get httpEquiv() { return stringAttribute.get(this, 'http-equiv'); }
    set httpEquiv(value) { stringAttribute.set(this, 'http-equiv', value); }

    get content() { return stringAttribute.get(this, 'content'); }
    set content(value) { stringAttribute.set(this, 'content', value); }

    get charset() { return stringAttribute.get(this, 'charset'); }
    set charset(value) { stringAttribute.set(this, 'charset', value); }

    get media() { return stringAttribute.get(this, 'media'); }
    set media(value) { stringAttribute.set(this, 'media', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$2, HTMLMetaElement);

  /**
   * @implements globalThis.HTMLPictureElement
   */
  class HTMLPictureElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'picture') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLAreaElement
   */
  class HTMLAreaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'area') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLOListElement
   */
  class HTMLOListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'ol') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableCaptionElement
   */
  class HTMLTableCaptionElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'caption') {
      super(ownerDocument, localName);
    }
  }

  const tagName$1 = 'a';

  /**
   * @implements globalThis.HTMLAnchorElement
   */
  class HTMLAnchorElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$1) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */ // copy paste from img.src, already covered
    get href() { return encodeURI(decodeURI(stringAttribute.get(this, 'href'))).trim(); }
    set href(value) { stringAttribute.set(this, 'href', decodeURI(value)); }

    get download() { return encodeURI(decodeURI(stringAttribute.get(this, 'download'))); }
    set download(value) { stringAttribute.set(this, 'download', decodeURI(value)); }

    get target() { return stringAttribute.get(this, 'target'); }
    set target(value) { stringAttribute.set(this, 'target', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }

    get rel() { return stringAttribute.get(this, 'rel'); }
    set rel(value) { stringAttribute.set(this, 'rel', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$1, HTMLAnchorElement);

  /**
   * @implements globalThis.HTMLLabelElement
   */
  class HTMLLabelElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'label') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLUnknownElement
   */
  class HTMLUnknownElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'unknown') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLModElement
   */
  class HTMLModElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'mod') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDetailsElement
   */
  class HTMLDetailsElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'details') {
      super(ownerDocument, localName);
    }
  }

  const tagName = 'source';

  /**
   * @implements globalThis.HTMLSourceElement
   */
  class HTMLSourceElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcset() { return stringAttribute.get(this, 'srcset'); }
    set srcset(value) { stringAttribute.set(this, 'srcset', value); }

    get sizes() { return stringAttribute.get(this, 'sizes'); }
    set sizes(value) { stringAttribute.set(this, 'sizes', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName, HTMLSourceElement);

  /**
   * @implements globalThis.HTMLTrackElement
   */
  class HTMLTrackElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'track') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMarqueeElement
   */
  class HTMLMarqueeElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'marquee') {
      super(ownerDocument, localName);
    }
  }

  const HTMLClasses = {
    HTMLElement: HTMLElement$1,
    HTMLTemplateElement,
    HTMLHtmlElement,
    HTMLScriptElement,
    HTMLFrameElement,
    HTMLIFrameElement,
    HTMLObjectElement,
    HTMLHeadElement,
    HTMLBodyElement,
    HTMLStyleElement,
    HTMLTimeElement,
    HTMLFieldSetElement,
    HTMLEmbedElement,
    HTMLHRElement,
    HTMLProgressElement,
    HTMLParagraphElement,
    HTMLTableElement,
    HTMLFrameSetElement,
    HTMLLIElement,
    HTMLBaseElement,
    HTMLDataListElement,
    HTMLInputElement,
    HTMLParamElement,
    HTMLMediaElement,
    HTMLAudioElement,
    HTMLHeadingElement,
    HTMLDirectoryElement,
    HTMLQuoteElement,
    HTMLCanvasElement,
    HTMLLegendElement,
    HTMLOptionElement,
    HTMLSpanElement,
    HTMLMeterElement,
    HTMLVideoElement,
    HTMLTableCellElement,
    HTMLTitleElement,
    HTMLOutputElement,
    HTMLTableRowElement,
    HTMLDataElement,
    HTMLMenuElement,
    HTMLSelectElement,
    HTMLBRElement,
    HTMLButtonElement,
    HTMLMapElement,
    HTMLOptGroupElement,
    HTMLDListElement,
    HTMLTextAreaElement,
    HTMLFontElement,
    HTMLDivElement,
    HTMLLinkElement,
    HTMLSlotElement,
    HTMLFormElement,
    HTMLImageElement,
    HTMLPreElement,
    HTMLUListElement,
    HTMLMetaElement,
    HTMLPictureElement,
    HTMLAreaElement,
    HTMLOListElement,
    HTMLTableCaptionElement,
    HTMLAnchorElement,
    HTMLLabelElement,
    HTMLUnknownElement,
    HTMLModElement,
    HTMLDetailsElement,
    HTMLSourceElement,
    HTMLTrackElement,
    HTMLMarqueeElement
  };

  // TODO: ensure all these are text only
  // /^(?:plaintext|script|style|textarea|title|xmp)$/i

  const voidElements = {test: () => true};
  const Mime = {
    'text/html': {
      docType: '<!DOCTYPE html>',
      ignoreCase: true,
      voidElements: /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i
    },
    'image/svg+xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'text/xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'application/xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'application/xhtml+xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    }
  };

  // https://dom.spec.whatwg.org/#interface-customevent


  /**
   * @implements globalThis.CustomEvent
   */
  class CustomEvent extends GlobalEvent {
    constructor(type, eventInitDict = {}) {
      super(type, eventInitDict);
      this.detail = eventInitDict.detail;
    }
  }

  /* c8 ignore stop */

  // https://dom.spec.whatwg.org/#interface-customevent


  /**
   * @implements globalThis.InputEvent
   */
  class InputEvent extends GlobalEvent {
    constructor(type, inputEventInit = {}) {
      super(type, inputEventInit);
      this.inputType = inputEventInit.inputType;
      this.data = inputEventInit.data;
      this.dataTransfer = inputEventInit.dataTransfer;
      this.isComposing = inputEventInit.isComposing || false;
      this.ranges = inputEventInit.ranges;
    }
  }
  /* c8 ignore stop */

  const ImageClass = ownerDocument =>
  /**
   * @implements globalThis.Image
   */
  class Image extends HTMLImageElement {
    constructor(width, height) {
      super(ownerDocument);
      switch (arguments.length) {
        case 1:
          this.height = width;
          this.width = width;
          break;
        case 2:
          this.height = height;
          this.width = width;
          break;
      }
    }
  };

  // https://dom.spec.whatwg.org/#concept-live-range


  const deleteContents = ({[START]: start, [END]: end}, fragment = null) => {
    setAdjacent(start[PREV], end[NEXT]);
    do {
      const after = getEnd(start);
      const next = after === end ? after : after[NEXT];
      if (fragment)
        fragment.insertBefore(start, fragment[END]);
      else
        start.remove();
      start = next;
    } while (start !== end);
  };

  /**
   * @implements globalThis.Range
   */
  class Range {
    constructor() {
      this[START] = null;
      this[END] = null;
      this.commonAncestorContainer = null;
    }

    /* TODO: this is more complicated than it looks
    setStart(node, offset) {
      this[START] = node.childNodes[offset];
    }

    setEnd(node, offset) {
      this[END] = getEnd(node.childNodes[offset]);
    }
    //*/

    insertNode(newNode) {
      this[END].parentNode.insertBefore(newNode, this[START]);
    }

    selectNode(node) {
      this[START] = node;
      this[END] = getEnd(node);
    }

    // TODO: SVG elements should then create contextual fragments
    //       that return SVG nodes
    selectNodeContents(node) {
      this.selectNode(node);
      this.commonAncestorContainer = node;
    }

    surroundContents(parentNode) {
      parentNode.replaceChildren(this.extractContents());
    }

    setStartBefore(node) {
      this[START] = node;
    }

    setStartAfter(node) {
      this[START] = node.nextSibling;
    }

    setEndBefore(node) {
      this[END] = getEnd(node.previousSibling);
    }

    setEndAfter(node) {
      this[END] = getEnd(node);
    }

    cloneContents() {
      let {[START]: start, [END]: end} = this;
      const fragment = start.ownerDocument.createDocumentFragment();
      while (start !== end) {
        fragment.insertBefore(start.cloneNode(true), fragment[END]);
        start = getEnd(start);
        if (start !== end)
          start = start[NEXT];
      }
      return fragment;
    }

    deleteContents() {
      deleteContents(this);
    }

    extractContents() {
      const fragment = this[START].ownerDocument.createDocumentFragment();
      deleteContents(this, fragment);
      return fragment;
    }

    createContextualFragment(html) {
      const { commonAncestorContainer: doc } = this;
      const isSVG = 'ownerSVGElement' in doc;
      const document = isSVG ? doc.ownerDocument : doc;
      let content = htmlToFragment(document, html);
      if (isSVG) {
        const childNodes = [...content.childNodes];
        content = document.createDocumentFragment();
        Object.setPrototypeOf(content, SVGElement$1.prototype);
        content.ownerSVGElement = document;
        for (const child of childNodes) {
          Object.setPrototypeOf(child, SVGElement$1.prototype);
          child.ownerSVGElement = document;
          content.appendChild(child);
        }
      }
      else
        this.selectNode(content);
      return content;
    }

    cloneRange() {
      const range = new Range;
      range[START] = this[START];
      range[END] = this[END];
      return range;
    }
  }

  const isOK = ({nodeType}, mask) => {
    switch (nodeType) {
      case ELEMENT_NODE:
        return mask & SHOW_ELEMENT;
      case TEXT_NODE:
        return mask & SHOW_TEXT;
      case COMMENT_NODE:
        return mask & SHOW_COMMENT;
      case CDATA_SECTION_NODE:
        return mask & SHOW_CDATA_SECTION;
    }
    return 0;
  };

  /**
   * @implements globalThis.TreeWalker
   */
  class TreeWalker {
    constructor(root, whatToShow = SHOW_ALL) {
      this.root = root;
      this.currentNode = root;
      this.whatToShow = whatToShow;
      let {[NEXT]: next, [END]: end} = root;
      if (root.nodeType === DOCUMENT_NODE) {
        const {documentElement} = root;
        next = documentElement;
        end = documentElement[END];
      }
      const nodes = [];
      while (next && next !== end) {
        if (isOK(next, whatToShow))
          nodes.push(next);
        next = next[NEXT];
      }
      this[PRIVATE] = {i: 0, nodes};
    }

    nextNode() {
      const $ = this[PRIVATE];
      this.currentNode = $.i < $.nodes.length ? $.nodes[$.i++] : null;
      return this.currentNode;
    }
  }

  const query = (method, ownerDocument, selectors) => {
    let {[NEXT]: next, [END]: end} = ownerDocument;
    return method.call({ownerDocument, [NEXT]: next, [END]: end}, selectors);
  };

  const globalExports = assign(
    {},
    Facades,
    HTMLClasses,
    {
      CustomEvent,
      Event: GlobalEvent,
      EventTarget: DOMEventTarget,
      InputEvent,
      NamedNodeMap,
      NodeList
    }
  );

  const window$1 = new WeakMap;

  /**
   * @implements globalThis.Document
   */
  let Document$1 = class Document extends NonElementParentNode {
    constructor(type) {
      super(null, '#document', DOCUMENT_NODE);
      this[CUSTOM_ELEMENTS] = {active: false, registry: null};
      this[MUTATION_OBSERVER] = {active: false, class: null};
      this[MIME] = Mime[type];
      /** @type {DocumentType} */
      this[DOCTYPE] = null;
      this[DOM_PARSER] = null;
      this[GLOBALS] = null;
      this[IMAGE] = null;
      this[UPGRADE] = null;
    }

    /**
     * @type {globalThis.Document['defaultView']}
     */
    get defaultView() {
      if (!window$1.has(this))
        window$1.set(this, new Proxy(globalThis, {
          set: (target, name, value) => {
            switch (name) {
              case 'addEventListener':
              case 'removeEventListener':
              case 'dispatchEvent':
                this[EVENT_TARGET][name] = value;
                break;
              default:
                target[name] = value;
                break;
            }
            return true;
          },
          get: (globalThis, name) => {
            switch (name) {
              case 'addEventListener':
              case 'removeEventListener':
              case 'dispatchEvent':
                if (!this[EVENT_TARGET]) {
                  const et = this[EVENT_TARGET] = new DOMEventTarget;
                  et.dispatchEvent = et.dispatchEvent.bind(et);
                  et.addEventListener = et.addEventListener.bind(et);
                  et.removeEventListener = et.removeEventListener.bind(et);
                }
                return this[EVENT_TARGET][name];
              case 'document':
                return this;
              /* c8 ignore start */
              case 'navigator':
                return {
                  userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'
                };
              /* c8 ignore stop */
              case 'window':
                return window$1.get(this);
              case 'customElements':
                if (!this[CUSTOM_ELEMENTS].registry)
                  this[CUSTOM_ELEMENTS] = new CustomElementRegistry(this);
                return this[CUSTOM_ELEMENTS];
              case 'performance':
                return globalThis.performance;
              case 'DOMParser':
                return this[DOM_PARSER];
              case 'Image':
                if (!this[IMAGE])
                  this[IMAGE] = ImageClass(this);
                return this[IMAGE];
              case 'MutationObserver':
                if (!this[MUTATION_OBSERVER].class)
                  this[MUTATION_OBSERVER] = new MutationObserverClass(this);
                return this[MUTATION_OBSERVER].class;
            }
            return (this[GLOBALS] && this[GLOBALS][name]) ||
                    globalExports[name] ||
                    globalThis[name];
          }
        }));
      return window$1.get(this);
    }

    get doctype() {
      const docType = this[DOCTYPE];
      if (docType)
        return docType;
      const {firstChild} = this;
      if (firstChild && firstChild.nodeType === DOCUMENT_TYPE_NODE)
        return (this[DOCTYPE] = firstChild);
      return null;
    }

    set doctype(value) {
      if (/^([a-z:]+)(\s+system|\s+public(\s+"([^"]+)")?)?(\s+"([^"]+)")?/i.test(value)) {
        const {$1: name, $4: publicId, $6: systemId} = RegExp;
        this[DOCTYPE] = new DocumentType$1(this, name, publicId, systemId);
        knownSiblings(this, this[DOCTYPE], this[NEXT]);
      }
    }

    get documentElement() {
      return this.firstElementChild;
    }

    get isConnected() { return true; }

    /**
     * @protected
     */
     _getParent() {
      return this[EVENT_TARGET];
    }

    createAttribute(name) { return new Attr$1(this, name); }
    createCDATASection(data) { return new CDATASection$1(this, data); }
    createComment(textContent) { return new Comment$1(this, textContent); }
    createDocumentFragment() { return new DocumentFragment$1(this); }
    createDocumentType(name, publicId, systemId) { return new DocumentType$1(this, name, publicId, systemId); }
    createElement(localName) { return new Element$1(this, localName); }
    createRange() {
      const range = new Range;
      range.commonAncestorContainer = this;
      return range;
    }
    createTextNode(textContent) { return new Text$1(this, textContent); }
    createTreeWalker(root, whatToShow = -1) { return new TreeWalker(root, whatToShow); }
    createNodeIterator(root, whatToShow = -1) { return this.createTreeWalker(root, whatToShow); }

    createEvent(name) {
      const event = create$1(name === 'Event' ? new GlobalEvent('') : new CustomEvent(''));
      event.initEvent = event.initCustomEvent = (
        type,
        canBubble = false,
        cancelable = false,
        detail
      ) => {
        event.bubbles = !!canBubble;

        defineProperties(event, {
          type: {value: type},
          canBubble: {value: canBubble},
          cancelable: {value: cancelable},
          detail: {value: detail}
        });
      };
      return event;
    }

    cloneNode(deep = false) {
      const {
        constructor,
        [CUSTOM_ELEMENTS]: customElements,
        [DOCTYPE]: doctype
      } = this;
      const document = new constructor();
      document[CUSTOM_ELEMENTS] = customElements;
      if (deep) {
        const end = document[END];
        const {childNodes} = this;
        for (let {length} = childNodes, i = 0; i < length; i++)
          document.insertBefore(childNodes[i].cloneNode(true), end);
        if (doctype)
          document[DOCTYPE] = childNodes[0];
      }
      return document;
    }

    importNode(externalNode) {
      // important: keep the signature length as *one*
      // or it would behave like old IE or Edge with polyfills
      const deep = 1 < arguments.length && !!arguments[1];
      const node = externalNode.cloneNode(deep);
      const {[CUSTOM_ELEMENTS]: customElements} = this;
      const {active} = customElements;
      const upgrade = element => {
        const {ownerDocument, nodeType} = element;
        element.ownerDocument = this;
        if (active && ownerDocument !== this && nodeType === ELEMENT_NODE)
          customElements.upgrade(element);
      };
      upgrade(node);
      if (deep) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            let {[NEXT]: next, [END]: end} = node;
            while (next !== end) {
              if (next.nodeType === ELEMENT_NODE)
                upgrade(next);
              next = next[NEXT];
            }
            break;
          }
        }
      }
      return node;
    }

    toString() { return this.childNodes.join(''); }

    querySelector(selectors) {
      return query(super.querySelector, this, selectors);
    }

    querySelectorAll(selectors) {
      return query(super.querySelectorAll, this, selectors);
    }

    /* c8 ignore start */
    getElementsByTagNameNS(_, name) {
      return this.getElementsByTagName(name);
    }
    createAttributeNS(_, name) {
      return this.createAttribute(name);
    }
    createElementNS(nsp, localName, options) {
      return nsp === SVG_NAMESPACE ?
              new SVGElement$1(this, localName, null) :
              this.createElement(localName, options);
    }
    /* c8 ignore stop */
  };

  setPrototypeOf(
    globalExports.Document = function Document() {
      illegalConstructor();
    },
    Document$1
  ).prototype = Document$1.prototype;

  const createHTMLElement = (ownerDocument, builtin, localName, options) => {
    if (!builtin && htmlClasses.has(localName)) {
      const Class = htmlClasses.get(localName);
      return new Class(ownerDocument, localName);
    }
    const {[CUSTOM_ELEMENTS]: {active, registry}} = ownerDocument;
    if (active) {
      const ce = builtin ? options.is : localName;
      if (registry.has(ce)) {
        const {Class} = registry.get(ce);
        const element = new Class(ownerDocument, localName);
        customElements.set(element, {connected: false});
        return element;
      }
    }
    return new HTMLElement$1(ownerDocument, localName);
  };

  /**
   * @implements globalThis.HTMLDocument
   */
  class HTMLDocument extends Document$1 {
    constructor() { super('text/html'); }

    get all() {
      const nodeList = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        switch (next.nodeType) {
          case ELEMENT_NODE:
            nodeList.push(next);
            break;
        }
        next = next[NEXT];
      }
      return nodeList;
    }

    /**
     * @type HTMLHeadElement
     */
    get head() {
      const {documentElement} = this;
      let {firstElementChild} = documentElement;
      if (!firstElementChild || firstElementChild.tagName !== 'HEAD') {
        firstElementChild = this.createElement('head');
        documentElement.prepend(firstElementChild);
      }
      return firstElementChild;
    }

    /**
     * @type HTMLBodyElement
     */
    get body() {
      const {head} = this;
      let {nextElementSibling} = head;
      if (!nextElementSibling || nextElementSibling.tagName !== 'BODY') {
        nextElementSibling = this.createElement('body');
        head.after(nextElementSibling);
      }
      return nextElementSibling;
    }

    /**
     * @type HTMLTitleElement
     */
    get title() {
      const {head} = this;
      return head.getElementsByTagName('title').at(0)?.textContent || '';
    }

    set title(textContent) {
      const {head} = this;
      let title = head.getElementsByTagName('title').at(0);
      if (title)
        title.textContent = textContent;
      else {
        head.insertBefore(
          this.createElement('title'),
          head.firstChild
        ).textContent = textContent;
      }
    }

    createElement(localName, options) {
      const builtin = !!(options && options.is);
      const element = createHTMLElement(this, builtin, localName, options);
      if (builtin)
        element.setAttribute('is', options.is);
      return element;
    }
  }

  /**
   * @implements globalThis.Document
   */
  class SVGDocument extends Document$1 {
    constructor() { super('image/svg+xml'); }
    toString() {
      return this[MIME].docType + super.toString();
    }
  }

  /**
   * @implements globalThis.XMLDocument
   */
  class XMLDocument extends Document$1 {
    constructor() { super('text/xml'); }
    toString() {
      return this[MIME].docType + super.toString();
    }
  }

  /**
   * @implements globalThis.DOMParser
   */
  class DOMParser {

    /** @typedef {{ "text/html": HTMLDocument, "image/svg+xml": SVGDocument, "text/xml": XMLDocument }} MimeToDoc */
    /**
     * @template {keyof MimeToDoc} MIME
     * @param {string} markupLanguage
     * @param {MIME} mimeType
     * @returns {MimeToDoc[MIME]}
     */
    parseFromString(markupLanguage, mimeType, globals = null) {
      let isHTML = false, document;
      if (mimeType === 'text/html') {
        isHTML = true;
        document = new HTMLDocument;
      }
      else if (mimeType === 'image/svg+xml')
        document = new SVGDocument;
      else
        document = new XMLDocument;
      document[DOM_PARSER] = DOMParser;
      if (globals)
        document[GLOBALS] = globals;
      if (isHTML && markupLanguage === '...')
        markupLanguage = '<!doctype html><html><head></head><body></body></html>';
      return markupLanguage ?
              parseFromString$1(document, isHTML, markupLanguage) :
              document;
    }
  }

  function Document() {
    illegalConstructor();
  }

  setPrototypeOf(Document, Document$1).prototype = Document$1.prototype;

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Parses an html string and returns a parsed html document.
   * @param html An HTML string.
   * @return A Document.
   */
  const parseFromString = (html) => {
      return new DOMParser().parseFromString(`<!doctype html><html><body>${html}</body></html>`, 'text/html');
  };

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Base BudouX parser.
   */
  class Parser {
      /**
       * Constructs a BudouX parser.
       * @param model A model data.
       */
      constructor(model) {
          this.model = new Map(Object.entries(model).map(([k, v]) => [k, new Map(Object.entries(v))]));
          this.baseScore =
              -0.5 *
                  [...this.model.values()]
                      .map(group => [...group.values()])
                      .flat()
                      .reduce((prev, curr) => prev + curr, 0);
      }
      /**
       * Parses the input sentence and returns a list of semantic chunks.
       *
       * @param sentence An input sentence.
       * @return The retrieved chunks.
       */
      parse(sentence) {
          if (sentence === '')
              return [];
          const boundaries = this.parseBoundaries(sentence);
          const result = [];
          let start = 0;
          for (const boundary of boundaries) {
              result.push(sentence.slice(start, boundary));
              start = boundary;
          }
          result.push(sentence.slice(start));
          return result;
      }
      /**
       * Parses the input sentence and returns a list of boundaries.
       *
       * @param sentence An input sentence.
       * @return The list of boundaries.
       */
      parseBoundaries(sentence) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
          const result = [];
          for (let i = 1; i < sentence.length; i++) {
              let score = this.baseScore;
              // NOTE: Score values in models may be negative.
              /* eslint-disable */
              score += ((_a = this.model.get('UW1')) === null || _a === void 0 ? void 0 : _a.get(sentence.substring(i - 3, i - 2))) || 0;
              score += ((_b = this.model.get('UW2')) === null || _b === void 0 ? void 0 : _b.get(sentence.substring(i - 2, i - 1))) || 0;
              score += ((_c = this.model.get('UW3')) === null || _c === void 0 ? void 0 : _c.get(sentence.substring(i - 1, i))) || 0;
              score += ((_d = this.model.get('UW4')) === null || _d === void 0 ? void 0 : _d.get(sentence.substring(i, i + 1))) || 0;
              score += ((_e = this.model.get('UW5')) === null || _e === void 0 ? void 0 : _e.get(sentence.substring(i + 1, i + 2))) || 0;
              score += ((_f = this.model.get('UW6')) === null || _f === void 0 ? void 0 : _f.get(sentence.substring(i + 2, i + 3))) || 0;
              score += ((_g = this.model.get('BW1')) === null || _g === void 0 ? void 0 : _g.get(sentence.substring(i - 2, i))) || 0;
              score += ((_h = this.model.get('BW2')) === null || _h === void 0 ? void 0 : _h.get(sentence.substring(i - 1, i + 1))) || 0;
              score += ((_j = this.model.get('BW3')) === null || _j === void 0 ? void 0 : _j.get(sentence.substring(i, i + 2))) || 0;
              score += ((_k = this.model.get('TW1')) === null || _k === void 0 ? void 0 : _k.get(sentence.substring(i - 3, i))) || 0;
              score += ((_l = this.model.get('TW2')) === null || _l === void 0 ? void 0 : _l.get(sentence.substring(i - 2, i + 1))) || 0;
              score += ((_m = this.model.get('TW3')) === null || _m === void 0 ? void 0 : _m.get(sentence.substring(i - 1, i + 2))) || 0;
              score += ((_o = this.model.get('TW4')) === null || _o === void 0 ? void 0 : _o.get(sentence.substring(i, i + 3))) || 0;
              /* eslint-enable */
              if (score > 0)
                  result.push(i);
          }
          return result;
      }
  }

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const assert = console.assert;
  const ZWSP_CODEPOINT = 0x200b; // U+200B ZERO WIDTH SPACE
  const ZWSP = String.fromCharCode(ZWSP_CODEPOINT);
  // We could use `Node.TEXT_NODE` and `Node.ELEMENT_NODE` in a browser context,
  // but we define the same here for Node.js environments.
  const NodeType = {
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
  };
  const DomAction = {
      Inline: 0, // An inline content, becomes a part of a paragraph.
      Block: 1, // A nested paragraph.
      Skip: 2, // Skip the content. The content before and after are connected.
      Break: 3, // A forced break. The content before and after become paragraphs.
      NoBreak: 4, // The content provides context, but it's not breakable.
      BreakOpportunity: 5, // Force a break opportunity.
  };
  /**
   * Determines the action from an element name, as defined in
   * {@link https://html.spec.whatwg.org/multipage/rendering.html HTML Rendering}.
   * See also {@link actionForElement}.
   */
  const domActions = {
      // Hidden elements
      // https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements
      AREA: DomAction.Skip,
      BASE: DomAction.Skip,
      BASEFONT: DomAction.Skip,
      DATALIST: DomAction.Skip,
      HEAD: DomAction.Skip,
      LINK: DomAction.Skip,
      META: DomAction.Skip,
      NOEMBED: DomAction.Skip,
      NOFRAMES: DomAction.Skip,
      PARAM: DomAction.Skip,
      RP: DomAction.Skip,
      SCRIPT: DomAction.Skip,
      STYLE: DomAction.Skip,
      TEMPLATE: DomAction.Skip,
      TITLE: DomAction.Skip,
      NOSCRIPT: DomAction.Skip,
      // Flow content
      // https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3
      HR: DomAction.Break,
      // Disable if `white-space: pre`.
      LISTING: DomAction.Skip,
      PLAINTEXT: DomAction.Skip,
      PRE: DomAction.Skip,
      XMP: DomAction.Skip,
      // Phrasing content
      // https://html.spec.whatwg.org/multipage/rendering.html#phrasing-content-3
      BR: DomAction.Break,
      RT: DomAction.Skip,
      WBR: DomAction.BreakOpportunity,
      // Form controls
      // https://html.spec.whatwg.org/multipage/rendering.html#form-controls
      INPUT: DomAction.Skip,
      SELECT: DomAction.Skip,
      BUTTON: DomAction.Skip,
      TEXTAREA: DomAction.Skip,
      // Other elements where the phrase-based line breaking should be disabled.
      // https://github.com/google/budoux/blob/main/budoux/skip_nodes.json
      ABBR: DomAction.Skip,
      CODE: DomAction.Skip,
      IFRAME: DomAction.Skip,
      TIME: DomAction.Skip,
      VAR: DomAction.Skip,
      // Deprecated, but supported in all browsers.
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nobr
      NOBR: DomAction.NoBreak,
  };
  const defaultBlockElements = new Set([
      // 15.3.2 The page
      'HTML',
      'BODY',
      // 15.3.3 Flow content
      'ADDRESS',
      'BLOCKQUOTE',
      'CENTER',
      'DIALOG',
      'DIV',
      'FIGURE',
      'FIGCAPTION',
      'FOOTER',
      'FORM',
      'HEADER',
      'LEGEND',
      'LISTING',
      'MAIN',
      'P',
      // 15.3.6 Sections and headings
      'ARTICLE',
      'ASIDE',
      'H1',
      'H2',
      'H3',
      'H4',
      'H5',
      'H6',
      'HGROUP',
      'NAV',
      'SECTION',
      // 15.3.7 Lists
      'DIR',
      'DD',
      'DL',
      'DT',
      'MENU',
      'OL',
      'UL',
      'LI',
      // 15.3.8 Tables
      'TABLE',
      'CAPTION',
      'COL',
      'TR',
      'TD',
      'TH',
      // 15.3.12 The fieldset and legend elements
      'FIELDSET',
      // 15.5.4 The details and summary elements
      'DETAILS',
      'SUMMARY',
      // 15.5.12 The marquee element
      'MARQUEE',
  ]);
  /**
   * Determine the action for a CSS `display` property value.
   * @param display The value of the CSS `display` property.
   * @return The {@link domActions} for the value.
   */
  function actionForDisplay(display) {
      // Handle common cases first.
      if (display === 'inline')
          return DomAction.Inline;
      if (display === 'block')
          return DomAction.Block;
      // Handle Ruby base as in-flow.
      if (display.startsWith('ruby')) {
          if (display === 'ruby-text')
              return DomAction.Skip;
          return DomAction.Inline;
      }
      // Handle other values including multi-value syntax as blocks.
      // https://drafts.csswg.org/css-display/#the-display-properties
      return DomAction.Block;
  }
  /**
   * Determine the action for an element.
   * @param element An element to determine the action for.
   * @return The {@link domActions} for the element.
   */
  function actionForElement(element) {
      const nodeName = element.nodeName;
      const action = domActions[nodeName];
      if (action !== undefined)
          return action;
      if (typeof globalThis.getComputedStyle === 'function') {
          const style = globalThis.getComputedStyle(element);
          switch (style.whiteSpace) {
              case 'nowrap':
              case 'pre':
                  return DomAction.NoBreak;
          }
          const display = style.display;
          if (display)
              return actionForDisplay(display);
          // `display` is an empty string if the element is not connected.
      }
      // Use the built-in rules if the `display` property is empty, or if
      // `getComputedStyle` is missing (e.g., jsdom.)
      return defaultBlockElements.has(nodeName)
          ? DomAction.Block
          : DomAction.Inline;
  }
  /**
   * Applies wrapping styles to make linebreak controls work in children.
   * @param element A parent element to apply the styles.
   */
  const applyWrapStyle = (element) => {
      element.style.wordBreak = 'keep-all';
      element.style.overflowWrap = 'anywhere';
  };
  /**
   * Represents a node in {@link Paragraph}.
   *
   * It wraps a {@link Text} or a {@link string}.
   *
   * A {@link string} provides the context for the parser, but it can't be split.
   */
  class NodeOrText {
      constructor(nodeOrText) {
          this.chunks = [];
          this.hasBreakOpportunityAfter = false;
          this.nodeOrText = nodeOrText;
      }
      static isString(value) {
          return typeof value === 'string';
      }
      get canSplit() {
          return !NodeOrText.isString(this.nodeOrText);
      }
      get text() {
          return NodeOrText.isString(this.nodeOrText)
              ? this.nodeOrText
              : this.nodeOrText.nodeValue;
      }
      get length() {
          var _a, _b;
          return (_b = (_a = this.text) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      /**
       * Split the {@link Text} in the same way as the {@link chunks}.
       * Joining all {@link chunks} must be equal to {@link text}.
       */
      split(separator) {
          const chunks = this.chunks;
          assert(chunks.length === 0 || chunks.join('') === this.text);
          if (chunks.length <= 1)
              return;
          if (NodeOrText.isString(this.nodeOrText))
              return;
          const node = this.nodeOrText;
          if (typeof separator === 'string') {
              // If the `separator` is a string, insert it at each boundary.
              node.nodeValue = chunks.join(separator);
              return;
          }
          // Otherwise create a `Text` node for each chunk, with the separator node
          // between them, and replace the `node` with them.
          const document = node.ownerDocument;
          let nodes = [];
          for (const chunk of chunks) {
              if (chunk)
                  nodes.push(document.createTextNode(chunk));
              // Add a separator between chunks. To simplify the logic, add a separator
              // after each chunk, then remove the last one.
              // To avoid `cloneNode` for the temporary one that is going to be removed,
              // add `null` as a marker, then replace them with `cloneNode` later.
              nodes.push(null);
          }
          nodes.pop();
          nodes = nodes.map(n => (n ? n : separator.cloneNode(true)));
          node.replaceWith(...nodes);
      }
  }
  /**
   * Represents a "paragraph", broken by block boundaries or forced breaks.
   *
   * A CSS
   * {@link https://drafts.csswg.org/css2/#inline-formatting inline formatting context}
   * is usually a "paragraph", but it can be broken into multiple paragraphs by
   * forced breaks such as `<br>`.
   */
  class Paragraph {
      constructor(element) {
          this.nodes = [];
          this.element = element;
      }
      isEmpty() {
          return this.nodes.length === 0;
      }
      get text() {
          return this.nodes.map(node => node.text).join('');
      }
      get lastNode() {
          return this.nodes.length ? this.nodes[this.nodes.length - 1] : undefined;
      }
      setHasBreakOpportunityAfter() {
          const lastNode = this.lastNode;
          if (lastNode)
              lastNode.hasBreakOpportunityAfter = true;
      }
      /**
       * @return Indices of forced break opportunities in the source.
       * They can be created by `<wbr>` tag or `&ZeroWidthSpace;`.
       */
      getForcedOpportunities() {
          const opportunities = [];
          let len = 0;
          for (const node of this.nodes) {
              if (node.canSplit) {
                  const text = node.text;
                  if (text) {
                      for (let i = 0; i < text.length; ++i) {
                          if (text.charCodeAt(i) === ZWSP_CODEPOINT) {
                              opportunities.push(len + i + 1);
                          }
                      }
                  }
              }
              len += node.length;
              if (node.hasBreakOpportunityAfter) {
                  opportunities.push(len);
              }
          }
          return opportunities;
      }
      /**
       * @return Filtered {@param boundaries} by excluding
       * {@link getForcedOpportunities} if it's not empty.
       * Otherwise {@param boundaries}.
       */
      excludeForcedOpportunities(boundaries) {
          const forcedOpportunities = this.getForcedOpportunities();
          if (!forcedOpportunities.length)
              return boundaries;
          const set = new Set(forcedOpportunities);
          return boundaries.filter(i => !set.has(i));
      }
  }
  /**
   * Adds HTML processing support to a BudouX {@link Parser}.
   */
  class HTMLProcessor {
      /**
       * @param parser A BudouX {@link Parser} to compute semantic line breaks.
       */
      constructor(parser, options) {
          /** See {@link HTMLProcessorOptions.separator}. */
          this.separator = ZWSP;
          this.parser_ = parser;
          if (options !== undefined) {
              if (options.className !== undefined)
                  this.className = options.className;
              if (options.separator !== undefined)
                  this.separator = options.separator;
          }
      }
      /**
       * Checks if the given element has a text node in its children.
       *
       * @param ele An element to be checked.
       * @return Whether the element has a child text node.
       */
      static hasChildTextNode(ele) {
          for (const child of ele.childNodes) {
              if (child.nodeType === NodeType.TEXT_NODE)
                  return true;
          }
          return false;
      }
      /**
       * Applies markups for semantic line breaks to the given HTML element.
       *
       * It breaks descendant nodes into paragraphs,
       * and applies the BudouX to each paragraph.
       * @param element The input element.
       */
      applyToElement(element) {
          for (const block of this.getBlocks(element)) {
              assert(!block.isEmpty());
              this.applyToParagraph(block);
          }
      }
      /**
       * Find paragraphs from a given HTML element.
       * @param element The root element to find paragraphs.
       * @param parent The parent {@link Paragraph} if any.
       * @return A list of {@link Paragraph}s.
       */
      *getBlocks(element, parent) {
          assert(element.nodeType === NodeType.ELEMENT_NODE);
          // Skip if it was once applied to this element.
          if (this.className && element.classList.contains(this.className))
              return;
          const action = actionForElement(element);
          if (action === DomAction.Skip)
              return;
          if (action === DomAction.Break) {
              if (parent && !parent.isEmpty()) {
                  parent.setHasBreakOpportunityAfter();
                  yield parent;
                  parent.nodes = [];
              }
              assert(!element.firstChild);
              return;
          }
          if (action === DomAction.BreakOpportunity) {
              if (parent)
                  parent.setHasBreakOpportunityAfter();
              return;
          }
          // Determine if this element creates a new inline formatting context, or if
          // this element belongs to the parent inline formatting context.
          assert(action === DomAction.Block ||
              action === DomAction.Inline ||
              action === DomAction.NoBreak);
          const isNewBlock = !parent || action === DomAction.Block;
          const block = isNewBlock ? new Paragraph(element) : parent;
          // Collect all text nodes in this inline formatting context, while searching
          // descendant elements recursively.
          for (const child of element.childNodes) {
              switch (child.nodeType) {
                  case NodeType.ELEMENT_NODE:
                      for (const childBlock of this.getBlocks(child, block))
                          yield childBlock;
                      break;
                  case NodeType.TEXT_NODE:
                      if (action === DomAction.NoBreak) {
                          const text = child.nodeValue;
                          if (text) {
                              block.nodes.push(new NodeOrText(text));
                          }
                          break;
                      }
                      block.nodes.push(new NodeOrText(child));
                      break;
              }
          }
          // Apply if this is an inline formatting context.
          if (isNewBlock && !block.isEmpty())
              yield block;
      }
      /**
       * Apply the BudouX to the given {@link Paragraph}.
       * @param paragraph The {@link Paragraph} to apply.
       */
      applyToParagraph(paragraph) {
          assert(paragraph.nodes.length > 0);
          if (!paragraph.nodes.some(node => node.canSplit))
              return;
          const text = paragraph.text;
          // No changes if whitespace-only.
          if (/^\s*$/.test(text))
              return;
          // Compute the phrase boundaries.
          const boundaries = this.parser_.parseBoundaries(text);
          // No changes if single phrase.
          if (boundaries.length <= 0)
              return;
          // The boundaries should be between 1 and `text.length - 1` in the
          // ascending order.
          assert(boundaries[0] > 0);
          assert(boundaries.every((x, i) => i === 0 || x > boundaries[i - 1]));
          assert(boundaries[boundaries.length - 1] < text.length);
          const adjustedBoundaries = paragraph.excludeForcedOpportunities(boundaries);
          // Add a sentinel to help iterating.
          adjustedBoundaries.push(text.length + 1);
          this.splitNodes(paragraph.nodes, adjustedBoundaries);
          this.applyBlockStyle(paragraph.element);
      }
      /**
       * Split {@link NodeOrText} at the specified boundaries.
       * @param nodes A list of {@link NodeOrText}.
       * @param boundaries A list of indices of the text to split at.
       */
      splitNodes(nodes, boundaries) {
          var _a;
          assert(boundaries.length > 0);
          assert(boundaries.every((x, i) => i === 0 || x > boundaries[i - 1]));
          const textLen = nodes.reduce((sum, node) => sum + node.length, 0);
          // The last boundary must be a sentinel.
          assert(boundaries[boundaries.length - 1] > textLen);
          // Distribute `boundaries` to `node.chunks`.
          let boundary_index = 0;
          let boundary = boundaries[0];
          assert(boundary > 0);
          let nodeStart = 0; // the start index of the `nodeText` in the whole text.
          let lastNode = null;
          for (const node of nodes) {
              assert(boundary >= nodeStart);
              assert(node.chunks.length === 0);
              const nodeText = node.text;
              if (!nodeText)
                  continue;
              const nodeLength = nodeText.length;
              const nodeEnd = nodeStart + nodeLength;
              assert(!lastNode || lastNode.canSplit);
              if (!node.canSplit) {
                  // If there's a boundary between nodes and `lastNode.canSplit`, add a
                  // boundary to the end of the `lastNode`.
                  if (lastNode && boundary === nodeStart) {
                      if (lastNode.chunks.length === 0)
                          lastNode.chunks.push((_a = lastNode.text) !== null && _a !== void 0 ? _a : '');
                      lastNode.chunks.push('');
                  }
                  while (boundary < nodeEnd) {
                      boundary = boundaries[++boundary_index];
                  }
                  lastNode = null;
                  nodeStart = nodeEnd;
                  continue;
              }
              // Check if the next boundary is in this `node`.
              lastNode = node;
              if (boundary >= nodeEnd) {
                  nodeStart = nodeEnd;
                  continue;
              }
              // Compute the boundary indices in the `node`.
              const chunks = node.chunks;
              let chunkStartInNode = 0;
              while (boundary < nodeEnd) {
                  const boundaryInNode = boundary - nodeStart;
                  assert(boundaryInNode >= chunkStartInNode);
                  chunks.push(nodeText.slice(chunkStartInNode, boundaryInNode));
                  chunkStartInNode = boundaryInNode;
                  boundary = boundaries[++boundary_index];
              }
              // Add the rest of the `nodeText`.
              assert(chunkStartInNode < nodeLength);
              chunks.push(nodeText.slice(chunkStartInNode));
              nodeStart = nodeEnd;
          }
          // Check if all nodes and boundaries are consumed.
          assert(nodeStart === textLen);
          assert(boundary_index < boundaries.length);
          assert(boundaries[boundary_index] >= textLen);
          // `node.chunks` are finalized. Split them.
          for (const node of nodes) {
              node.split(this.separator);
          }
      }
      /**
       * Applies the block style to the given element.
       * @param element The element to apply the block style.
       */
      applyBlockStyle(element) {
          if (this.className) {
              element.classList.add(this.className);
              return;
          }
          applyWrapStyle(element);
      }
  }
  /**
   * BudouX {@link Parser} with HTML processing support.
   */
  class HTMLProcessingParser extends Parser {
      constructor(model, htmlProcessorOptions = {
          separator: ZWSP,
      }) {
          super(model);
          this.htmlProcessor = new HTMLProcessor(this, htmlProcessorOptions);
      }
      /**
       * Applies markups for semantic line breaks to the given HTML element.
       * @param parentElement The input element.
       */
      applyToElement(parentElement) {
          this.htmlProcessor.applyToElement(parentElement);
      }
      /**
       * Translates the given HTML string to another HTML string with markups
       * for semantic line breaks.
       * @param html An input html string.
       * @return The translated HTML string.
       */
      translateHTMLString(html) {
          if (html === '')
              return html;
          const doc = parseFromString(html);
          if (HTMLProcessor.hasChildTextNode(doc.body)) {
              const wrapper = doc.createElement('span');
              wrapper.append(...doc.body.childNodes);
              doc.body.append(wrapper);
          }
          this.applyToElement(doc.body.childNodes[0]);
          return doc.body.innerHTML;
      }
  }

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Loads a parser equipped with the default Japanese model.
   * @return A parser with the default Japanese model.
   */
  const loadDefaultJapaneseParser = () => {
      return new HTMLProcessingParser(model);
  };

  // import barba from "@barba/core";
  var parser = loadDefaultJapaneseParser();
  var BudouX = /*#__PURE__*/function () {
    function BudouX() {
      _classCallCheck(this, BudouX);
      this.load();
      // barba.hooks.beforeOnce((data) => {
      //     this.load();
      // })
      // barba.hooks.after((data) => {
      //     this.load();
      // });
    }
    return _createClass$1(BudouX, [{
      key: "load",
      value: function load() {
        var elms = document.querySelectorAll('[data-budoux]');
        if (elms.length) {
          var _iterator = _createForOfIteratorHelper(elms),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var elm = _step.value;
              parser.applyElement(elm);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
    }]);
  }();

  window.constants = {
    enabled_legacy_browser: false
  };
  var APP = /*#__PURE__*/_createClass$1(function APP() {
    _classCallCheck(this, APP);
    var common$1 = new common();
    common$1.load();
    // new Barba();
    new Page();
    new Lottie();
    new BudouX();
  });
  new APP();

})();
